<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<style>
/* ═══════ BASE ═══════ */
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a1628;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;color:#e0e8f0;-webkit-tap-highlight-color:transparent;user-select:none}
#widgetContainer{position:relative;width:100%;height:100%;overflow:hidden}
#loading{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:#0a1628;z-index:100;font-size:14px;color:#6090c0;transition:opacity .3s}
#loading.hidden{opacity:0;pointer-events:none}

/* ═══════ TANK ═══════ */
#tankWrap{position:absolute;inset:0;overflow:hidden}
#tank{display:block;width:100%;height:100%}
#dirtCanvas{position:absolute;inset:0;width:100%;height:100%;pointer-events:none;z-index:12}

/* ═══════ HUD ═══════ */
.coin-display{position:absolute;top:8px;left:10px;display:flex;align-items:center;gap:4px;background:rgba(0,0,0,.45);border-radius:12px;padding:3px 10px 3px 6px;font-size:13px;font-weight:600;z-index:30;cursor:pointer}
#coinIcon{font-size:14px}
#coinCount{color:#ffd866}
#hudRight{position:absolute;top:8px;right:10px;display:flex;flex-direction:column;gap:4px;z-index:30}
.hud-bar{display:flex;align-items:center;gap:4px;background:rgba(0,0,0,.45);border-radius:8px;padding:3px 8px;font-size:10px;cursor:pointer;min-width:80px}
.hud-bar-label{width:10px;text-align:center}
.hud-bar-track{flex:1;height:5px;background:rgba(255,255,255,.12);border-radius:3px;overflow:hidden}
.hud-bar-fill{height:100%;border-radius:3px;transition:width .5s}
.hud-bar-val{font-size:9px;opacity:.7;min-width:22px;text-align:right}

/* ═══════ HUD TOOLTIP ═══════ */
#hudTooltip{position:absolute;top:38px;right:10px;background:rgba(10,22,40,.92);border:1px solid rgba(100,160,220,.3);border-radius:10px;padding:8px 12px;z-index:31;opacity:0;pointer-events:none;transform:translateY(-4px);transition:opacity .2s,transform .2s;max-width:200px;font-size:11px}
#hudTooltip.visible{opacity:1;pointer-events:auto;transform:translateY(0)}
#hudTooltipTitle{font-weight:600;margin-bottom:3px;font-size:12px}
#hudTooltipBody{opacity:.75;line-height:1.4}

/* ═══════ FISH BUBBLE ═══════ */
#fishBubble{position:absolute;background:rgba(10,22,40,.94);border:1px solid rgba(100,160,220,.35);border-radius:12px;padding:10px 14px;z-index:21;opacity:0;pointer-events:none;transition:opacity .2s;font-size:11px;min-width:150px;max-width:200px}
#fishBubble.visible{opacity:1;pointer-events:auto}
#fbName{font-weight:700;font-size:13px;margin-bottom:1px}
#fbSpecies{opacity:.6;font-size:10px;margin-bottom:6px}
#fbDetail{line-height:1.5}
.fb-stats{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:3px}
.fb-stat{font-size:10px;background:rgba(255,255,255,.08);padding:1px 6px;border-radius:4px}
.fb-earn{font-size:10px;opacity:.7;margin-bottom:2px}
.fb-warn{color:#ff8866;font-size:10px;font-weight:600;margin-top:2px}
.fb-trait{font-size:9px;opacity:.5;margin-top:1px}
.fb-actions{display:flex;gap:6px;margin-top:6px;padding-top:5px;border-top:1px solid rgba(100,160,220,.15)}
.fb-btn{padding:3px 10px;border-radius:5px;border:none;font-size:10px;font-weight:600;cursor:pointer}
.fb-sell{background:rgba(180,60,60,.5);color:#ffa0a0}
.fb-sell:hover{background:rgba(200,70,70,.6)}
#fbStage{}

/* ═══════ DECOR CARD ═══════ */
#decorCard{position:absolute;background:rgba(10,22,40,.94);border:1px solid rgba(100,160,220,.3);border-radius:10px;padding:10px 14px;z-index:22;opacity:0;pointer-events:none;transition:opacity .2s;font-size:11px;min-width:140px}
#decorCard.visible{opacity:1;pointer-events:auto}
#dcName{font-weight:600;font-size:12px;margin-bottom:2px}
#dcInfo{opacity:.6;font-size:10px;margin-bottom:6px;line-height:1.4}
#dcActions{display:flex;gap:6px}
#dcActions button{padding:4px 10px;border-radius:5px;border:none;font-size:10px;font-weight:600;cursor:pointer}
.dc-trim{background:rgba(80,160,80,.5);color:#b0ffb0}
.dc-trim:hover{background:rgba(80,160,80,.7)}
.dc-trim:disabled{opacity:.4;cursor:default}
.dc-sell{background:rgba(180,60,60,.5);color:#ffa0a0}
.dc-sell:hover{background:rgba(200,70,70,.6)}

/* ═══════ TANK NAV ═══════ */
#tankNav{position:absolute;bottom:8px;left:50%;transform:translateX(-50%);display:flex;align-items:center;gap:8px;background:rgba(0,0,0,.5);border-radius:16px;padding:3px 10px;z-index:40;font-size:11px}
#tankNav.hidden{display:none}
#tankNav button{background:none;border:none;color:#e0e8f0;font-size:14px;cursor:pointer;padding:2px 6px;opacity:.7}
#tankNav button:hover{opacity:1}
#tnLabel{font-weight:500;min-width:80px;text-align:center}

/* ═══════ BOTTOM BAR ═══════ */
#bottomBar{position:absolute;bottom:0;left:0;right:0;height:0;z-index:40}

/* ═══════ FAB ═══════ */
#fab{position:absolute;bottom:12px;right:12px;width:44px;height:44px;border-radius:50%;background:rgba(40,80,140,.85);border:2px solid rgba(100,160,220,.5);color:#e0e8f0;font-size:20px;display:flex;align-items:center;justify-content:center;cursor:pointer;z-index:65;transition:transform .2s,background .2s;box-shadow:0 2px 8px rgba(0,0,0,.4)}
#fab:hover{background:rgba(50,100,170,.9);transform:scale(1.05)}
#fab.active{background:rgba(60,120,200,.9);transform:rotate(45deg)}

/* ═══════ MENU OVERLAY ═══════ */
#menuOverlay{position:absolute;inset:0;background:rgba(5,12,25,.82);z-index:60;display:flex;align-items:center;justify-content:center;opacity:0;pointer-events:none;transition:opacity .2s}
#menuOverlay.visible{opacity:1;pointer-events:auto}
#menuGrid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;max-width:280px}
.menu-btn{display:flex;flex-direction:column;align-items:center;gap:4px;background:rgba(30,60,100,.6);border:1px solid rgba(100,160,220,.25);border-radius:12px;padding:14px 10px;color:#e0e8f0;font-size:11px;font-weight:500;cursor:pointer;transition:background .15s,transform .15s;min-width:75px}
.menu-btn:hover{background:rgba(40,80,140,.7);transform:scale(1.03)}
.menu-btn .menu-icon{font-size:22px}
.menu-btn.locked{opacity:.4;pointer-events:none}

/* ═══════ TOOL DOCK ═══════ */
#toolDock{position:absolute;bottom:0;left:0;right:0;background:rgba(10,22,40,.92);border-top:1px solid rgba(100,160,220,.25);z-index:42;padding:8px 12px;display:flex;align-items:center;gap:8px;transform:translateY(100%);transition:transform .25s;border-radius:12px 12px 0 0}
#toolDock.visible{transform:translateY(0)}
#toolDockContent{flex:1;display:flex;align-items:center;gap:8px;overflow-x:auto}
.dock-item{display:flex;flex-direction:column;align-items:center;gap:2px;padding:6px 10px;background:rgba(40,80,140,.4);border:1px solid rgba(100,160,220,.25);border-radius:8px;font-size:10px;cursor:pointer;min-width:56px;white-space:nowrap;transition:background .15s}
.dock-item:hover,.dock-item.active{background:rgba(60,120,200,.5);border-color:rgba(100,160,220,.5)}
.dock-item .dock-qty{font-size:9px;opacity:.6}
#cleanDockLabel{font-size:12px;font-weight:500;}
.dock-close{background:none;border:none;color:#e0e8f0;font-size:18px;cursor:pointer;padding:4px 8px;opacity:.7}
.dock-close:hover{opacity:1}

/* ═══════ PANELS ═══════ */
.panel{position:absolute;inset:0;background:rgba(8,18,35,.95);z-index:70;display:flex;flex-direction:column;opacity:0;pointer-events:none;transform:translateY(8px);transition:opacity .2s,transform .2s}
.panel.visible{opacity:1;pointer-events:auto;transform:translateY(0)}
.panel-header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(100,160,220,.15);font-weight:600;font-size:14px}
.panel-header button{background:none;border:none;color:#e0e8f0;font-size:18px;cursor:pointer;padding:4px 8px;opacity:.7}
.panel-header button:hover{opacity:1}
.panel-body{flex:1;overflow-y:auto;padding:10px 14px;-webkit-overflow-scrolling:touch}
.panel-section-title{font-size:11px;font-weight:600;text-transform:uppercase;opacity:.5;margin:12px 0 6px;letter-spacing:.5px}
.panel-section-title:first-child{margin-top:0}

/* ═══ Store items ═══ */
.s-item{display:flex;align-items:center;gap:10px;padding:8px;background:rgba(30,60,100,.25);border:1px solid rgba(100,160,220,.12);border-radius:8px;margin-bottom:6px;transition:opacity .2s}
.s-item.locked{opacity:.4}
.s-item.active-tank{border-color:rgba(100,200,140,.5);background:rgba(30,100,60,.2)}
.s-icon{font-size:20px;width:28px;text-align:center;flex-shrink:0}
.s-info{flex:1;min-width:0}
.s-name{font-size:12px;font-weight:500}
.s-desc{font-size:10px;opacity:.6;margin-top:1px}
.buy-btn{padding:4px 10px;border-radius:6px;border:none;font-size:11px;font-weight:600;cursor:pointer;white-space:nowrap;transition:background .15s}
.buy-btn.primary{background:#3070b0;color:#fff}
.buy-btn.primary:hover{background:#4088cc}
.buy-btn:disabled{background:rgba(60,80,100,.3);color:rgba(200,210,220,.4);cursor:default}
.sell-btn{background:rgba(180,60,60,.5);color:#ffa0a0;padding:3px 8px;border-radius:5px;border:none;font-size:10px;cursor:pointer}
.sell-btn:hover{background:rgba(200,70,70,.6)}

/* ═══ Store tabs ═══ */
.store-tabs{display:flex;gap:4px;margin-bottom:10px;flex-wrap:wrap}
.store-tab{padding:4px 10px;border-radius:6px;border:1px solid rgba(100,160,220,.2);background:transparent;color:#e0e8f0;font-size:11px;cursor:pointer;opacity:.6;transition:all .15s}
.store-tab.active{opacity:1;background:rgba(40,80,140,.4);border-color:rgba(100,160,220,.4)}

/* ═══════ TOAST ═══════ */
#toast{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%) scale(.9);background:rgba(10,22,40,.92);border:1px solid rgba(100,160,220,.3);border-radius:12px;padding:10px 18px;z-index:50;font-size:13px;font-weight:500;text-align:center;opacity:0;pointer-events:none;transition:opacity .3s,transform .3s;max-width:80%}
#toast.visible{opacity:1;transform:translate(-50%,-50%) scale(1)}

/* ═══════ FLOAT TEXT ═══════ */
.float-text{position:absolute;font-size:12px;font-weight:700;color:#ffd866;text-shadow:0 1px 3px rgba(0,0,0,.6);pointer-events:none;z-index:20;animation:floatUp 1.5s ease-out forwards}
@keyframes floatUp{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-30px)}}

/* ═══════ SCROLLBAR ═══════ */
.panel-body::-webkit-scrollbar{width:4px}
.panel-body::-webkit-scrollbar-track{background:transparent}
.panel-body::-webkit-scrollbar-thumb{background:rgba(100,160,220,.25);border-radius:2px}

/* ═══════ RESET BUTTON ═══════ */
.reset-btn{display:block;margin:16px auto 0;padding:8px 20px;background:rgba(180,50,50,.5);border:1px solid rgba(200,80,80,.4);border-radius:8px;color:#ffa0a0;font-size:12px;cursor:pointer}
.reset-btn:hover{background:rgba(200,60,60,.6)}

/* ═══════ PIXEL ICONS ═══════ */
.hud-px-icon,.tn-btn{display:inline-flex;align-items:center;justify-content:center}
.menu-icon{display:inline-flex;align-items:center;justify-content:center;font-size:0}
.hud-px-icon img,.menu-icon img,.tn-btn img,#fab img{image-rendering:pixelated;display:block}
</style>
</head>
<body>
<div id="widgetContainer" data-tank="fresh" data-tier="1">
  <div id="loading">Loading aquarium…</div>
  <div id="tankWrap">
    <canvas id="tank"></canvas>
    <canvas id="dirtCanvas"></canvas>

    <!-- HUD -->
    <div class="coin-display" id="coinDisplay">
      <span id="coinIcon" class="hud-px-icon" data-icon="coin"></span>
      <span id="coinCount">0</span>
    </div>
    <div id="hudRight">
      <div id="cleanBar" class="hud-bar">
        <span class="hud-bar-label hud-px-icon" data-icon="broom"></span>
        <div class="hud-bar-track"><div class="hud-bar-fill" id="cleanFill" style="width:100%;background:#4caf88"></div></div>
        <span class="hud-bar-val" id="cleanVal">100%</span>
      </div>
      <div id="hungerBar" class="hud-bar">
        <span class="hud-bar-label hud-px-icon" data-icon="food"></span>
        <div class="hud-bar-track"><div class="hud-bar-fill" id="hungerFill" style="width:100%;background:#e8a040"></div></div>
        <span class="hud-bar-val" id="hungerVal">100%</span>
      </div>
    </div>

    <!-- HUD Tooltip -->
    <div id="hudTooltip">
      <div id="hudTooltipTitle"></div>
      <div id="hudTooltipBody"></div>
    </div>

    <!-- Fish bubble -->
    <div id="fishBubble">
      <div id="fbName"></div>
      <div id="fbSpecies"></div>
      <div id="fbDetail"></div>
      <div id="fbStage"></div>
    </div>

    <!-- Decor card -->
    <div id="decorCard">
      <div id="dcName"></div>
      <div id="dcInfo"></div>
      <div id="dcActions"></div>
    </div>

    <!-- Tank nav -->
    <div id="tankNav" class="hidden">
      <button id="tnPrev" class="tn-btn" data-icon="arrow_l"></button>
      <span id="tnLabel"></span>
      <button id="tnNext" class="tn-btn" data-icon="arrow_r"></button>
    </div>

    <!-- Bottom bar -->
    <div id="bottomBar"></div>
  </div>

  <!-- FAB -->
  <button id="fab" data-icon="menu"></button>

  <!-- Menu overlay -->
  <div id="menuOverlay">
    <div id="menuGrid">
      <button class="menu-btn" data-action="feed"><span class="menu-icon" data-icon="fish"></span>Feed</button>
      <button class="menu-btn" data-action="clean"><span class="menu-icon" data-icon="broom"></span>Clean</button>
      <button class="menu-btn" data-action="laser"><span class="menu-icon" data-icon="laser"></span>Play</button>
      <button class="menu-btn" data-action="store"><span class="menu-icon" data-icon="store"></span>Store</button>
      <button class="menu-btn" data-action="upgrades"><span class="menu-icon" data-icon="wrench"></span>Tools</button>
      <button class="menu-btn" data-action="inventory"><span class="menu-icon" data-icon="clipboard"></span>Fish</button>
      <button class="menu-btn" data-action="tanks"><span class="menu-icon" data-icon="house"></span>Tanks</button>
      <button class="menu-btn" data-action="help"><span class="menu-icon" data-icon="help"></span>Help</button>
    </div>
  </div>

  <!-- Tool dock -->
  <div id="toolDock">
    <div id="toolDockContent"></div>
    <button class="dock-close">✕</button>
  </div>

  <!-- Panels -->
  <div id="storePanel" class="panel">
    <div class="panel-header"><span>Store</span><span id="storeCap"></span><button data-close="storePanel">✕</button></div>
    <div id="storeList" class="panel-body"></div>
  </div>
  <div id="upgradesPanel" class="panel">
    <div class="panel-header"><span>Tools &amp; Equipment</span><button data-close="upgradesPanel">✕</button></div>
    <div id="upgradesList" class="panel-body"></div>
  </div>
  <div id="inventoryPanel" class="panel">
    <div class="panel-header"><span>Fish &amp; Supplies</span><button data-close="inventoryPanel">✕</button></div>
    <div id="inventoryList" class="panel-body"></div>
  </div>
  <div id="tanksPanel" class="panel">
    <div class="panel-header"><span>Tanks</span><button data-close="tanksPanel">✕</button></div>
    <div id="tanksList" class="panel-body"></div>
  </div>
  <div id="helpPanel" class="panel">
    <div class="panel-header"><span>Help</span><button data-close="helpPanel">✕</button></div>
    <div id="helpBody" class="panel-body"></div>
  </div>

  <!-- Toast -->
  <div id="toast"></div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════════════
// Aquarium Widget — Client Renderer (Homey SDK 3)
//
// Hybrid Canvas + DOM:  Canvas for game world, DOM for HUD/menus/panels.
// All game logic lives server-side. Client is a "dumb renderer".
// ═══════════════════════════════════════════════════════════════════════════════

// ═══════ CONSTANTS ═══════

const TANK_TIER_MAP = { fresh: '1', tropical: '2', salt: '3' };
const BIOMES = {
  fresh: {
    bg: ['#5aad90','#1e4838'], wall: '#1a3830', substrate: '#9a8060',
    subH: 0.16, bubbleRate: 0.08, label: 'Fresh Starter',
  },
  tropical: {
    bg: ['#30a8c0','#145058'], wall: '#0c4040', substrate: '#a89870',
    subH: 0.14, bubbleRate: 0.12, label: 'Tropical Planted',
  },
  salt: {
    bg: ['#1858a0','#081840'], wall: '#051028', substrate: '#d8c8a8',
    subH: 0.13, bubbleRate: 0.16, label: 'Saltwater Reef',
  },
};

const FISH_SPRITES = {
  guppy:      { w:12, h:7, data:['000222000000','002133500000','021344510000','213345510000','021333100000','002211000000','000020000000'] },
  goldfish:   { w:14, h:9, data:['00002200000000','00021331000000','00221345100000','02213351100000','22113351100000','22113311000000','00221331000000','00022110000000','00002200000000'] },
  snail:      { w:10, h:7, data:['0003333000','0033334300','0333343300','0034443000','0041104100','0410010400','0010001000'] },
  neon_tetra: { w:12, h:7, data:['000111000000','016666510000','016655110000','011655100000','013361000000','001110000000','000020000000'] },
  blue_eye:   { w:12, h:7, data:['000110000000','001135100000','011355100000','011335100000','011131000000','001110000000','000020000000'] },
  moon_fish:  { w:14, h:9, data:['00000110000000','00011131000000','00113351000000','01113351100000','01113351100000','01113351100000','00113310000000','00011110000000','00000110000000'] },
  discus:     { w:14, h:11, data:['00000110000000','00001131000000','00011331000000','00113451000000','01113631100000','01113631100000','01113631100000','00113451000000','00011331000000','00001131000000','00000110000000'] },
  pleco:      { w:16, h:7, data:['0000000000000000','0001111111100000','0011334511110000','0111111111111000','0011111111110000','0001111111100000','0001100011000000'] },
  gourami:    { w:14, h:9, data:['00002200000000','00021131000000','00211335100000','02211335100000','22113351100000','22113311000000','00211310000000','00021130000000','00002200000000'] },
  clownfish:  { w:14, h:9, data:['00002200000000','00021161000000','00211635100000','02211636100000','22113636100000','22113616100000','00211161000000','00021160000000','00002200000000'] },
  blue_tang:  { w:16, h:11, data:['0000002200000000','0000021130000000','0000211331000000','0002113351000000','0021133631100000','0211336631100000','0021133631100000','0002113351000000','0000211331000000','0000021130000000','0000002200000000'] },
  green_chromis: { w:12, h:7, data:['000111000000','011335100000','011315000000','011131000000','001110000000','000020000000','000000000000'] },
  firefish:   { w:14, h:7, data:['00000110000000','00011333100000','00113335100000','01113335100000','00113331000000','00001130000000','00000220000000'] },
  royal_gramma: { w:14, h:9, data:['00002200000000','00021131000000','00211335100000','02111336100000','21113361100000','02611361000000','00261130000000','00026130000000','00002200000000'] },
  banggai_cardinal: { w:12, h:7, data:['000220000000','021361100000','221645100000','021361100000','002200000000','000200000000','000000000000'] },
  moray_eel:  { w:20, h:7, data:['00000000000000000000','00001111111111000000','00011333451111100000','00111111131111110000','00011111111111100000','00001111111111000000','00000000000000000000'] },
  cleaner_shrimp: { w:12, h:7, data:['000005500000','000113300000','001334510000','001133100000','000113000000','001001010000','010001000000'] },
};

const FISH_PALETTES = {
  guppy:      { 1:'#FF8844', 2:'#FF5522', 3:'#FFCC88', 4:'#AA4400', 5:'#111' },
  goldfish:   { 1:'#FFB833', 2:'#FF9500', 3:'#FFE088', 4:'#CC7700', 5:'#111' },
  snail:      { 1:'#D4B896', 2:'#B89878', 3:'#8B6B4A', 4:'#A08060', 5:'#111' },
  neon_tetra: { 1:'#C0C8D0', 2:'#FF3333', 3:'#FF5050', 4:'#333', 5:'#111', 6:'#3388FF' },
  blue_eye:   { 1:'#88CCEE', 2:'#5599CC', 3:'#AADDFF', 4:'#336688', 5:'#2266FF' },
  moon_fish:  { 1:'#CCE0CC', 2:'#88BB88', 3:'#E8FFE8', 4:'#668866', 5:'#111' },
  discus:     { 1:'#FF6644', 2:'#DD4422', 3:'#FF8866', 4:'#CC3311', 5:'#111', 6:'#FF4422' },
  pleco:      { 1:'#665544', 2:'#554433', 3:'#887766', 4:'#443322', 5:'#111' },
  gourami:    { 1:'#5599CC', 2:'#3377AA', 3:'#88CCEE', 4:'#224466', 5:'#111' },
  clownfish:  { 1:'#FF6600', 2:'#FF4400', 3:'#FF8833', 4:'#CC4400', 5:'#111', 6:'#FFFFFF' },
  blue_tang:  { 1:'#3355BB', 2:'#FFDD33', 3:'#5577DD', 4:'#223399', 5:'#111', 6:'#FFDD33' },
  green_chromis: { 1:'#55BB77', 2:'#339955', 3:'#88EEBB', 4:'#227744', 5:'#111' },
  firefish:   { 1:'#FF4444', 2:'#FFAA33', 3:'#FFCC44', 4:'#CC2222', 5:'#111' },
  royal_gramma: { 1:'#8833CC', 2:'#7722BB', 3:'#AA55EE', 4:'#5511AA', 5:'#111', 6:'#FFDD33' },
  banggai_cardinal: { 1:'#CCCCCC', 2:'#AAAAAA', 3:'#EEEEEE', 4:'#555', 5:'#111', 6:'#222' },
  moray_eel:  { 1:'#667744', 2:'#556633', 3:'#8B9966', 4:'#445522', 5:'#FFDD33' },
  cleaner_shrimp: { 1:'#EE4444', 2:'#CC2222', 3:'#FFFFFF', 4:'#AA0000', 5:'#FFFFFF' },
};

const DECOR_COLORS = {
  hornwort:'#44AA44', moss_ball:'#339933', rock_pile:'#888888', driftwood:'#8B6B4A',
  treasure_chest:'#AA7733', java_fern:'#338833', amazon_sword:'#228822', floating_plants:'#55BB55',
  mossy_log:'#6B4B2A', hollow_stump:'#5A3A1A', anemone:'#FF6688', live_rock:'#999999',
  brain_coral:'#DD8844', staghorn_coral:'#DDAA66', cave:'#444444', sea_fan:'#CC5599',
};

const ZONE_RANGES = { top:[0.08,0.35], middle:[0.25,0.65], bottom:[0.55,0.82], any:[0.15,0.75] };

// Species base display scales (relative to PX_SCALE) — larger fish are bigger on screen
const FISH_BASE_SCALES = {
  guppy: 1.0, goldfish: 1.5, snail: 1.1,
  neon_tetra: 0.9, blue_eye: 0.95, moon_fish: 1.4, discus: 1.7, pleco: 1.6, gourami: 1.4,
  clownfish: 1.3, blue_tang: 1.6, green_chromis: 0.9, firefish: 1.1,
  royal_gramma: 1.2, banggai_cardinal: 1.0, moray_eel: 2.2, cleaner_shrimp: 1.0,
};

// ═══════ PIXEL ICON SYSTEM ═══════
// Pre-rendered pixel art icons replace all emojis for consistent style.
// Each icon is a small sprite rendered to a Data URL at init.

const ICON_DATA = {
  coin: { w:7,h:7, pal:{1:'#b8860b',2:'#daa520',3:'#ffd700',4:'#ffe566'},
    d:['0011100','0233320','1344431','1344431','1344431','0233320','0011100'] },
  broom: { w:7,h:7, pal:{1:'#8B7355',2:'#A0522D',3:'#D2B48C',4:'#90EE90'},
    d:['0004000','0004000','0034000','0134000','0113000','1113000','0110000'] },
  food: { w:7,h:7, pal:{1:'#888',2:'#aaa',3:'#ccc',4:'#ddd'},
    d:['0000000','0333300','3444430','3444430','3444430','0222200','0000000'] },
  fish: { w:9,h:5, pal:{1:'#4488cc',2:'#66aaee',3:'#88ccff',4:'#224466',5:'#111'},
    d:['001110000','012234000','123345100','012234000','001110000'] },
  store: { w:7,h:7, pal:{1:'#666',2:'#888',3:'#aaa',4:'#ccc'},
    d:['1100011','0100010','0222220','0344430','0344430','0344430','0222220'] },
  wrench: { w:7,h:7, pal:{1:'#708090',2:'#a0b0c0',3:'#c0d0e0',4:'#506070'},
    d:['0002200','0012300','0012300','0011000','0011000','0011000','0001000'] },
  clipboard: { w:7,h:7, pal:{1:'#8B7355',2:'#D2B48C',3:'#FFF8DC',4:'#888'},
    d:['0111100','1233310','1233310','1244410','1233310','1233310','0111100'] },
  house: { w:7,h:7, pal:{1:'#4682B4',2:'#6495ED',3:'#87CEEB',4:'#ADD8E6'},
    d:['0001000','0012100','0123210','1234321','0123210','0123210','0111110'] },
  help: { w:7,h:7, pal:{1:'#5599dd',2:'#77bbff',3:'#99ddff',4:'#fff'},
    d:['0111100','1222210','0002210','0022100','0022100','0000000','0022100'] },
  laser: { w:7,h:7, pal:{1:'#800',2:'#c00',3:'#f44',4:'#f88'},
    d:['0001000','0012100','0123210','1234321','0123210','0012100','0001000'] },
  close: { w:5,h:5, pal:{1:'#999',2:'#ccc'},
    d:['10001','02020','00200','02020','10001'] },
  menu: { w:7,h:5, pal:{1:'#ccc',2:'#fff'},
    d:['1111111','0000000','1111111','0000000','1111111'] },
  lock: { w:7,h:7, pal:{1:'#888',2:'#aaa',3:'#daa520',4:'#ffd700'},
    d:['0022200','0211200','0200200','0344430','0344430','0344430','0333300'] },
  arrow_l: { w:5,h:7, pal:{1:'#aaa',2:'#ddd'},
    d:['00010','00110','01210','12210','01210','00110','00010'] },
  arrow_r: { w:5,h:7, pal:{1:'#aaa',2:'#ddd'},
    d:['01000','01100','01210','01221','01210','01100','01000'] },
  plant: { w:5,h:7, pal:{1:'#2d6b2d',2:'#3a8a3a',3:'#5cb85c',4:'#8fd88f'},
    d:['00300','03430','34340','03430','00200','00100','00100'] },
  decor: { w:7,h:5, pal:{1:'#666',2:'#888',3:'#aaa',4:'#ccc'},
    d:['0023200','0234320','2344432','1233321','1111111'] },
  heater: { w:5,h:9, pal:{1:'#aa3333',2:'#cc4444',3:'#ff6666',4:'#ffaa88'},
    d:['01110','12221','12321','12321','12321','12321','12321','12221','01110'] },
  filter: { w:7,h:9, pal:{1:'#556677',2:'#778899',3:'#99aabb',4:'#88bbff'},
    d:['0111110','1222221','1234321','1222221','1234321','1222221','1234321','1222221','0111110'] },
  skimmer: { w:5,h:9, pal:{1:'#999',2:'#bbb',3:'#ddd',4:'#fff'},
    d:['01110','12221','13331','12221','12221','12221','13331','12221','01110'] },
  uv: { w:5,h:9, pal:{1:'#6633cc',2:'#8855ee',3:'#aa77ff',4:'#ddbbff'},
    d:['01110','12221','12321','13431','14341','13431','12321','12221','01110'] },
};

const iconCache = {};

function renderPixelIcon(key, scale) {
  const cacheKey = key + '_' + scale;
  if (iconCache[cacheKey]) return iconCache[cacheKey];
  const ic = ICON_DATA[key];
  if (!ic) return '';
  const c = document.createElement('canvas');
  c.width = ic.w * scale; c.height = ic.h * scale;
  const cx = c.getContext('2d');
  cx.imageSmoothingEnabled = false;
  for (let y = 0; y < ic.h; y++) {
    for (let x = 0; x < ic.w; x++) {
      const ch = ic.d[y][x];
      if (ch === '0') continue;
      cx.fillStyle = ic.pal[ch] || '#888';
      cx.fillRect(x * scale, y * scale, scale, scale);
    }
  }
  const url = c.toDataURL();
  iconCache[cacheKey] = url;
  return url;
}

function iconImg(key, size) {
  const s = size || 16;
  const scale = Math.max(2, Math.round(s / 7));
  return `<img src="${renderPixelIcon(key, scale)}" width="${s}" height="${s}" style="image-rendering:pixelated;vertical-align:middle" alt="">`;
}

// ═══════ STATE ═══════

let W = 400, H = 300, DPR = 1, PX_SCALE = 3;
let gameState = null;
let tankCat = null;
let storeData = null;
let tanksList = null;
let globalCat = null;
let activeTankId = 'fresh';

// Animation state per fish
let fishAnims = {};
// Schooling anchors per species
let schoolAnchors = {};
// Particles
let bubbles = [];
let foodParticles = [];
let floatTexts = [];
// Sprite cache
let spriteCache = {};
// UI state
let activeMode = null; // 'feed' | 'clean' | 'laser' | null
let selectedFoodId = null;
let activePanel = null;
let menuOpen = false;
let storeTab = 'fish';
// Cleaning state
let cleanMask = null;
let cleanSeed = 0;
let cleanGridW = 64, cleanGridH = 48;
let cleanDirtyStart = 0;
// Laser state
let laserPos = null;
let laserActive = false;
let laserStartTime = 0;
// Tooltip
let tooltipTimer = null;
let selectedFishId = null; // only this fish shows level badge
let selectedFishTimer = null;
// Decor dragging state
let draggingDecor = null; // { id, decorId, startX, startY }
let floatingDriftPhase = 0; // for floating plant gentle drift
// Game time
let lastFrameTime = 0;
let refreshTimer = null;

// ═══════ DOM REFS ═══════

const $ = id => document.getElementById(id);
const canvas = $('tank');
const ctx = canvas.getContext('2d');
const dirtCanvas = $('dirtCanvas');
const dirtCtx = dirtCanvas.getContext('2d');

// ═══════ API LAYER ═══════

const API = {
  widgetId: 'default',
  async init() {
    try { this.widgetId = await Homey.getWidgetInstanceId(); } catch(e) { /* sandbox fallback */ }
  },
  async getState() {
    return Homey.api('GET', `/?widgetId=${encodeURIComponent(this.widgetId)}`);
  },
  async doAction(type, payload) {
    return Homey.api('POST', `/?widgetId=${encodeURIComponent(this.widgetId)}`, { type, payload: payload || {} });
  },
};

// ═══════ SPRITE PRE-RENDERING ═══════

function buildSpriteCache() {
  spriteCache = {};
  for (const [key, sp] of Object.entries(FISH_SPRITES)) {
    const pal = FISH_PALETTES[key];
    if (!pal) continue;
    spriteCache[key] = {
      right: renderSprite(sp, pal, PX_SCALE, false),
      left: renderSprite(sp, pal, PX_SCALE, true),
    };
  }
}

function renderSprite(sp, palette, scale, flip) {
  const c = document.createElement('canvas');
  c.width = sp.w * scale;
  c.height = sp.h * scale;
  const cx = c.getContext('2d');
  cx.imageSmoothingEnabled = false;
  for (let y = 0; y < sp.h; y++) {
    const row = sp.data[y];
    for (let x = 0; x < sp.w; x++) {
      const ch = row[x];
      if (ch === '0') continue;
      const color = palette[ch];
      if (!color) continue;
      cx.fillStyle = color;
      const dx = flip ? (sp.w - 1 - x) * scale : x * scale;
      cx.fillRect(dx, y * scale, scale, scale);
    }
  }
  return c;
}

// ═══════ RENDERING — ENVIRONMENT ═══════

function renderEnvironment(biomeKey) {
  const b = BIOMES[biomeKey] || BIOMES.fresh;

  // Water gradient — deeper color transition
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, b.bg[0]);
  grad.addColorStop(0.5, b.bg[1]);
  grad.addColorStop(1, shadeColor(b.bg[1], -15));
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Underwater light rays from surface
  const time = Date.now() / 3000;
  ctx.globalAlpha = 0.03;
  ctx.fillStyle = '#ffffff';
  for (let i = 0; i < 7; i++) {
    const rayX = ((time * 12 + i * 65) % (W + 60)) - 30;
    const rayW = 8 + Math.sin(time + i) * 4;
    ctx.beginPath();
    ctx.moveTo(rayX - rayW, 0);
    ctx.lineTo(rayX + rayW, 0);
    ctx.lineTo(rayX + rayW * 2.5, H * 0.7);
    ctx.lineTo(rayX - rayW * 1.5, H * 0.7);
    ctx.closePath();
    ctx.fill();
  }

  // Caustic light patterns — animated dappled light
  ctx.globalAlpha = 0.025;
  for (let i = 0; i < 12; i++) {
    const cx = Math.sin(time * 0.4 + i * 2.1) * W * 0.4 + W * 0.5;
    const cy = Math.cos(time * 0.3 + i * 1.7) * H * 0.2 + H * 0.25;
    const r = 15 + Math.sin(time * 0.8 + i) * 8;
    ctx.beginPath();
    ctx.ellipse(cx, cy, r, r * 0.6, time * 0.1 + i, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Substrate — multi-layer for depth
  const subY = H * (1 - b.subH);
  // Dark substrate base
  ctx.fillStyle = shadeColor(b.substrate, -20);
  ctx.fillRect(0, subY, W, H - subY);
  // Lighter top layer
  const subGrad = ctx.createLinearGradient(0, subY, 0, H);
  subGrad.addColorStop(0, b.substrate);
  subGrad.addColorStop(0.3, shadeColor(b.substrate, -10));
  subGrad.addColorStop(1, shadeColor(b.substrate, -25));
  ctx.fillStyle = subGrad;
  ctx.fillRect(0, subY, W, H - subY);

  // Substrate pebble texture — varied sizes and colors
  const rng = seededRng(42);
  for (let i = 0; i < 120; i++) {
    const gx = rng() * W;
    const gy = subY + 2 + rng() * (H - subY - 4);
    const shade = ((rng() - 0.5) * 40) | 0;
    ctx.fillStyle = shadeColor(b.substrate, shade);
    const pw = 1 + rng() * 3.5;
    const ph = 0.8 + rng() * 1.5;
    ctx.fillRect(gx, gy, pw, ph);
  }
  // Substrate highlight line — softer
  ctx.fillStyle = 'rgba(255,255,255,.08)';
  ctx.fillRect(0, subY, W, 1.5);
  ctx.fillStyle = 'rgba(255,255,255,.03)';
  ctx.fillRect(0, subY + 1.5, W, 1);

  // Water surface shimmer — more dynamic
  ctx.globalAlpha = 0.07;
  ctx.fillStyle = '#ffffff';
  for (let i = 0; i < 10; i++) {
    const sx = Math.sin(time * 0.8 + i * 1.2) * 25 + i * (W / 10);
    const sw = 25 + Math.sin(time * 1.2 + i) * 12;
    ctx.fillRect(sx, 0, sw, 2.5);
    ctx.fillRect(sx + 5, 2.5, sw * 0.6, 1);
  }
  ctx.globalAlpha = 1;

  // Depth fog near bottom — subtle dark gradient at bottom
  const fogGrad = ctx.createLinearGradient(0, subY - 20, 0, subY);
  fogGrad.addColorStop(0, 'rgba(0,0,0,0)');
  fogGrad.addColorStop(1, 'rgba(0,0,0,.06)');
  ctx.fillStyle = fogGrad;
  ctx.fillRect(0, subY - 20, W, 20);

  // Glass frame — subtle edge borders with inner reflection
  ctx.strokeStyle = 'rgba(150,200,255,.06)';
  ctx.lineWidth = 2;
  ctx.strokeRect(1, 1, W - 2, H - 2);
  // Inner glass reflection strips — animated subtle shimmer
  const reflAlpha = 0.02 + Math.sin(time * 0.5) * 0.01;
  ctx.fillStyle = `rgba(150,200,255,${reflAlpha})`;
  ctx.fillRect(0, 0, 4, H);
  ctx.fillRect(W - 4, 0, 4, H);
  // Top reflection
  ctx.fillStyle = 'rgba(200,230,255,.04)';
  ctx.fillRect(0, 0, W, 3);
}

// ═══════ RENDERING — DECOR ═══════

function renderDecor(decors, biomeKey) {
  if (!decors || !tankCat) return;
  const biome = BIOMES[biomeKey] || BIOMES.fresh;
  const subY = H * (1 - biome.subH);

  for (const d of decors) {
    const def = tankCat.content?.decor?.[d.decorId];
    if (!def) continue;
    const color = DECOR_COLORS[d.decorId] || '#888';
    const x = d.x * W;
    const baseSize = Math.max(12, (d.size || 1) * PX_SCALE * 8);

    if (def.placement === 'top') {
      // Floating plants — clusters of lily-pad shapes at surface
      // Add gentle drift animation
      const time = Date.now() / 4000;
      const driftX = Math.sin(time + d.x * 10) * 3;
      const driftY = Math.sin(time * 0.7 + d.x * 7) * 1.5;
      ctx.save();
      const rng = seededRng(Math.round(d.x * 10000));
      for (let i = 0; i < 3; i++) {
        const ox = x + driftX + (rng() - 0.5) * baseSize;
        const r = baseSize * (0.3 + rng() * 0.3);
        ctx.fillStyle = shadeColor(color, ((rng() - 0.5) * 30) | 0);
        ctx.globalAlpha = 0.85;
        ctx.beginPath();
        ctx.ellipse(ox, 3 + driftY + rng() * 6, r, r * 0.4, rng() * 0.3, 0, Math.PI * 2);
        ctx.fill();
        // highlight
        ctx.fillStyle = shadeColor(color, 30);
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.ellipse(ox - r * 0.2, 2 + driftY + rng() * 4, r * 0.4, r * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
      ctx.restore();
    } else if (def.growth) {
      // Plant — draw stem with multiple leaves
      const ph = baseSize * 2;
      const baseY = subY;
      const topY = baseY - ph;
      const rng = seededRng(Math.round(d.x * 10000) + 99);

      // Stems
      const stemCount = 1 + Math.floor(rng() * 2);
      for (let s = 0; s < stemCount; s++) {
        const sx = x + (s - stemCount / 2) * 4;
        ctx.strokeStyle = shadeColor(color, -20);
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(sx, baseY);
        const cp1x = sx + (rng() - 0.5) * 12;
        const cp1y = baseY - ph * 0.5;
        ctx.quadraticCurveTo(cp1x, cp1y, sx + (rng() - 0.5) * 6, topY + rng() * ph * 0.2);
        ctx.stroke();
      }

      // Leaves along stem
      const leafCount = 4 + Math.floor(rng() * 4);
      for (let i = 0; i < leafCount; i++) {
        const t = (i + 0.5) / leafCount;
        const ly = baseY - ph * t;
        const lx = x + (rng() - 0.5) * 8;
        const dir = i % 2 === 0 ? 1 : -1;
        const leafW = baseSize * (0.3 + rng() * 0.2) * dir;
        const leafH = baseSize * 0.15;
        ctx.fillStyle = shadeColor(color, ((rng() - 0.5) * 25) | 0);
        ctx.beginPath();
        ctx.moveTo(lx, ly);
        ctx.quadraticCurveTo(lx + leafW, ly - leafH, lx + leafW * 0.6, ly + leafH * 0.5);
        ctx.quadraticCurveTo(lx + leafW * 0.3, ly + leafH, lx, ly);
        ctx.fill();
      }
    } else {
      // Solid decor — draw proper shapes based on type
      const dw = baseSize * 1.4;
      const dh = baseSize * 0.9;
      const dy = subY - dh;

      if (d.decorId.includes('rock') || d.decorId === 'live_rock') {
        // Rocky pile with highlights
        const rng = seededRng(Math.round(d.x * 10000) + 55);
        for (let r = 0; r < 3; r++) {
          const rx = x + (rng() - 0.5) * dw * 0.5;
          const ry = subY - rng() * dh * 0.8;
          const rw = dw * (0.3 + rng() * 0.3);
          const rh = dh * (0.25 + rng() * 0.3);
          ctx.fillStyle = shadeColor(color, ((rng() - 0.5) * 30) | 0);
          ctx.beginPath();
          ctx.ellipse(rx, ry, rw / 2, rh / 2, 0, Math.PI, 0);
          ctx.fill();
          ctx.fillStyle = shadeColor(color, 25);
          ctx.globalAlpha = 0.3;
          ctx.beginPath();
          ctx.ellipse(rx - rw * 0.1, ry - rh * 0.15, rw * 0.25, rh * 0.15, 0, Math.PI, 0);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      } else if (d.decorId.includes('coral') || d.decorId === 'anemone' || d.decorId === 'sea_fan') {
        // Coral/anemone style: branching shapes
        const rng = seededRng(Math.round(d.x * 10000) + 77);
        const branches = 3 + Math.floor(rng() * 3);
        for (let b = 0; b < branches; b++) {
          const bx = x + (rng() - 0.5) * dw * 0.4;
          const by1 = subY;
          const by2 = subY - dh * (0.5 + rng() * 0.5);
          ctx.strokeStyle = shadeColor(color, ((rng() - 0.5) * 30) | 0);
          ctx.lineWidth = 2 + rng() * 2;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(bx, by1);
          ctx.quadraticCurveTo(bx + (rng() - 0.5) * dw * 0.3, (by1 + by2) / 2, bx + (rng() - 0.5) * dw * 0.2, by2);
          ctx.stroke();
          // Branch tip
          ctx.fillStyle = shadeColor(color, 20);
          ctx.beginPath();
          ctx.arc(bx + (rng() - 0.5) * 4, by2, 2 + rng() * 2, 0, Math.PI * 2);
          ctx.fill();
        }
      } else {
        // Generic rounded shape (driftwood, chest, log, stump, cave, moss_ball)
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x - dw / 2, subY);
        ctx.quadraticCurveTo(x - dw / 2, dy, x - dw * 0.1, dy - 3);
        ctx.quadraticCurveTo(x + dw * 0.1, dy - 5, x + dw / 2, dy);
        ctx.quadraticCurveTo(x + dw / 2, subY - 2, x + dw / 2, subY);
        ctx.closePath();
        ctx.fill();
        // Shading highlight
        ctx.fillStyle = shadeColor(color, 15);
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.ellipse(x, dy + dh * 0.2, dw * 0.3, dh * 0.15, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
  }
}

// ═══════ RENDERING — EQUIPMENT ═══════

function renderEquipment(toolsOwned) {
  if (!toolsOwned || !tankCat) return;
  let eqX = W - 10;
  const iconKeys = { heater:'heater', filter_tropical:'filter', filter_salt:'filter', skimmer:'skimmer', uv_sterilizer:'uv' };

  for (const [toolId, level] of Object.entries(toolsOwned)) {
    if (level <= 0) continue;
    const iKey = iconKeys[toolId] || 'filter';
    const ic = ICON_DATA[iKey];
    if (!ic) continue;

    const eqScale = Math.max(2, PX_SCALE - 1);
    const eqW = ic.w * eqScale;
    const eqH = ic.h * eqScale;
    const eqY = 15;

    // Draw equipment pixel art on right wall
    for (let y = 0; y < ic.h; y++) {
      for (let x = 0; x < ic.w; x++) {
        const ch = ic.d[y][x];
        if (ch === '0') continue;
        ctx.fillStyle = ic.pal[ch] || '#888';
        ctx.globalAlpha = 0.85;
        ctx.fillRect(eqX - eqW + x * eqScale, eqY + y * eqScale, eqScale, eqScale);
      }
    }
    ctx.globalAlpha = 1;

    // Level indicator dots
    if (level > 1) {
      for (let i = 0; i < Math.min(level, 5); i++) {
        ctx.fillStyle = '#ffd866';
        ctx.fillRect(eqX - eqW / 2 - (level * 2) + i * 4, eqY + eqH + 3, 2, 2);
      }
    }

    eqX -= eqW + 6;
  }
}

// ═══════ RENDERING — FISH ═══════

function updateFishAnim(fish, dt) {
  // ── Schooling: pick a leader per species, others follow it ──
  const schoolingSpecies = new Map(); // speciesId → [fish instances]
  for (const f of fish) {
    const sp = tankCat?.content?.fish?.[f.speciesId];
    if (sp?.preferences?.schooling) {
      if (!schoolingSpecies.has(f.speciesId)) schoolingSpecies.set(f.speciesId, []);
      schoolingSpecies.get(f.speciesId).push(f);
    }
  }
  // Assign leader (first fish, or keep current leader if alive)
  for (const [sid, members] of schoolingSpecies) {
    if (!schoolAnchors[sid]) {
      const sp = tankCat?.content?.fish?.[sid];
      const zone = ZONE_RANGES[sp?.preferences?.zonePreference || 'middle'] || ZONE_RANGES.middle;
      schoolAnchors[sid] = { leaderId: members[0].id, zone, timer: 0 };
    }
    const anchor = schoolAnchors[sid];
    // Validate leader
    if (!members.find(m => m.id === anchor.leaderId)) {
      anchor.leaderId = members[0].id;
    }
  }
  // Prune stale anchors
  for (const sid of Object.keys(schoolAnchors)) {
    if (!schoolingSpecies.has(sid)) delete schoolAnchors[sid];
  }

  for (const f of fish) {
    let anim = fishAnims[f.id];
    if (!anim) {
      const sp = tankCat?.content?.fish?.[f.speciesId];
      const zone = sp?.preferences?.zonePreference || 'middle';
      const range = ZONE_RANGES[zone] || ZONE_RANGES.middle;
      const movType = sp?.preferences?.movementType || 'default';
      anim = {
        x: 0.1 + Math.random() * 0.8,
        y: range[0] + Math.random() * (range[1] - range[0]),
        tx: 0.2 + Math.random() * 0.6,
        ty: range[0] + Math.random() * (range[1] - range[0]),
        facing: Math.random() > 0.5 ? 1 : -1,
        phase: Math.random() * Math.PI * 2,
        speed: 0.3 + Math.random() * 0.3,
        sizeVar: 0.9 + Math.random() * 0.2,
        zone: range,
        movementType: movType,
        wiggle: false,
        wiggleTimer: 0,
      };
      // Crawl types start on bottom
      if (movType === 'crawl') {
        anim.y = range[1] || 0.82;
        anim.ty = anim.y;
      }
      fishAnims[f.id] = anim;
    }

    // Handle wiggle state (fish is being held/tapped)
    if (anim.wiggle) {
      anim.wiggleTimer -= dt;
      anim.phase += dt * 18; // fast wiggle
      if (anim.wiggleTimer <= 0) anim.wiggle = false;
      continue; // Don't move while wiggling
    }

    const sp = tankCat?.content?.fish?.[f.speciesId];
    const movType = anim.movementType || 'default';

    // Move toward target
    const dx = anim.tx - anim.x;
    const dy = anim.ty - anim.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    // Feed mode: swim toward nearest accepted food
    let chaseTarget = null;
    if (activeMode === 'feed' && foodParticles.length > 0 && f.hunger < 70) {
      const accepts = sp?.diet?.accepts || [];
      let nearest = null, nearDist = Infinity;
      for (const fp of foodParticles) {
        if (!accepts.includes(fp.foodId)) continue;
        const fdx = fp.x / W - anim.x;
        const fdy = fp.y / H - anim.y;
        const fd = Math.sqrt(fdx*fdx + fdy*fdy);
        if (fd < nearDist) { nearDist = fd; nearest = fp; }
      }
      if (nearest && nearDist < 0.4) chaseTarget = { x: nearest.x / W, y: nearest.y / H };
    }
    // Laser mode: chase laser
    if (activeMode === 'laser' && laserPos) {
      if (movType !== 'snake' && movType !== 'crawl') {
        chaseTarget = { x: laserPos.x / W, y: laserPos.y / H };
      }
    }

    if (chaseTarget) {
      anim.tx = chaseTarget.x;
      anim.ty = chaseTarget.y;
    } else if (dist < 0.03) {
      // ── Movement type: CRAWL (snails, shrimp) ──
      if (movType === 'crawl') {
        // Stay on substrate bottom, move very slowly left/right
        anim.tx = 0.06 + Math.random() * 0.88;
        anim.ty = anim.zone[1] || 0.82; // stay at bottom of zone
      }
      // ── Movement type: GLASS (pleco) ──
      else if (movType === 'glass') {
        if (!anim._wallSide) anim._wallSide = Math.random() > 0.5 ? 'left' : 'right';
        if (Math.random() < 0.12) anim._wallSide = anim._wallSide === 'left' ? 'right' : 'left';
        anim.tx = anim._wallSide === 'left' ? 0.04 : 0.96;
        anim.ty = 0.15 + Math.random() * 0.65;
      }
      // ── Movement type: SNAKE (moray eel) ──
      else if (movType === 'snake') {
        // Slow undulating movement near bottom/cave
        anim.tx = 0.1 + Math.random() * 0.8;
        anim.ty = Math.max(anim.zone[0], 0.5 + Math.random() * 0.32);
      }
      // ── Schooling fish: follow leader ──
      else if (sp?.preferences?.schooling && schoolAnchors[f.speciesId]) {
        const anchor = schoolAnchors[f.speciesId];
        const leaderAnim = fishAnims[anchor.leaderId];
        if (leaderAnim && f.id !== anchor.leaderId) {
          // Follow leader with offset
          const idx = (schoolingSpecies.get(f.speciesId) || []).indexOf(f);
          const angle = (idx * 1.2) + anim.phase * 0.05;
          const followDist = 0.06 + (idx % 3) * 0.03;
          anim.tx = leaderAnim.x - leaderAnim.facing * followDist + Math.sin(angle) * 0.04;
          anim.ty = leaderAnim.y + Math.cos(angle) * 0.03;
        } else {
          // Leader: normal swimming
          anim.tx = 0.1 + Math.random() * 0.8;
          anim.ty = anim.zone[0] + Math.random() * (anim.zone[1] - anim.zone[0]);
        }
      }
      // ── Default movement ──
      else {
        anim.tx = 0.08 + Math.random() * 0.84;
        anim.ty = anim.zone[0] + Math.random() * (anim.zone[1] - anim.zone[0]);
      }
    }

    // Speed varies by movement type
    let baseSpd = (chaseTarget ? 1.5 : 0.6) * anim.speed;
    if (movType === 'crawl') baseSpd *= 0.25; // snails are very slow
    if (movType === 'snake') baseSpd *= 0.5; // eels are moderate
    if (movType === 'glass') baseSpd *= 0.4; // plecos are slow
    const spd = baseSpd * dt;

    anim.x += dx * spd * 2;
    // Snake movement: add sinusoidal vertical oscillation
    const yOsc = movType === 'snake'
      ? Math.sin(anim.phase * 1.5) * 0.001
      : Math.sin(anim.phase) * 0.0003;
    anim.y += dy * spd * 2 + yOsc;
    anim.phase += dt * (movType === 'snake' ? 5 : 3);
    if (Math.abs(dx) > 0.005) anim.facing = dx > 0 ? 1 : -1;

    // Clamp — crawl types hug the bottom
    anim.x = Math.max(0.04, Math.min(0.96, anim.x));
    if (movType === 'crawl') {
      anim.y = Math.max(anim.zone[1] - 0.03, Math.min(anim.zone[1] + 0.02, anim.y));
    } else {
      anim.y = Math.max(0.05, Math.min(0.88, anim.y));
    }
  }
}

function renderFish(fish) {
  // Sort by Y for depth ordering
  const sorted = [...fish].sort((a, b) => {
    const ay = fishAnims[a.id]?.y || 0;
    const by = fishAnims[b.id]?.y || 0;
    return ay - by;
  });

  const biome = BIOMES[activeTankId] || BIOMES.fresh;
  const subY = H * (1 - biome.subH);

  for (const f of sorted) {
    const anim = fishAnims[f.id];
    if (!anim) continue;
    const cached = spriteCache[f.speciesId];
    if (!cached) continue;

    const img = anim.facing > 0 ? cached.right : cached.left;
    const baseScale = FISH_BASE_SCALES[f.speciesId] || 1.0;
    const scale = anim.sizeVar * baseScale;
    const drawW = img.width * scale;
    const drawH = img.height * scale;
    const px = anim.x * W - drawW / 2;
    const py = anim.y * H - drawH / 2;
    const movType = anim.movementType || 'default';

    // Weak state: make grey/transparent
    if (f.weak) {
      ctx.globalAlpha = 0.45;
      ctx.filter = 'grayscale(0.8)';
    }

    // Wiggle animation
    if (anim.wiggle) {
      ctx.save();
      const wigAmt = Math.sin(anim.phase) * 3;
      ctx.translate(anim.x * W, anim.y * H);
      ctx.rotate(wigAmt * Math.PI / 180 * 4);
      ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
      ctx.restore();
    }
    // Glass movement (pleco): draw attached to glass wall, oriented vertically
    else if (movType === 'glass' && anim._wallSide) {
      ctx.save();
      const wallX = anim._wallSide === 'left' ? 4 + drawW * 0.3 : W - 4 - drawW * 0.3;
      ctx.translate(wallX, anim.y * H);
      // Head up, body along glass
      const rot = anim._wallSide === 'left' ? -Math.PI / 2 : Math.PI / 2;
      ctx.rotate(rot);
      ctx.scale(anim.facing > 0 ? 1 : -1, 1); // flip for facing
      ctx.drawImage(cached.right, -drawW / 2, -drawH / 2, drawW, drawH);
      ctx.restore();
    }
    // Snake movement: sinusoidal body undulation
    else if (movType === 'snake') {
      ctx.save();
      ctx.translate(anim.x * W, anim.y * H);
      const undulate = Math.sin(anim.phase * 1.5) * 2;
      ctx.rotate(undulate * Math.PI / 180);
      ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
      ctx.restore();
    }
    // Crawl movement (snails, shrimp): on substrate
    else if (movType === 'crawl') {
      // Draw on top of substrate
      const crawlY = subY - drawH * 0.6;
      ctx.drawImage(img, anim.x * W - drawW / 2, crawlY, drawW, drawH);
    }
    // Default swim
    else {
      ctx.drawImage(img, px, py, drawW, drawH);
    }

    if (f.weak) {
      ctx.globalAlpha = 1;
      ctx.filter = 'none';
    }

    // Level badge — only show for selected (tapped) fish
    if (f.level > 1 && f.id === selectedFishId) {
      const badgeX = (movType === 'crawl') ? anim.x * W + drawW / 2 - 12 : px + drawW - 12;
      const badgeY = (movType === 'crawl') ? subY - drawH * 0.6 - 2 : py - 2;
      ctx.fillStyle = 'rgba(0,0,0,.6)';
      ctx.fillRect(badgeX, badgeY, 16, 11);
      ctx.fillStyle = '#ffd866';
      ctx.font = 'bold 9px sans-serif';
      ctx.fillText('L' + f.level, badgeX + 1, badgeY + 8);
    }
  }
}

// ═══════ FOOD PARTICLES ═══════

function updateFoodParticles(dt) {
  const fish = gameState?.tanks?.[activeTankId]?.fish || [];
  for (let i = foodParticles.length - 1; i >= 0; i--) {
    const fp = foodParticles[i];
    const sinkSpeed = fp.sink === 'slowSink' ? 25 : fp.sink === 'sink' ? 60 : 5;
    fp.y += sinkSpeed * dt;
    fp.x += Math.sin(fp.phase) * 8 * dt;
    fp.phase += dt * 2;
    fp.life -= dt;

    // Check fish contact
    let eaten = false;
    for (const f of fish) {
      const anim = fishAnims[f.id];
      if (!anim) continue;
      const sp = tankCat?.content?.fish?.[f.speciesId];
      if (!sp || !sp.diet.accepts.includes(fp.foodId)) continue;
      const fdx = fp.x - anim.x * W;
      const fdy = fp.y - anim.y * H;
      if (Math.sqrt(fdx*fdx + fdy*fdy) < 18) {
        // Keep fish at current position so it doesn't snap back
        anim.tx = anim.x;
        anim.ty = anim.y;
        API.doAction('fish_consume', { fishId: f.id, foodId: fp.foodId }).then(refreshState);
        showFloatText(fp.x, fp.y, '+fed');
        eaten = true;
        break;
      }
    }

    if (eaten || fp.life <= 0 || fp.y > H) {
      foodParticles.splice(i, 1);
    }
  }
}

function renderFoodParticles() {
  for (const fp of foodParticles) {
    ctx.fillStyle = '#e8c870';
    ctx.beginPath();
    ctx.arc(fp.x, fp.y, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffd866';
    ctx.beginPath();
    ctx.arc(fp.x, fp.y, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ═══════ BUBBLES ═══════

function updateBubbles(dt, biomeKey) {
  const b = BIOMES[biomeKey] || BIOMES.fresh;
  // Spawn
  if (Math.random() < b.bubbleRate * dt * 10) {
    bubbles.push({
      x: 10 + Math.random() * (W - 20),
      y: H * 0.85 + Math.random() * H * 0.1,
      r: 1 + Math.random() * 2.5,
      speed: 15 + Math.random() * 25,
      phase: Math.random() * Math.PI * 2,
    });
  }
  for (let i = bubbles.length - 1; i >= 0; i--) {
    const b = bubbles[i];
    b.y -= b.speed * dt;
    b.x += Math.sin(b.phase + b.y * 0.05) * 0.3;
    if (b.y < -5) bubbles.splice(i, 1);
  }
}

function renderBubbles() {
  ctx.fillStyle = 'rgba(200,230,255,.2)';
  ctx.strokeStyle = 'rgba(200,230,255,.15)';
  ctx.lineWidth = 0.5;
  for (const b of bubbles) {
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  }
}

// ═══════ DIRT & CLEANING ═══════

function initCleanMask(seed, gridW, gridH, dirtPercent) {
  cleanSeed = seed;
  cleanGridW = gridW; cleanGridH = gridH;
  cleanDirtyStart = dirtPercent;
  // Use same seed that produces the normal dirt overlay pattern so the
  // clean-mode mask looks identical to the dirt that was already visible.
  const rng = seededRng(activeTankId.length * 1000 + 7);
  cleanMask = [];
  // Pre-sample the same RNG sequence used by the normal overlay (12×10 grid)
  // to compute which coarse cells had dirt, then map to the finer clean grid.
  const coarseCols = 12, coarseRows = 10;
  const coarseDirty = [];
  for (let cy = 0; cy < coarseRows; cy++) {
    for (let cx = 0; cx < coarseCols; cx++) {
      const show = rng() <= dirtPercent * 1.5;
      // consume rest of rng calls that renderDirtOverlay does
      rng(); rng(); rng(); rng(); rng();
      coarseDirty.push(show);
    }
  }
  // Build fine grid from coarse dirt map
  const fineRng = seededRng(seed);
  for (let cy = 0; cy < gridH; cy++) {
    for (let cx = 0; cx < gridW; cx++) {
      // Map fine cell to coarse cell
      const ccx = Math.floor(cx / gridW * coarseCols);
      const ccy = Math.floor(cy / gridH * coarseRows);
      const coarseIdx = ccy * coarseCols + ccx;
      const inCoarseDirt = coarseDirty[coarseIdx] || false;

      const isEdge = cx === 0 || cy === 0 || cx === gridW - 1 || cy === gridH - 1;
      const isCorner = (cx <= 1 || cx >= gridW - 2) && (cy <= 1 || cy >= gridH - 2);
      let threshold = isCorner ? 0.25 : isEdge ? 0.40 : 0.55;
      // Cells in coarse-dirty areas are more likely to be dirty
      if (inCoarseDirt) threshold *= 0.5;
      else threshold *= (1 + dirtPercent * 0.5);
      threshold *= (1 - dirtPercent * 0.4);
      const dirty = fineRng() >= threshold;
      const opacity = (0.08 + fineRng() * 0.12) * (1 + dirtPercent * 0.5);
      cleanMask.push({ dirty, opacity, cleaned: false });
    }
  }
}

function wipeCells(canvasX, canvasY, radius) {
  if (!cleanMask) return;
  const biome = BIOMES[activeTankId] || BIOMES.fresh;
  const subY = H * (1 - biome.subH);
  if (canvasY > subY) return; // wiping below substrate does nothing
  const cellW = W / cleanGridW;
  const cellH = subY / cleanGridH; // grid maps to above-substrate area
  const cx = Math.floor(canvasX / cellW);
  const cy = Math.floor(canvasY / cellH);
  const r = Math.ceil(radius);
  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      if (dx*dx + dy*dy > r*r) continue;
      const tx = cx + dx, ty = cy + dy;
      if (tx < 0 || tx >= cleanGridW || ty < 0 || ty >= cleanGridH) continue;
      const idx = ty * cleanGridW + tx;
      if (cleanMask[idx].dirty && !cleanMask[idx].cleaned) {
        cleanMask[idx].cleaned = true;
      }
    }
  }
  updateCleanDockLabel();
}

function getCleanProgress() {
  if (!cleanMask) return 0;
  let totalDirty = 0, cleaned = 0;
  for (const c of cleanMask) {
    if (c.dirty) { totalDirty++; if (c.cleaned) cleaned++; }
  }
  return totalDirty === 0 ? 1 : cleaned / totalDirty;
}

function renderDirtOverlay() {
  dirtCtx.clearRect(0, 0, W, H);
  const tank = gameState?.tanks?.[activeTankId];
  const dirt = tank ? 1 - tank.cleanliness / 100 : 0;
  const biome = BIOMES[activeTankId] || BIOMES.fresh;
  const subY = H * (1 - biome.subH); // dirt only above substrate

  if (activeMode !== 'clean' || !cleanMask) {
    // Always show dirt texture when tank is dirty (not just clean mode)
    if (tank && tank.cleanliness < 95) {
      const rng = seededRng(activeTankId.length * 1000 + 7);
      const cellW = W / 12;
      const cellH = subY / 10; // only above ground
      for (let cy = 0; cy < 10; cy++) {
        for (let cx = 0; cx < 12; cx++) {
          if (rng() > dirt * 1.5) continue;
          const ox = cx * cellW + rng() * cellW * 0.5;
          const oy = cy * cellH + rng() * cellH * 0.5;
          if (oy > subY - 4) continue; // skip substrate area
          const w = cellW * (0.4 + rng() * 0.6);
          const h = cellH * (0.3 + rng() * 0.5);
          dirtCtx.fillStyle = `rgba(70,55,25,${dirt * 0.25 * (0.3 + rng() * 0.7)})`;
          dirtCtx.fillRect(ox, oy, w, h);
        }
      }
      // Edge film on glass (above substrate only)
      dirtCtx.fillStyle = `rgba(60,45,20,${dirt * 0.15})`;
      dirtCtx.fillRect(0, 0, W, 4);
      dirtCtx.fillRect(0, 0, 3, subY);
      dirtCtx.fillRect(W - 3, 0, 3, subY);
    }
    return;
  }
  // Clean mode: render wipe mask (above substrate only)
  const cellW = W / cleanGridW;
  const cellH = subY / cleanGridH; // map grid to above-substrate area
  for (let cy = 0; cy < cleanGridH; cy++) {
    for (let cx = 0; cx < cleanGridW; cx++) {
      const cell = cleanMask[cy * cleanGridW + cx];
      if (!cell.dirty || cell.cleaned) continue;
      const cellY = cy * cellH;
      if (cellY + cellH > subY) continue; // don't draw on substrate
      dirtCtx.fillStyle = `rgba(80, 60, 30, ${cell.opacity})`;
      dirtCtx.fillRect(cx * cellW, cellY, cellW + 0.5, cellH + 0.5);
    }
  }
}

// ═══════ LASER ═══════

function renderLaser() {
  if (activeMode !== 'laser' || !laserPos) return;
  const t = Date.now() / 200;
  const pulse = 4 + Math.sin(t) * 1.5;
  ctx.fillStyle = 'rgba(255,50,50,.7)';
  ctx.beginPath();
  ctx.arc(laserPos.x, laserPos.y, pulse, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = 'rgba(255,150,150,.4)';
  ctx.beginPath();
  ctx.arc(laserPos.x, laserPos.y, pulse + 3, 0, Math.PI * 2);
  ctx.fill();
}

// ═══════ FLOAT TEXT ═══════

function showFloatText(x, y, text, color) {
  const el = document.createElement('div');
  el.className = 'float-text';
  el.textContent = text;
  if (color) el.style.color = color;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  $('tankWrap').appendChild(el);
  setTimeout(() => el.remove(), 1600);
}

// ═══════ HUD ═══════

function updateHUD() {
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank) return;

  $('coinCount').textContent = Math.floor(tank.coins);

  const clean = Math.round(tank.cleanliness);
  $('cleanFill').style.width = clean + '%';
  $('cleanFill').style.background = clean > 60 ? '#4caf88' : clean > 30 ? '#e8a040' : '#e05050';
  $('cleanVal').textContent = clean + '%';

  // Average hunger of all fish
  const fish = tank.fish || [];
  const avgHunger = fish.length > 0
    ? Math.round(fish.reduce((s, f) => s + f.hunger, 0) / fish.length)
    : 100;
  $('hungerFill').style.width = avgHunger + '%';
  $('hungerFill').style.background = avgHunger > 60 ? '#e8a040' : avgHunger > 30 ? '#e07838' : '#e05050';
  $('hungerVal').textContent = avgHunger + '%';

  // Tank nav
  const unlocked = tanksList ? tanksList.filter(t => t.unlocked) : [];
  const navEl = $('tankNav');
  if (unlocked.length > 1) {
    navEl.classList.remove('hidden');
    $('tnLabel').textContent = (BIOMES[activeTankId] || BIOMES.fresh).label;
  } else {
    navEl.classList.add('hidden');
  }

  // Container attrs
  const wc = $('widgetContainer');
  wc.dataset.tank = activeTankId;
  wc.dataset.tier = TANK_TIER_MAP[activeTankId] || '1';
}

// ═══════ TOAST ═══════

let toastTimer = null;
function showToast(msg, duration) {
  const t = $('toast');
  t.textContent = msg;
  t.classList.add('visible');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => t.classList.remove('visible'), duration || 3000);
}

// ═══════ HUD TOOLTIP ═══════

function showHudTooltip(title, body) {
  $('hudTooltipTitle').textContent = title;
  $('hudTooltipBody').textContent = body;
  $('hudTooltip').classList.add('visible');
  clearTimeout(tooltipTimer);
  tooltipTimer = setTimeout(() => $('hudTooltip').classList.remove('visible'), 4000);
}

// ═══════ FISH BUBBLE ═══════

function showFishBubble(f, px, py) {
  $('decorCard').classList.remove('visible'); // dismiss decor card
  // Track selected fish for level badge display
  selectedFishId = f.id;
  clearTimeout(selectedFishTimer);
  selectedFishTimer = setTimeout(() => { selectedFishId = null; }, 8000);

  const fb = $('fishBubble');
  const c = f._computed || {};
  const sp = tankCat?.content?.fish?.[f.speciesId];
  $('fbName').textContent = c.speciesName || f.speciesId;
  $('fbSpecies').textContent = `Lv.${f.level} ${c.lifeStage || ''}`;

  // Build detailed info
  let detailHtml = '';
  detailHtml += `<div class="fb-stats">`;
  detailHtml += `<span class="fb-stat">${iconImg('food', 10)} ${Math.round(f.hunger)}%</span>`;
  detailHtml += `<span class="fb-stat">HP ${Math.round(f.health)}</span>`;
  detailHtml += `<span class="fb-stat">Happy ${c.happiness ?? '?'}</span>`;
  detailHtml += `</div>`;
  detailHtml += `<div class="fb-earn">${iconImg('coin', 10)} ${c.coinRate ?? 0}/hr · XP ${f.xp}/${c.xpToNext || '?'}</div>`;
  if (f.weak) detailHtml += `<div class="fb-warn">Weak — Feed & clean to recover!</div>`;
  if (sp?.preferences?.schooling) detailHtml += `<div class="fb-trait">Schooling fish (0.5 space)</div>`;
  if (sp?.preferences?.movementType === 'crawl') detailHtml += `<div class="fb-trait">Bottom crawler</div>`;
  if (sp?.preferences?.movementType === 'glass') detailHtml += `<div class="fb-trait">Glass cleaner</div>`;
  if (sp?.utility?.dirtReduction) detailHtml += `<div class="fb-trait">Reduces dirt by ${Math.round(sp.utility.dirtReduction * 100)}%</div>`;

  // Action buttons
  detailHtml += `<div class="fb-actions">`;
  detailHtml += `<button class="fb-btn fb-sell" data-fb-sell="${f.id}">Sell</button>`;
  detailHtml += `</div>`;

  $('fbDetail').innerHTML = detailHtml;
  $('fbStage').textContent = '';
  fb.style.left = Math.min(px, W - 170) + 'px';
  fb.style.top = Math.max(py - 90, 4) + 'px';
  fb.classList.add('visible');
  clearTimeout(fb._timer);
  fb._timer = setTimeout(() => fb.classList.remove('visible'), 8000);

  // Bind sell action
  const sellBtn = fb.querySelector('[data-fb-sell]');
  if (sellBtn) {
    sellBtn.onclick = async (e) => {
      e.stopPropagation();
      const res = await API.doAction('sell_fish', { fishId: f.id });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.sold) { showToast(`Sold for ${res.result.value} coins`); }
      fb.classList.remove('visible');
      selectedFishId = null;
      await refreshState();
    };
  }
}

// ═══════ DECOR CARD ═══════

function showDecorCard(d, px, py) {
  $('fishBubble').classList.remove('visible'); // dismiss fish bubble
  const dc = $('decorCard');
  const dd = tankCat?.content?.decor?.[d.decorId];
  if (!dd) return;

  $('dcName').textContent = dd.name || d.decorId;
  const growInfo = dd.growth ? `Size: ${d.size.toFixed(1)} / ${dd.growth.maxSize}` : 'Static';
  $('dcInfo').textContent = `${dd.placement} · ${growInfo}`;

  let actionsHtml = '';
  if (dd.growth) {
    const atMin = d.size <= (dd.growth.minSize + 0.01);
    actionsHtml += `<button class="dc-trim" ${atMin ? 'disabled' : ''} data-trim-decor="${d.id}">✂️ Trim</button>`;
  }
  actionsHtml += `<button class="dc-sell" data-sell-decor-card="${d.id}">Sell</button>`;
  $('dcActions').innerHTML = actionsHtml;

  // Bind trim handler
  const trimBtn = $('dcActions').querySelector('[data-trim-decor]');
  if (trimBtn) {
    trimBtn.onclick = async () => {
      const res = await API.doAction('trim_plant', { decorInstanceId: d.id });
      if (res?.result?.trimmed) {
        showToast(`Trimmed! Size: ${res.result.newSize.toFixed(1)}`);
        await refreshState();
        dc.classList.remove('visible');
      } else if (res?.result?.error) {
        showToast(res.result.error);
      }
    };
  }

  // Bind sell handler
  const sellBtn = $('dcActions').querySelector('[data-sell-decor-card]');
  if (sellBtn) {
    sellBtn.onclick = async () => {
      const res = await API.doAction('sell_decor', { decorInstanceId: d.id });
      if (res?.result?.sold) {
        showToast(`Sold for ${res.result.value} coins`);
        await refreshState();
        dc.classList.remove('visible');
      } else if (res?.result?.error) {
        showToast(res.result.error);
      }
    };
  }

  dc.style.left = Math.min(px, W - 160) + 'px';
  dc.style.top = Math.max(py - 50, 4) + 'px';
  dc.classList.add('visible');
  clearTimeout(dc._timer);
  dc._timer = setTimeout(() => dc.classList.remove('visible'), 8000);
}

// ═══════ FAB & MENU ═══════

function toggleMenu() {
  menuOpen = !menuOpen;
  $('menuOverlay').classList.toggle('visible', menuOpen);
  $('fab').classList.toggle('active', menuOpen);
  // Close any active panel when menu toggles
}

function closeMenu() {
  menuOpen = false;
  $('menuOverlay').classList.remove('visible');
  $('fab').classList.remove('active');
}

function handleMenuAction(action) {
  closeMenu();
  switch (action) {
    case 'feed': enterFeedMode(); break;
    case 'clean': enterCleanMode(); break;
    case 'laser': enterLaserMode(); break;
    case 'store': openPanel('storePanel'); break;
    case 'upgrades': openPanel('upgradesPanel'); break;
    case 'inventory': openPanel('inventoryPanel'); break;
    case 'tanks': openPanel('tanksPanel'); break;
    case 'help': openPanel('helpPanel'); break;
  }
}

// ═══════ TOOL MODES ═══════

function exitToolMode() {
  activeMode = null;
  $('toolDock').classList.remove('visible');
  $('fab').style.display = '';
  laserPos = null;
  cleanMask = null;
  selectedFoodId = null;
  renderDirtOverlay();
}

function enterFeedMode() {
  exitToolMode();
  activeMode = 'feed';
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank || !tankCat) return;

  const foods = Object.entries(tank.foodStock || {}).filter(([, qty]) => qty > 0);
  const allFoods = Object.entries(tankCat.content?.food || {});
  const dock = $('toolDockContent');
  dock.innerHTML = '';

  for (const [fid, fdef] of allFoods) {
    const qty = tank.foodStock?.[fid] || 0;
    const el = document.createElement('div');
    el.className = 'dock-item' + (selectedFoodId === fid ? ' active' : '');
    el.innerHTML = `<span>${fdef.name}</span><span class="dock-qty">×${qty}</span>`;
    el.onclick = () => {
      selectedFoodId = fid;
      dock.querySelectorAll('.dock-item').forEach(d => d.classList.remove('active'));
      el.classList.add('active');
    };
    dock.appendChild(el);
  }
  // Auto-select first available food
  if (!selectedFoodId || !(tank.foodStock?.[selectedFoodId] > 0)) {
    const first = allFoods.find(([fid]) => (tank.foodStock?.[fid] || 0) > 0);
    if (first) {
      selectedFoodId = first[0];
      dock.querySelector('.dock-item')?.classList.add('active');
    }
  }

  $('toolDock').classList.add('visible');
  $('fab').style.display = 'none';
}

async function enterCleanMode() {
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank) return;
  if (tank.cleanliness >= 98) {
    showToast('Your tank is sparkling clean! ✨');
    return;
  }
  exitToolMode();
  activeMode = 'clean';

  const res = await API.doAction('start_clean');
  const r = res?.result;
  if (r && r.started) {
    initCleanMask(r.seed, r.gridW || 64, r.gridH || 48, r.dirtPercent);
    renderDirtOverlay();
  }

  const dock = $('toolDockContent');
  dock.innerHTML = '<span id="cleanDockLabel">Wipe to clean!</span>';
  $('toolDock').classList.add('visible');
  $('fab').style.display = 'none';
}

function updateCleanDockLabel() {
  const lbl = $('cleanDockLabel');
  if (!lbl) return;
  const prog = getCleanProgress();
  if (prog >= 0.99) {
    lbl.textContent = 'Tank cleaned! ✨';
  } else if (prog > 0) {
    lbl.textContent = `${Math.round(prog * 100)}% cleaned`;
  } else {
    lbl.textContent = 'Wipe to clean!';
  }
}

async function finishClean() {
  const progress = getCleanProgress();
  const res = await API.doAction('finish_clean', { improvementPercent: Math.round(progress * 100) });
  const r = res?.result;
  cleanMask = null;
  renderDirtOverlay();

  if (r && r.coinsEarned > 0) {
    if (progress >= 0.95) {
      showToast(`Tank cleaned! +${r.coinsEarned} coins`);
    } else {
      showToast(`Partially cleaned! +${r.coinsEarned} coins`);
    }
  } else if (progress < 0.05) {
    showToast('Barely cleaned...');
  } else {
    showToast('Partially cleaned!');
  }
  await refreshState();
}

function enterLaserMode() {
  exitToolMode();
  activeMode = 'laser';
  laserActive = true;
  laserStartTime = Date.now();

  const dock = $('toolDockContent');
  dock.innerHTML = '<span>Move your finger to play! Fish love to chase the dot.</span>';
  $('toolDock').classList.add('visible');
  $('fab').style.display = 'none';
}

async function triggerLaserReward() {
  const elapsed = Date.now() - laserStartTime;
  if (elapsed < 5000) return; // Need 5 seconds of play
  const res = await API.doAction('laser_pointer');
  const r = res?.result;
  if (r?.reward) {
    showToast(`+${r.reward.coins} coins! Fish had fun!`);
    showFloatText(W / 2, H / 2, `+${r.reward.coins}`, '#ffd866');
    await refreshState();
  } else if (r?.cooldownRemaining) {
    const mins = Math.ceil(r.cooldownRemaining / 60000);
    showToast(`Play cooldown: ${mins > 60 ? Math.floor(mins/60)+'h '+mins%60+'m' : mins+'m'}`);
  }
}

// ═══════ PANELS ═══════

function openPanel(panelId) {
  closeAllPanels();
  const el = $(panelId);
  if (!el) return;
  activePanel = panelId;
  el.classList.add('visible');
  populatePanel(panelId);
}

function closeAllPanels() {
  document.querySelectorAll('.panel').forEach(p => p.classList.remove('visible'));
  activePanel = null;
}

function populatePanel(panelId) {
  switch (panelId) {
    case 'storePanel': populateStore(); break;
    case 'upgradesPanel': populateUpgrades(); break;
    case 'inventoryPanel': populateInventory(); break;
    case 'tanksPanel': populateTanks(); break;
    case 'helpPanel': populateHelp(); break;
  }
}

function populateStore() {
  if (!storeData || !tankCat) return;
  const list = $('storeList');
  const tank = gameState?.tanks?.[activeTankId];
  const cap = tankCat.capacity?.spaceCapacity || 8;
  const used = tankCat._computed?.usedSpace || 0;
  $('storeCap').textContent = `${used}/${cap}`;

  // Tabs
  const sections = Object.keys(storeData);
  let html = '<div class="store-tabs">';
  for (const sec of ['fish','food','decor','tools']) {
    if (!storeData[sec]) continue;
    const label = sec === 'fish' ? 'Fish' : sec === 'food' ? 'Food' : sec === 'decor' ? 'Decorations' : 'Tools';
    html += `<button class="store-tab ${storeTab === sec ? 'active' : ''}" data-tab="${sec}">${label}</button>`;
  }
  html += '</div>';

  // Items for active tab
  const items = storeData[storeTab] || [];
  if (items.length === 0) {
    html += '<div style="opacity:.5;text-align:center;padding:20px">Nothing available</div>';
  }

  if (storeTab === 'fish') {
    html += `<div class="panel-section-title">Fish — Space: ${used}/${cap}</div>`;
    for (const item of items) {
      const locked = !item.canBuy;
      const reqText = item.reqInfo?.length ? `<div class="s-desc" style="color:#e8a040;opacity:.8">⚠️ ${item.reqInfo.join(', ')}</div>` : '';
      html += `<div class="s-item ${locked && item.blockReason !== 'Not enough coins' ? 'locked' : ''}">
        <div class="s-icon">${iconImg('fish', 20)}</div>
        <div class="s-info">
          <div class="s-name">${item.name}</div>
          <div class="s-desc">◆${item.spaceCost} space · ${item.baseCoinPerHour}/hr${item.ownedCount > 0 ? ' · ×' + item.ownedCount + ' owned' : ''}</div>
          ${reqText}
        </div>
        <button class="buy-btn primary" ${!item.canBuy ? 'disabled' : ''} data-buy-fish="${item.id}">
          ${item.blockReason?.includes('full') || item.blockReason?.includes('Max') ? 'Full' : item.price + ' ' + iconImg('coin', 12)}
        </button>
      </div>`;
    }
  } else if (storeTab === 'food') {
    html += '<div class="panel-section-title">Food</div>';
    for (const item of items) {
      html += `<div class="s-item">
        <div class="s-icon">${iconImg('food', 20)}</div>
        <div class="s-info">
          <div class="s-name">${item.name}</div>
          <div class="s-desc">+${item.hungerRestore} hunger · Stock: ×${item.currentStock}</div>
        </div>
        <button class="buy-btn primary" ${!item.canBuy ? 'disabled' : ''} data-buy-food="${item.id}">
          ${item.price * 5} ${iconImg('coin', 12)} ×5
        </button>
      </div>`;
    }
  } else if (storeTab === 'decor') {
    html += '<div class="panel-section-title">Decorations</div>';
    for (const item of items) {
      html += `<div class="s-item ${!item.canBuy ? 'locked' : ''}">
        <div class="s-icon" style="color:${DECOR_COLORS[item.id] || '#888'}">●</div>
        <div class="s-info">
          <div class="s-name">${item.name}</div>
          <div class="s-desc">${item.placement} · ${item.growth ? 'grows' : 'static'}${item.blockReason ? ' · ' + item.blockReason : ''}</div>
        </div>
        <button class="buy-btn primary" ${!item.canBuy ? 'disabled' : ''} data-buy-decor="${item.id}">
          ${item.price} ${iconImg('coin', 12)}
        </button>
      </div>`;
    }
  } else if (storeTab === 'tools') {
    html += '<div class="panel-section-title">Equipment</div>';
    for (const item of items) {
      html += `<div class="s-item">
        <div class="s-icon">${iconImg('wrench', 20)}</div>
        <div class="s-info">
          <div class="s-name">${item.name}</div>
          <div class="s-desc">Level ${item.currentLevel}/${item.maxLevel}${item.maxed ? ' (Max)' : ''}</div>
        </div>
        <button class="buy-btn primary" ${!item.canBuy ? 'disabled' : ''} data-buy-tool="${item.id}">
          ${item.maxed ? 'Max' : item.nextPrice + ' ' + iconImg('coin', 12)}
        </button>
      </div>`;
    }
  }

  list.innerHTML = html;

  // Tab click handlers
  list.querySelectorAll('.store-tab').forEach(tab => {
    tab.onclick = () => { storeTab = tab.dataset.tab; populateStore(); };
  });

  // Buy handlers
  list.querySelectorAll('[data-buy-fish]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('buy_fish', { speciesId: btn.dataset.buyFish });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.bought) showToast(`Bought ${btn.dataset.buyFish}!`);
      await refreshState();
      populateStore();
    };
  });
  list.querySelectorAll('[data-buy-food]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('buy_food', { foodId: btn.dataset.buyFood, quantity: 5 });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.bought) showToast(`Bought ${res.result.quantity}× food`);
      await refreshState();
      populateStore();
    };
  });
  list.querySelectorAll('[data-buy-decor]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('buy_decor', { decorId: btn.dataset.buyDecor });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.bought) showToast('Decoration placed!');
      await refreshState();
      populateStore();
    };
  });
  list.querySelectorAll('[data-buy-tool]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('buy_tool', { toolId: btn.dataset.buyTool });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.bought) showToast(`Upgraded ${btn.dataset.buyTool}!`);
      await refreshState();
      populateStore();
    };
  });
}

function populateUpgrades() {
  const list = $('upgradesList');
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank || !tankCat) { list.innerHTML = '<div style="opacity:.5">No tools available for this tank.</div>'; return; }

  let html = '<div class="panel-section-title">Equipment</div>';
  const tools = tankCat.content?.tools || {};
  const toolEntries = Object.entries(tools);

  if (toolEntries.length === 0) {
    html += '<div style="opacity:.5;padding:10px">No equipment available for this tank.</div>';
  }

  for (const [toolId, toolDef] of toolEntries) {
    const level = tank.toolsOwned?.[toolId] || 0;
    const maxed = level >= toolDef.maxLevel;
    const nextPrice = maxed ? null : toolDef.prices[level];
    const canBuy = !maxed && tank.coins >= (nextPrice || Infinity);

    html += `<div class="s-item">
      <div class="s-icon">${iconImg('wrench', 20)}</div>
      <div class="s-info">
        <div class="s-name">${toolDef.name}</div>
        <div class="s-desc">Level ${level}/${toolDef.maxLevel}${maxed ? ' — Fully upgraded' : ''}</div>
      </div>
      <button class="buy-btn primary" ${!canBuy ? 'disabled' : ''} data-upgrade-tool="${toolId}">
        ${maxed ? 'Max' : nextPrice + ' ' + iconImg('coin', 12)}
      </button>
    </div>`;
  }

  // Show utility fish
  const utilFish = (tank.fish || []).filter(f => {
    const sp = tankCat.content?.fish?.[f.speciesId];
    return sp?.utility;
  });
  if (utilFish.length > 0) {
    html += '<div class="panel-section-title">Utility Creatures</div>';
    for (const f of utilFish) {
      const sp = tankCat.content?.fish?.[f.speciesId];
      html += `<div class="s-item">
        <div class="s-icon">${iconImg('wrench', 18)}</div>
        <div class="s-info">
          <div class="s-name">${sp.name}</div>
          <div class="s-desc">Reduces dirt by ${Math.round((sp.utility.dirtReduction||0)*100)}%</div>
        </div>
      </div>`;
    }
  }

  list.innerHTML = html;

  list.querySelectorAll('[data-upgrade-tool]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('buy_tool', { toolId: btn.dataset.upgradeTool });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.bought) showToast('Tool upgraded!');
      await refreshState();
      populateUpgrades();
    };
  });
}

function populateInventory() {
  const list = $('inventoryList');
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank || !tankCat) { list.innerHTML = ''; return; }

  let html = '';

  // Food stock
  const foods = Object.entries(tank.foodStock || {}).filter(([, q]) => q > 0);
  if (foods.length > 0 || Object.keys(tankCat.content?.food || {}).length > 0) {
    html += '<div class="panel-section-title">Food Stock</div>';
    for (const [fid, fdef] of Object.entries(tankCat.content?.food || {})) {
      const qty = tank.foodStock?.[fid] || 0;
      html += `<div class="s-item">
        <div class="s-icon">${iconImg('food', 18)}</div>
        <div class="s-info">
          <div class="s-name">${fdef.name}</div>
          <div class="s-desc">Stock: ×${qty}</div>
        </div>
      </div>`;
    }
  }

  // Fish
  const fish = tank.fish || [];
  if (fish.length > 0) {
    html += '<div class="panel-section-title">Fish</div>';
    for (const f of fish) {
      const c = f._computed || {};
      const sp = tankCat.content?.fish?.[f.speciesId];
      html += `<div class="s-item">
        <div class="s-icon">${iconImg('fish', 18)}</div>
        <div class="s-info">
          <div class="s-name">${c.speciesName || f.speciesId} ${f.weak ? '⚠️' : ''}</div>
          <div class="s-desc">Lv.${f.level} ${c.lifeStage||''} · H:${c.happiness??'?'} · F:${Math.round(f.hunger)} · ${c.coinRate||0}/hr</div>
        </div>
        <button class="sell-btn" data-sell-fish="${f.id}">Sell</button>
      </div>`;
    }
  }

  // Decorations
  const decors = tank.decor || [];
  if (decors.length > 0) {
    html += '<div class="panel-section-title">Decorations</div>';
    for (const d of decors) {
      const dd = tankCat.content?.decor?.[d.decorId];
      html += `<div class="s-item">
        <div class="s-icon" style="color:${DECOR_COLORS[d.decorId]||'#888'}">●</div>
        <div class="s-info">
          <div class="s-name">${dd?.name || d.decorId}</div>
          <div class="s-desc">${dd?.growth ? 'Size: ' + d.size.toFixed(1) : 'Static'}</div>
        </div>
        <button class="sell-btn" data-sell-decor="${d.id}">Sell</button>
      </div>`;
    }
  }

  list.innerHTML = html;

  list.querySelectorAll('[data-sell-fish]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('sell_fish', { fishId: btn.dataset.sellFish });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.sold) showToast(`Sold for ${res.result.value} coins`);
      await refreshState();
      populateInventory();
    };
  });
  list.querySelectorAll('[data-sell-decor]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('sell_decor', { decorInstanceId: btn.dataset.sellDecor });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.sold) showToast(`Sold for ${res.result.value} coins`);
      await refreshState();
      populateInventory();
    };
  });
}

function populateTanks() {
  const list = $('tanksList');
  if (!tanksList) { list.innerHTML = ''; return; }

  let html = '';
  for (const t of tanksList) {
    const isCurrent = t.tankId === activeTankId;
    const b = BIOMES[t.tankId] || {};
    html += `<div class="s-item ${isCurrent ? 'active-tank' : ''}">
      <div class="s-icon">${t.unlocked ? iconImg('fish', 18) : iconImg('lock', 18)}</div>
      <div class="s-info">
        <div class="s-name">${t.name}${isCurrent ? ' — Current' : ''}</div>
        <div class="s-desc">${t.unlocked ? `${t.fishCount} fish · ${t.usedSpace}/${t.spaceCapacity} space · ${t.coins} coins` : t.unlockLabel}</div>
      </div>
      ${!isCurrent && t.unlocked ?
        `<button class="buy-btn primary" data-switch-tank="${t.tankId}">Switch</button>` :
        (!t.unlocked ?
          `<button class="buy-btn primary" ${!t.meetsRequirements ? 'disabled' : ''} data-unlock-tank="${t.tankId}">${t.meetsRequirements ? 'Unlock' : 'Locked'}</button>` :
          '')}
    </div>`;
  }

  list.innerHTML = html;

  list.querySelectorAll('[data-switch-tank]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('switch_tank', { tankId: btn.dataset.switchTank });
      if (res?.result?.switched) {
        await refreshState();
        closeAllPanels();
      }
    };
  });
  list.querySelectorAll('[data-unlock-tank]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('unlock_tank', { tankId: btn.dataset.unlockTank });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.unlocked) {
        showToast(`Unlocked ${res.result.tankName}!`);
        await refreshState();
        populateTanks();
      }
    };
  });
}

function populateHelp() {
  $('helpBody').innerHTML = `
    <div class="panel-section-title">Getting Started</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      You start with a Fresh tank and one guppy. Feed your fish, keep the tank clean, and earn coins.
      Buy more fish and supplies from the Store!
    </p>
    <div class="panel-section-title">Tanks &amp; Switching</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Multiple tank biomes are available, each with unique fish, coins, food, and decor.
      Unlock new tanks by earning lifetime coins. Fresh → Tropical → Saltwater.
    </p>
    <div class="panel-section-title">Feeding</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Open Feed mode from the menu. Tap on the tank to drop food. Switch food types in the dock.
      Different fish eat different foods — check what your fish accepts!
    </p>
    <div class="panel-section-title">Cleaning</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Dirt builds up over time. Open Clean mode and swipe to wipe away grime.
      Earn coins proportional to dirt removed! Filters and snails slow dirt accumulation.
    </p>
    <div class="panel-section-title">Play</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Open Play mode for a laser pointer. Fish will chase the dot!
      Earn coins and XP every 6 hours of cooldown.
    </p>
    <div class="panel-section-title">Decor &amp; Plants</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Buy decor from the Store. Plants grow over time — trim overgrown plants by tapping them.
      Floating plants can multiply into new clusters. Some fish require specific decor to be happy.
    </p>
    <div class="panel-section-title">Happiness &amp; Requirements</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Each fish has a happiness score (0–100). Hunger, cleanliness, tools, and decor affect happiness.
      Missing required decor or tools causes large penalties. Happy fish generate more coins!
      Tap a fish to see its happiness breakdown.
    </p>
    <div class="panel-section-title">Weak State &amp; Recovery</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Fish never die permanently. Neglected fish become Weak — they stop generating coins and appear grey.
      To recover: feed them and clean the tank. Health regenerates over time once conditions improve.
    </p>
    <div class="panel-section-title">Store Rules</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Some items require tools or lifetime coins to unlock. Tank space limits how many fish you can have.
      Fish prices increase for each one you already own. Selling returns a fraction of the purchase price.
      Tools can't be sold — they're permanent upgrades.
    </p>
    <button class="reset-btn" id="resetBtn">Reset Aquarium</button>
  `;

  $('resetBtn').onclick = async () => {
    if (confirm('Are you sure you want to reset your aquarium? All progress will be lost!')) {
      await API.doAction('reset_state');
      await refreshState();
      closeAllPanels();
      showToast('Aquarium reset!');
    }
  };
}

// ═══════ INPUT HANDLING ═══════

function setupInput() {
  // FAB
  $('fab').onclick = toggleMenu;

  // Menu buttons
  document.querySelectorAll('.menu-btn').forEach(btn => {
    btn.onclick = () => handleMenuAction(btn.dataset.action);
  });

  // Panel close buttons
  document.querySelectorAll('[data-close]').forEach(btn => {
    btn.onclick = () => {
      const panelId = btn.dataset.close;
      $(panelId)?.classList.remove('visible');
      if (activePanel === panelId) activePanel = null;
    };
  });

  // Dock close
  document.querySelector('.dock-close').onclick = async () => {
    if (activeMode === 'clean' && cleanMask) {
      await finishClean();
    }
    if (activeMode === 'laser') {
      await triggerLaserReward();
    }
    exitToolMode();
  };

  // HUD tooltips
  $('coinDisplay').onclick = () => {
    const tank = gameState?.tanks?.[activeTankId];
    const lifetime = gameState?.lifetime?.coinsEarned || 0;
    showHudTooltip('Coins', `Current: ${Math.floor(tank?.coins||0)}\nLifetime: ${Math.floor(lifetime)}`);
  };
  $('cleanBar').onclick = () => {
    const tank = gameState?.tanks?.[activeTankId];
    showHudTooltip('Cleanliness', `${Math.round(tank?.cleanliness||0)}%\nKeep above 60% for happy fish!`);
  };
  $('hungerBar').onclick = () => {
    const fish = gameState?.tanks?.[activeTankId]?.fish || [];
    const avg = fish.length > 0 ? Math.round(fish.reduce((s,f) => s + f.hunger, 0)/fish.length) : 100;
    showHudTooltip('Hunger', `Average: ${avg}%\nFeed fish when below 70%!`);
  };

  // Tank nav
  $('tnPrev').onclick = () => switchTankNav(-1);
  $('tnNext').onclick = () => switchTankNav(1);

  // Canvas interactions
  const canvasEl = canvas;
  let isDragging = false;
  let lastDragPos = null;

  function getCanvasPos(e) {
    const rect = canvasEl.getBoundingClientRect();
    const touch = e.touches ? e.touches[0] : e;
    return {
      x: (touch.clientX - rect.left) * (W / rect.width),
      y: (touch.clientY - rect.top) * (H / rect.height),
    };
  }

  canvasEl.addEventListener('mousedown', onPointerDown);
  canvasEl.addEventListener('touchstart', onPointerDown, { passive: false });
  canvasEl.addEventListener('mousemove', onPointerMove);
  canvasEl.addEventListener('touchmove', onPointerMove, { passive: false });
  canvasEl.addEventListener('mouseup', onPointerUp);
  canvasEl.addEventListener('touchend', onPointerUp);

  function onPointerDown(e) {
    if (e.touches) e.preventDefault();
    const pos = getCanvasPos(e);
    isDragging = true;
    lastDragPos = pos;

    if (activeMode === 'clean') {
      wipeCells(pos.x, pos.y, 3);
      renderDirtOverlay();
    } else if (activeMode === 'laser') {
      laserPos = pos;
    } else if (activeMode === 'feed') {
      dropFood(pos.x, pos.y);
    } else {
      // Normal mode: check decor drag first, then fish tap
      const hitDecor = hitTestDecor(pos.x, pos.y);
      if (hitDecor && !hitDecor._isFloating) {
        draggingDecor = { id: hitDecor.id, decorId: hitDecor.decorId, offsetX: 0, offsetY: 0 };
      } else {
        draggingDecor = null;
        checkFishTap(pos.x, pos.y);
      }
    }
  }

  function onPointerMove(e) {
    if (!isDragging) return;
    if (e.touches) e.preventDefault();
    const pos = getCanvasPos(e);

    if (activeMode === 'clean') {
      wipeCells(pos.x, pos.y, 3);
      renderDirtOverlay();
    } else if (activeMode === 'laser') {
      laserPos = pos;
    } else if (draggingDecor) {
      // Move decor visually during drag
      const tank = gameState?.tanks?.[activeTankId];
      if (tank) {
        const d = tank.decor.find(d => d.id === draggingDecor.id);
        if (d) {
          d.x = Math.max(0.05, Math.min(0.95, pos.x / W));
          d.y = Math.max(0.05, Math.min(0.95, pos.y / H));
        }
      }
    }
    lastDragPos = pos;
  }

  function onPointerUp(e) {
    if (draggingDecor) {
      // Commit decor position to server
      const tank = gameState?.tanks?.[activeTankId];
      const d = tank?.decor?.find(d => d.id === draggingDecor.id);
      if (d) {
        API.doAction('move_decor', { decorInstanceId: d.id, x: d.x, y: d.y });
      }
      draggingDecor = null;
    }
    isDragging = false;
    if (activeMode === 'clean') {
      // Auto-complete check
      const prog = getCleanProgress();
      if (prog >= 0.99) {
        finishClean();
        exitToolMode();
      }
    }
  }
}

async function dropFood(x, y) {
  if (!selectedFoodId) { showToast('Select a food first!'); return; }
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank || (tank.foodStock?.[selectedFoodId] || 0) <= 0) {
    showToast('Out of food! Buy more from the Store.');
    return;
  }

  const res = await API.doAction('feed', { foodId: selectedFoodId });
  if (res?.result?.error) { showToast(res.result.error); return; }
  if (res?.result?.fed) {
    const fdef = tankCat?.content?.food?.[selectedFoodId];
    foodParticles.push({
      x, y, foodId: selectedFoodId,
      sink: fdef?.sinkBehavior || 'slowSink',
      phase: Math.random() * Math.PI * 2,
      life: 12,
    });
    // Update local stock
    if (tank.foodStock[selectedFoodId]) tank.foodStock[selectedFoodId]--;
    // Refresh dock display
    enterFeedMode();
  }
}

function checkFishTap(px, py) {
  const tank = gameState?.tanks?.[activeTankId];
  const fish = tank?.fish || [];
  // Check fish first
  for (const f of fish) {
    const anim = fishAnims[f.id];
    if (!anim) continue;
    const fx = anim.x * W, fy = anim.y * H;
    // For crawl types, adjust hit position to substrate
    const biome = BIOMES[activeTankId] || BIOMES.fresh;
    const subYp = H * (1 - biome.subH);
    const effectiveY = (anim.movementType === 'crawl') ? subYp - 5 : fy;
    if (Math.abs(px - fx) < 20 && Math.abs(py - effectiveY) < 15) {
      // Trigger wiggle animation
      if (anim) {
        anim.wiggle = true;
        anim.wiggleTimer = 2.0; // wiggle for 2 seconds
      }
      showFishBubble(f, fx, effectiveY);
      return;
    }
  }
  // Check decor
  const decors = tank?.decor || [];
  const biome = BIOMES[activeTankId] || BIOMES.fresh;
  const subY = H * (1 - biome.subH);
  for (const d of decors) {
    const dd = tankCat?.content?.decor?.[d.decorId];
    if (!dd) continue;
    const dx = d.x * W;
    const baseSize = Math.max(12, (d.size || 1) * PX_SCALE * 8);
    let hitW, hitH, hitX, hitY;
    if (dd.placement === 'top') {
      hitW = baseSize * 2; hitH = 16; hitX = dx; hitY = 6;
    } else if (dd.growth) {
      hitW = baseSize * 1.5; hitH = baseSize * 4; hitX = dx; hitY = subY - hitH;
    } else {
      hitW = baseSize * 2.8; hitH = baseSize * 1.8; hitX = dx; hitY = subY - baseSize * 0.9;
    }
    if (Math.abs(px - hitX) < hitW / 2 && py > hitY - 4 && py < hitY + hitH + 4) {
      showDecorCard(d, px, py);
      return;
    }
  }
  // No fish/decor tapped — dismiss popups
  $('fishBubble').classList.remove('visible');
  $('decorCard').classList.remove('visible');
}

function hitTestDecor(px, py) {
  const tank = gameState?.tanks?.[activeTankId];
  const decors = tank?.decor || [];
  const biome = BIOMES[activeTankId] || BIOMES.fresh;
  const subY = H * (1 - biome.subH);
  for (const d of decors) {
    const dd = tankCat?.content?.decor?.[d.decorId];
    if (!dd) continue;
    const dx = d.x * W;
    const baseSize = Math.max(12, (d.size || 1) * PX_SCALE * 8);
    let hitW, hitH, hitX, hitY;
    if (dd.placement === 'top') {
      hitW = baseSize * 2; hitH = 16; hitX = dx; hitY = 6;
      // Mark floating plants
      d._isFloating = true;
    } else if (dd.growth) {
      hitW = baseSize * 1.5; hitH = baseSize * 4; hitX = dx; hitY = subY - hitH;
      d._isFloating = false;
    } else {
      hitW = baseSize * 2.8; hitH = baseSize * 1.8; hitX = dx; hitY = subY - baseSize * 0.9;
      d._isFloating = false;
    }
    if (Math.abs(px - hitX) < hitW / 2 && py > hitY - 4 && py < hitY + hitH + 4) {
      return d;
    }
  }
  return null;
}

async function switchTankNav(dir) {
  if (!tanksList) return;
  const unlocked = tanksList.filter(t => t.unlocked);
  const currentIdx = unlocked.findIndex(t => t.tankId === activeTankId);
  const nextIdx = (currentIdx + dir + unlocked.length) % unlocked.length;
  const nextTank = unlocked[nextIdx];
  if (nextTank && nextTank.tankId !== activeTankId) {
    exitToolMode();
    const res = await API.doAction('switch_tank', { tankId: nextTank.tankId });
    if (res?.result?.switched) await refreshState();
  }
}

// ═══════ STATE SYNC ═══════

async function refreshState() {
  try {
    const res = await API.getState();
    if (!res) return;
    applyState(res);
  } catch (err) {
    console.error('Failed to refresh state:', err);
  }
}

function applyState(res) {
  gameState = res.save;
  activeTankId = res.activeTankId || gameState?.activeTankId || 'fresh';
  tankCat = res.tankCatalog;
  storeData = res.store;
  tanksList = res.tanksList;
  globalCat = res.global;

  // Prune anims for fish no longer present
  const fishIds = new Set((gameState?.tanks?.[activeTankId]?.fish || []).map(f => f.id));
  for (const id of Object.keys(fishAnims)) {
    if (!fishIds.has(id)) delete fishAnims[id];
  }

  updateHUD();

  // Refresh active panel if open
  if (activePanel) populatePanel(activePanel);
}

// ═══════ GAME LOOP ═══════

function gameLoop(timestamp) {
  const dt = Math.min((timestamp - lastFrameTime) / 1000, 0.1) || 0.016;
  lastFrameTime = timestamp;

  resizeCanvas();

  const tank = gameState?.tanks?.[activeTankId];
  const fish = tank?.fish || [];

  // Update
  updateFishAnim(fish, dt);
  updateFoodParticles(dt);
  updateBubbles(dt, activeTankId);

  // Render
  ctx.clearRect(0, 0, W, H);
  renderEnvironment(activeTankId);
  renderDecor(tank?.decor, activeTankId);
  renderEquipment(tank?.toolsOwned);
  renderFish(fish);
  renderFoodParticles();
  renderBubbles();
  renderLaser();
  renderDirtOverlay();

  requestAnimationFrame(gameLoop);
}

// ═══════ RESIZE ═══════

function resizeCanvas() {
  const rect = canvas.parentElement.getBoundingClientRect();
  const newW = Math.round(rect.width);
  const newH = Math.round(rect.height);
  if (newW === W && newH === H) return;

  DPR = window.devicePixelRatio || 1;
  W = newW;
  H = newH;
  canvas.width = W * DPR;
  canvas.height = H * DPR;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  ctx.imageSmoothingEnabled = false;

  dirtCanvas.width = W * DPR;
  dirtCanvas.height = H * DPR;
  dirtCanvas.style.width = W + 'px';
  dirtCanvas.style.height = H + 'px';
  dirtCtx.setTransform(DPR, 0, 0, DPR, 0, 0);

  PX_SCALE = Math.max(2, Math.floor(Math.min(W, H) / 100));
  buildSpriteCache();
}

// ═══════ HELPERS ═══════

function seededRng(seed) {
  let s = seed | 0;
  return function() { s = (s * 1664525 + 1013904223) | 0; return (s >>> 0) / 4294967296; };
}

function shadeColor(hex, amt) {
  let r = parseInt(hex.slice(1,3),16) + amt;
  let g = parseInt(hex.slice(3,5),16) + amt;
  let b = parseInt(hex.slice(5,7),16) + amt;
  r = Math.max(0,Math.min(255,r));
  g = Math.max(0,Math.min(255,g));
  b = Math.max(0,Math.min(255,b));
  return `rgb(${r},${g},${b})`;
}

// ═══════ PIXEL ICON INIT ═══════

function initPixelIcons() {
  document.querySelectorAll('[data-icon]').forEach(el => {
    const key = el.dataset.icon;
    if (!ICON_DATA[key]) return;
    let size = 14;
    if (el.classList.contains('menu-icon')) size = 24;
    else if (el.id === 'fab') size = 20;
    else if (el.classList.contains('tn-btn')) size = 12;
    el.innerHTML = iconImg(key, size);
  });
}

// ═══════ INIT ═══════

async function init(homey) {
  if (homey) window.Homey = homey;
  try {
    await Homey.ready();
  } catch (e) {
    // Standalone / sandbox mode
  }

  await API.init();
  setupInput();
  initPixelIcons();
  resizeCanvas();

  // Check reset setting
  try {
    const settings = await Homey.getSettings();
    if (settings?.reset_state) {
      await API.doAction('reset_state');
      try { await Homey.set('reset_state', false); } catch(e) {}
    }
  } catch (e) { /* ignore in sandbox */ }

  // Initial state load
  const res = await API.getState();
  if (res) {
    applyState(res);

    // Show "while you were away" if significant idle earnings
    if (res.simResult?.coinsEarned > 5) {
      showToast(`While away: +${res.simResult.coinsEarned} coins earned!`, 4000);
    }
  }

  // Hide loading
  $('loading').classList.add('hidden');

  // Start game loop
  lastFrameTime = performance.now();
  requestAnimationFrame(gameLoop);

  // Periodic refresh every 5 minutes
  refreshTimer = setInterval(refreshState, 5 * 60 * 1000);
}

window.onHomeyReady = init;
</script>
</body>
</html>
