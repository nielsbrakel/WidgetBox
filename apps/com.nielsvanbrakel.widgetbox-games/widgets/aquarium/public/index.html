<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<style>
/* â•â•â•â•â•â•â• BASE â•â•â•â•â•â•â• */
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a1628;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;color:#e0e8f0;-webkit-tap-highlight-color:transparent;user-select:none}
#widgetContainer{position:relative;width:100%;height:100%;overflow:hidden}
#loading{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:#0a1628;z-index:100;font-size:14px;color:#6090c0;transition:opacity .3s}
#loading.hidden{opacity:0;pointer-events:none}

/* â•â•â•â•â•â•â• TANK â•â•â•â•â•â•â• */
#tankWrap{position:absolute;inset:0;overflow:hidden}
#tank{display:block;width:100%;height:100%}
#dirtCanvas{position:absolute;inset:0;width:100%;height:100%;pointer-events:none;z-index:12}

/* â•â•â•â•â•â•â• HUD â•â•â•â•â•â•â• */
.coin-display{position:absolute;top:8px;left:10px;display:flex;align-items:center;gap:4px;background:rgba(0,0,0,.45);border-radius:12px;padding:3px 10px 3px 6px;font-size:13px;font-weight:600;z-index:30;cursor:pointer}
#coinIcon{font-size:14px}
#coinCount{color:#ffd866}
#hudRight{position:absolute;top:8px;right:10px;display:flex;flex-direction:column;gap:4px;z-index:30}
.hud-bar{display:flex;align-items:center;gap:4px;background:rgba(0,0,0,.45);border-radius:8px;padding:3px 8px;font-size:10px;cursor:pointer;min-width:80px}
.hud-bar-label{width:10px;text-align:center}
.hud-bar-track{flex:1;height:5px;background:rgba(255,255,255,.12);border-radius:3px;overflow:hidden}
.hud-bar-fill{height:100%;border-radius:3px;transition:width .5s}
.hud-bar-val{font-size:9px;opacity:.7;min-width:22px;text-align:right}

/* â•â•â•â•â•â•â• HUD TOOLTIP â•â•â•â•â•â•â• */
#hudTooltip{position:absolute;top:38px;right:10px;background:rgba(10,22,40,.92);border:1px solid rgba(100,160,220,.3);border-radius:10px;padding:8px 12px;z-index:31;opacity:0;pointer-events:none;transform:translateY(-4px);transition:opacity .2s,transform .2s;max-width:200px;font-size:11px}
#hudTooltip.visible{opacity:1;pointer-events:auto;transform:translateY(0)}
#hudTooltipTitle{font-weight:600;margin-bottom:3px;font-size:12px}
#hudTooltipBody{opacity:.75;line-height:1.4}

/* â•â•â•â•â•â•â• FISH BUBBLE â•â•â•â•â•â•â• */
#fishBubble{position:absolute;background:rgba(10,22,40,.92);border:1px solid rgba(100,160,220,.3);border-radius:10px;padding:8px 12px;z-index:21;opacity:0;pointer-events:none;transition:opacity .2s;font-size:11px;white-space:nowrap}
#fishBubble.visible{opacity:1}
#fbName{font-weight:600;font-size:12px}
#fbSpecies{opacity:.6;font-size:10px}
#fbDetail{margin-top:4px;line-height:1.5}
#fbStage{opacity:.6;font-size:10px}

/* â•â•â•â•â•â•â• DECOR CARD â•â•â•â•â•â•â• */
#decorCard{position:absolute;background:rgba(10,22,40,.94);border:1px solid rgba(100,160,220,.3);border-radius:10px;padding:10px 14px;z-index:22;opacity:0;pointer-events:none;transition:opacity .2s;font-size:11px;min-width:140px}
#decorCard.visible{opacity:1;pointer-events:auto}
#dcName{font-weight:600;font-size:12px;margin-bottom:2px}
#dcInfo{opacity:.6;font-size:10px;margin-bottom:6px;line-height:1.4}
#dcActions{display:flex;gap:6px}
#dcActions button{padding:4px 10px;border-radius:5px;border:none;font-size:10px;font-weight:600;cursor:pointer}
.dc-trim{background:rgba(80,160,80,.5);color:#b0ffb0}
.dc-trim:hover{background:rgba(80,160,80,.7)}
.dc-trim:disabled{opacity:.4;cursor:default}
.dc-sell{background:rgba(180,60,60,.5);color:#ffa0a0}
.dc-sell:hover{background:rgba(200,70,70,.6)}

/* â•â•â•â•â•â•â• TANK NAV â•â•â•â•â•â•â• */
#tankNav{position:absolute;bottom:8px;left:50%;transform:translateX(-50%);display:flex;align-items:center;gap:8px;background:rgba(0,0,0,.5);border-radius:16px;padding:3px 10px;z-index:40;font-size:11px}
#tankNav.hidden{display:none}
#tankNav button{background:none;border:none;color:#e0e8f0;font-size:14px;cursor:pointer;padding:2px 6px;opacity:.7}
#tankNav button:hover{opacity:1}
#tnLabel{font-weight:500;min-width:80px;text-align:center}

/* â•â•â•â•â•â•â• BOTTOM BAR â•â•â•â•â•â•â• */
#bottomBar{position:absolute;bottom:0;left:0;right:0;height:0;z-index:40}

/* â•â•â•â•â•â•â• FAB â•â•â•â•â•â•â• */
#fab{position:absolute;bottom:12px;right:12px;width:44px;height:44px;border-radius:50%;background:rgba(40,80,140,.85);border:2px solid rgba(100,160,220,.5);color:#e0e8f0;font-size:20px;display:flex;align-items:center;justify-content:center;cursor:pointer;z-index:65;transition:transform .2s,background .2s;box-shadow:0 2px 8px rgba(0,0,0,.4)}
#fab:hover{background:rgba(50,100,170,.9);transform:scale(1.05)}
#fab.active{background:rgba(60,120,200,.9);transform:rotate(45deg)}

/* â•â•â•â•â•â•â• MENU OVERLAY â•â•â•â•â•â•â• */
#menuOverlay{position:absolute;inset:0;background:rgba(5,12,25,.82);z-index:60;display:flex;align-items:center;justify-content:center;opacity:0;pointer-events:none;transition:opacity .2s}
#menuOverlay.visible{opacity:1;pointer-events:auto}
#menuGrid{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;max-width:280px}
.menu-btn{display:flex;flex-direction:column;align-items:center;gap:4px;background:rgba(30,60,100,.6);border:1px solid rgba(100,160,220,.25);border-radius:12px;padding:14px 10px;color:#e0e8f0;font-size:11px;font-weight:500;cursor:pointer;transition:background .15s,transform .15s;min-width:75px}
.menu-btn:hover{background:rgba(40,80,140,.7);transform:scale(1.03)}
.menu-btn .menu-icon{font-size:22px}
.menu-btn.locked{opacity:.4;pointer-events:none}

/* â•â•â•â•â•â•â• TOOL DOCK â•â•â•â•â•â•â• */
#toolDock{position:absolute;bottom:0;left:0;right:0;background:rgba(10,22,40,.92);border-top:1px solid rgba(100,160,220,.25);z-index:42;padding:8px 12px;display:flex;align-items:center;gap:8px;transform:translateY(100%);transition:transform .25s;border-radius:12px 12px 0 0}
#toolDock.visible{transform:translateY(0)}
#toolDockContent{flex:1;display:flex;align-items:center;gap:8px;overflow-x:auto}
.dock-item{display:flex;flex-direction:column;align-items:center;gap:2px;padding:6px 10px;background:rgba(40,80,140,.4);border:1px solid rgba(100,160,220,.25);border-radius:8px;font-size:10px;cursor:pointer;min-width:56px;white-space:nowrap;transition:background .15s}
.dock-item:hover,.dock-item.active{background:rgba(60,120,200,.5);border-color:rgba(100,160,220,.5)}
.dock-item .dock-qty{font-size:9px;opacity:.6}
#cleanDockLabel{font-size:12px;font-weight:500;}
.dock-close{background:none;border:none;color:#e0e8f0;font-size:18px;cursor:pointer;padding:4px 8px;opacity:.7}
.dock-close:hover{opacity:1}

/* â•â•â•â•â•â•â• PANELS â•â•â•â•â•â•â• */
.panel{position:absolute;inset:0;background:rgba(8,18,35,.95);z-index:70;display:flex;flex-direction:column;opacity:0;pointer-events:none;transform:translateY(8px);transition:opacity .2s,transform .2s}
.panel.visible{opacity:1;pointer-events:auto;transform:translateY(0)}
.panel-header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(100,160,220,.15);font-weight:600;font-size:14px}
.panel-header button{background:none;border:none;color:#e0e8f0;font-size:18px;cursor:pointer;padding:4px 8px;opacity:.7}
.panel-header button:hover{opacity:1}
.panel-body{flex:1;overflow-y:auto;padding:10px 14px;-webkit-overflow-scrolling:touch}
.panel-section-title{font-size:11px;font-weight:600;text-transform:uppercase;opacity:.5;margin:12px 0 6px;letter-spacing:.5px}
.panel-section-title:first-child{margin-top:0}

/* â•â•â• Store items â•â•â• */
.s-item{display:flex;align-items:center;gap:10px;padding:8px;background:rgba(30,60,100,.25);border:1px solid rgba(100,160,220,.12);border-radius:8px;margin-bottom:6px;transition:opacity .2s}
.s-item.locked{opacity:.4}
.s-item.active-tank{border-color:rgba(100,200,140,.5);background:rgba(30,100,60,.2)}
.s-icon{font-size:20px;width:28px;text-align:center;flex-shrink:0}
.s-info{flex:1;min-width:0}
.s-name{font-size:12px;font-weight:500}
.s-desc{font-size:10px;opacity:.6;margin-top:1px}
.buy-btn{padding:4px 10px;border-radius:6px;border:none;font-size:11px;font-weight:600;cursor:pointer;white-space:nowrap;transition:background .15s}
.buy-btn.primary{background:#3070b0;color:#fff}
.buy-btn.primary:hover{background:#4088cc}
.buy-btn:disabled{background:rgba(60,80,100,.3);color:rgba(200,210,220,.4);cursor:default}
.sell-btn{background:rgba(180,60,60,.5);color:#ffa0a0;padding:3px 8px;border-radius:5px;border:none;font-size:10px;cursor:pointer}
.sell-btn:hover{background:rgba(200,70,70,.6)}

/* â•â•â• Store tabs â•â•â• */
.store-tabs{display:flex;gap:4px;margin-bottom:10px;flex-wrap:wrap}
.store-tab{padding:4px 10px;border-radius:6px;border:1px solid rgba(100,160,220,.2);background:transparent;color:#e0e8f0;font-size:11px;cursor:pointer;opacity:.6;transition:all .15s}
.store-tab.active{opacity:1;background:rgba(40,80,140,.4);border-color:rgba(100,160,220,.4)}

/* â•â•â•â•â•â•â• TOAST â•â•â•â•â•â•â• */
#toast{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%) scale(.9);background:rgba(10,22,40,.92);border:1px solid rgba(100,160,220,.3);border-radius:12px;padding:10px 18px;z-index:50;font-size:13px;font-weight:500;text-align:center;opacity:0;pointer-events:none;transition:opacity .3s,transform .3s;max-width:80%}
#toast.visible{opacity:1;transform:translate(-50%,-50%) scale(1)}

/* â•â•â•â•â•â•â• FLOAT TEXT â•â•â•â•â•â•â• */
.float-text{position:absolute;font-size:12px;font-weight:700;color:#ffd866;text-shadow:0 1px 3px rgba(0,0,0,.6);pointer-events:none;z-index:20;animation:floatUp 1.5s ease-out forwards}
@keyframes floatUp{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-30px)}}

/* â•â•â•â•â•â•â• SCROLLBAR â•â•â•â•â•â•â• */
.panel-body::-webkit-scrollbar{width:4px}
.panel-body::-webkit-scrollbar-track{background:transparent}
.panel-body::-webkit-scrollbar-thumb{background:rgba(100,160,220,.25);border-radius:2px}

/* â•â•â•â•â•â•â• RESET BUTTON â•â•â•â•â•â•â• */
.reset-btn{display:block;margin:16px auto 0;padding:8px 20px;background:rgba(180,50,50,.5);border:1px solid rgba(200,80,80,.4);border-radius:8px;color:#ffa0a0;font-size:12px;cursor:pointer}
.reset-btn:hover{background:rgba(200,60,60,.6)}
</style>
</head>
<body>
<div id="widgetContainer" data-tank="fresh" data-tier="1">
  <div id="loading">Loading aquariumâ€¦</div>
  <div id="tankWrap">
    <canvas id="tank"></canvas>
    <canvas id="dirtCanvas"></canvas>

    <!-- HUD -->
    <div class="coin-display" id="coinDisplay">
      <span id="coinIcon">ğŸª™</span>
      <span id="coinCount">0</span>
    </div>
    <div id="hudRight">
      <div id="cleanBar" class="hud-bar">
        <span class="hud-bar-label">ğŸ§¹</span>
        <div class="hud-bar-track"><div class="hud-bar-fill" id="cleanFill" style="width:100%;background:#4caf88"></div></div>
        <span class="hud-bar-val" id="cleanVal">100%</span>
      </div>
      <div id="hungerBar" class="hud-bar">
        <span class="hud-bar-label">ğŸ½</span>
        <div class="hud-bar-track"><div class="hud-bar-fill" id="hungerFill" style="width:100%;background:#e8a040"></div></div>
        <span class="hud-bar-val" id="hungerVal">100%</span>
      </div>
    </div>

    <!-- HUD Tooltip -->
    <div id="hudTooltip">
      <div id="hudTooltipTitle"></div>
      <div id="hudTooltipBody"></div>
    </div>

    <!-- Fish bubble -->
    <div id="fishBubble">
      <div id="fbName"></div>
      <div id="fbSpecies"></div>
      <div id="fbDetail"></div>
      <div id="fbStage"></div>
    </div>

    <!-- Decor card -->
    <div id="decorCard">
      <div id="dcName"></div>
      <div id="dcInfo"></div>
      <div id="dcActions"></div>
    </div>

    <!-- Tank nav -->
    <div id="tankNav" class="hidden">
      <button id="tnPrev">â—€</button>
      <span id="tnLabel"></span>
      <button id="tnNext">â–¶</button>
    </div>

    <!-- Bottom bar -->
    <div id="bottomBar"></div>
  </div>

  <!-- FAB -->
  <button id="fab">â˜°</button>

  <!-- Menu overlay -->
  <div id="menuOverlay">
    <div id="menuGrid">
      <button class="menu-btn" data-action="feed"><span class="menu-icon">ğŸŸ</span>Feed</button>
      <button class="menu-btn" data-action="clean"><span class="menu-icon">ğŸ§¹</span>Clean</button>
      <button class="menu-btn" data-action="laser"><span class="menu-icon">ğŸ”´</span>Play</button>
      <button class="menu-btn" data-action="store"><span class="menu-icon">ğŸ›’</span>Store</button>
      <button class="menu-btn" data-action="upgrades"><span class="menu-icon">ğŸ”§</span>Tools</button>
      <button class="menu-btn" data-action="inventory"><span class="menu-icon">ğŸ“‹</span>Fish</button>
      <button class="menu-btn" data-action="tanks"><span class="menu-icon">ğŸ </span>Tanks</button>
      <button class="menu-btn" data-action="help"><span class="menu-icon">â“</span>Help</button>
    </div>
  </div>

  <!-- Tool dock -->
  <div id="toolDock">
    <div id="toolDockContent"></div>
    <button class="dock-close">âœ•</button>
  </div>

  <!-- Panels -->
  <div id="storePanel" class="panel">
    <div class="panel-header"><span>Store</span><span id="storeCap"></span><button data-close="storePanel">âœ•</button></div>
    <div id="storeList" class="panel-body"></div>
  </div>
  <div id="upgradesPanel" class="panel">
    <div class="panel-header"><span>Tools &amp; Equipment</span><button data-close="upgradesPanel">âœ•</button></div>
    <div id="upgradesList" class="panel-body"></div>
  </div>
  <div id="inventoryPanel" class="panel">
    <div class="panel-header"><span>Fish &amp; Supplies</span><button data-close="inventoryPanel">âœ•</button></div>
    <div id="inventoryList" class="panel-body"></div>
  </div>
  <div id="tanksPanel" class="panel">
    <div class="panel-header"><span>Tanks</span><button data-close="tanksPanel">âœ•</button></div>
    <div id="tanksList" class="panel-body"></div>
  </div>
  <div id="helpPanel" class="panel">
    <div class="panel-header"><span>Help</span><button data-close="helpPanel">âœ•</button></div>
    <div id="helpBody" class="panel-body"></div>
  </div>

  <!-- Toast -->
  <div id="toast"></div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Aquarium Widget â€” Client Renderer (Homey SDK 3)
//
// Hybrid Canvas + DOM:  Canvas for game world, DOM for HUD/menus/panels.
// All game logic lives server-side. Client is a "dumb renderer".
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â• CONSTANTS â•â•â•â•â•â•â•

const TANK_TIER_MAP = { fresh: '1', tropical: '2', salt: '3' };
const BIOMES = {
  fresh: {
    bg: ['#6ab8a0','#285848'], wall: '#1e4038', substrate: '#a89070',
    subH: 0.16, bubbleRate: 0.08, label: 'Fresh Starter',
  },
  tropical: {
    bg: ['#38b0c8','#186068'], wall: '#104848', substrate: '#b0a080',
    subH: 0.14, bubbleRate: 0.12, label: 'Tropical Planted',
  },
  salt: {
    bg: ['#2060a0','#0a2050'], wall: '#061430', substrate: '#e0d0b0',
    subH: 0.13, bubbleRate: 0.16, label: 'Saltwater Reef',
  },
};

const FISH_SPRITES = {
  guppy:      { w:10, h:6, data:['0022200000','0213310000','2213451000','0213310000','0022100000','0002000000'] },
  goldfish:   { w:12, h:8, data:['000220000000','002133100000','022134510000','221133110000','221133110000','022133100000','002211000000','000220000000'] },
  snail:      { w:8,  h:6, data:['00333000','03333300','03334300','00444000','04110410','00100100'] },
  neon_tetra: { w:10, h:6, data:['0011100000','0166351000','0116551000','0133610000','0011100000','0002000000'] },
  blue_eye:   { w:10, h:6, data:['0011000000','0113510000','0113510000','0111310000','0011100000','0002000000'] },
  moon_fish:  { w:12, h:8, data:['000011000000','001113100000','011133510000','011133110000','011133110000','011133100000','001111000000','000011000000'] },
  discus:     { w:12, h:10, data:['000011000000','000113100000','001133100000','011134510000','011136310000','011136310000','011134510000','001133100000','000113100000','000011000000'] },
  pleco:      { w:14, h:6, data:['00000000000000','00111111110000','01113345111000','01111111111000','00111111110000','00011000110000'] },
  gourami:    { w:12, h:8, data:['000220000000','002113100000','021133510000','221133110000','221133110000','021133100000','002113000000','000220000000'] },
  clownfish:  { w:12, h:8, data:['000220000000','002116100000','021163510000','221163110000','221136110000','021116100000','002116000000','000220000000'] },
  blue_tang:  { w:14, h:10, data:['00000220000000','00002113000000','00021133100000','00211335100000','02211336310000','02211336310000','00211335100000','00021133100000','00002113000000','00000220000000'] },
  green_chromis: { w:10, h:6, data:['0011100000','0113351000','0113150000','0111310000','0011100000','0002000000'] },
  firefish:   { w:12, h:6, data:['000011000000','001113310000','011133510000','011133110000','001113300000','000022000000'] },
  royal_gramma: { w:12, h:8, data:['000220000000','002113100000','021133510000','211133610000','261136110000','026113600000','002613000000','000220000000'] },
  banggai_cardinal: { w:10, h:6, data:['0022000000','0213611000','2216451000','0213611000','0022000000','0002000000'] },
  moray_eel:  { w:18, h:6, data:['000000000000000000','000011111111100000','001113334511110000','001111113111110000','000011111111100000','000000000000000000'] },
  cleaner_shrimp: { w:10, h:6, data:['0000550000','0001133000','0013345100','0011331000','0001130000','0010010100'] },
};

const FISH_PALETTES = {
  guppy:      { 1:'#FF8844', 2:'#FF5522', 3:'#FFCC88', 4:'#AA4400', 5:'#111' },
  goldfish:   { 1:'#FFB833', 2:'#FF9500', 3:'#FFE088', 4:'#CC7700', 5:'#111' },
  snail:      { 1:'#D4B896', 2:'#B89878', 3:'#8B6B4A', 4:'#A08060', 5:'#111' },
  neon_tetra: { 1:'#C0C8D0', 2:'#FF3333', 3:'#FF5050', 4:'#333', 5:'#111', 6:'#3388FF' },
  blue_eye:   { 1:'#88CCEE', 2:'#5599CC', 3:'#AADDFF', 4:'#336688', 5:'#2266FF' },
  moon_fish:  { 1:'#CCE0CC', 2:'#88BB88', 3:'#E8FFE8', 4:'#668866', 5:'#111' },
  discus:     { 1:'#FF6644', 2:'#DD4422', 3:'#FF8866', 4:'#CC3311', 5:'#111', 6:'#FF4422' },
  pleco:      { 1:'#665544', 2:'#554433', 3:'#887766', 4:'#443322', 5:'#111' },
  gourami:    { 1:'#5599CC', 2:'#3377AA', 3:'#88CCEE', 4:'#224466', 5:'#111' },
  clownfish:  { 1:'#FF6600', 2:'#FF4400', 3:'#FF8833', 4:'#CC4400', 5:'#111', 6:'#FFFFFF' },
  blue_tang:  { 1:'#3355BB', 2:'#FFDD33', 3:'#5577DD', 4:'#223399', 5:'#111', 6:'#FFDD33' },
  green_chromis: { 1:'#55BB77', 2:'#339955', 3:'#88EEBB', 4:'#227744', 5:'#111' },
  firefish:   { 1:'#FF4444', 2:'#FFAA33', 3:'#FFCC44', 4:'#CC2222', 5:'#111' },
  royal_gramma: { 1:'#8833CC', 2:'#7722BB', 3:'#AA55EE', 4:'#5511AA', 5:'#111', 6:'#FFDD33' },
  banggai_cardinal: { 1:'#CCCCCC', 2:'#AAAAAA', 3:'#EEEEEE', 4:'#555', 5:'#111', 6:'#222' },
  moray_eel:  { 1:'#667744', 2:'#556633', 3:'#8B9966', 4:'#445522', 5:'#FFDD33' },
  cleaner_shrimp: { 1:'#EE4444', 2:'#CC2222', 3:'#FFFFFF', 4:'#AA0000', 5:'#FFFFFF' },
};

const DECOR_COLORS = {
  hornwort:'#44AA44', moss_ball:'#339933', rock_pile:'#888888', driftwood:'#8B6B4A',
  treasure_chest:'#AA7733', java_fern:'#338833', amazon_sword:'#228822', floating_plants:'#55BB55',
  mossy_log:'#6B4B2A', hollow_stump:'#5A3A1A', anemone:'#FF6688', live_rock:'#999999',
  brain_coral:'#DD8844', staghorn_coral:'#DDAA66', cave:'#444444', sea_fan:'#CC5599',
};

const ZONE_RANGES = { top:[0.08,0.35], middle:[0.25,0.65], bottom:[0.55,0.82], any:[0.15,0.75] };

// â•â•â•â•â•â•â• STATE â•â•â•â•â•â•â•

let W = 400, H = 300, DPR = 1, PX_SCALE = 3;
let gameState = null;
let tankCat = null;
let storeData = null;
let tanksList = null;
let globalCat = null;
let activeTankId = 'fresh';

// Animation state per fish
let fishAnims = {};
// Schooling anchors per species
let schoolAnchors = {};
// Particles
let bubbles = [];
let foodParticles = [];
let floatTexts = [];
// Sprite cache
let spriteCache = {};
// UI state
let activeMode = null; // 'feed' | 'clean' | 'laser' | null
let selectedFoodId = null;
let activePanel = null;
let menuOpen = false;
let storeTab = 'fish';
// Cleaning state
let cleanMask = null;
let cleanSeed = 0;
let cleanGridW = 64, cleanGridH = 48;
let cleanDirtyStart = 0;
// Laser state
let laserPos = null;
let laserActive = false;
let laserStartTime = 0;
// Tooltip
let tooltipTimer = null;
// Game time
let lastFrameTime = 0;
let refreshTimer = null;

// â•â•â•â•â•â•â• DOM REFS â•â•â•â•â•â•â•

const $ = id => document.getElementById(id);
const canvas = $('tank');
const ctx = canvas.getContext('2d');
const dirtCanvas = $('dirtCanvas');
const dirtCtx = dirtCanvas.getContext('2d');

// â•â•â•â•â•â•â• API LAYER â•â•â•â•â•â•â•

const API = {
  widgetId: 'default',
  async init() {
    try { this.widgetId = await Homey.getWidgetInstanceId(); } catch(e) { /* sandbox fallback */ }
  },
  async getState() {
    return Homey.api('GET', `/?widgetId=${encodeURIComponent(this.widgetId)}`);
  },
  async doAction(type, payload) {
    return Homey.api('POST', `/?widgetId=${encodeURIComponent(this.widgetId)}`, { type, payload: payload || {} });
  },
};

// â•â•â•â•â•â•â• SPRITE PRE-RENDERING â•â•â•â•â•â•â•

function buildSpriteCache() {
  spriteCache = {};
  for (const [key, sp] of Object.entries(FISH_SPRITES)) {
    const pal = FISH_PALETTES[key];
    if (!pal) continue;
    spriteCache[key] = {
      right: renderSprite(sp, pal, PX_SCALE, false),
      left: renderSprite(sp, pal, PX_SCALE, true),
    };
  }
}

function renderSprite(sp, palette, scale, flip) {
  const c = document.createElement('canvas');
  c.width = sp.w * scale;
  c.height = sp.h * scale;
  const cx = c.getContext('2d');
  cx.imageSmoothingEnabled = false;
  for (let y = 0; y < sp.h; y++) {
    const row = sp.data[y];
    for (let x = 0; x < sp.w; x++) {
      const ch = row[x];
      if (ch === '0') continue;
      const color = palette[ch];
      if (!color) continue;
      cx.fillStyle = color;
      const dx = flip ? (sp.w - 1 - x) * scale : x * scale;
      cx.fillRect(dx, y * scale, scale, scale);
    }
  }
  return c;
}

// â•â•â•â•â•â•â• RENDERING â€” ENVIRONMENT â•â•â•â•â•â•â•

function renderEnvironment(biomeKey) {
  const b = BIOMES[biomeKey] || BIOMES.fresh;

  // Water gradient
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, b.bg[0]);
  grad.addColorStop(1, b.bg[1]);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Caustic light bands
  const time = Date.now() / 3000;
  ctx.globalAlpha = 0.04;
  ctx.fillStyle = '#ffffff';
  for (let i = 0; i < 5; i++) {
    const x = ((time * 15 + i * 80) % (W + 40)) - 20;
    ctx.fillRect(x, 0, 12, H * 0.6);
  }
  ctx.globalAlpha = 1;

  // Substrate
  const subY = H * (1 - b.subH);
  ctx.fillStyle = b.substrate;
  ctx.fillRect(0, subY, W, H - subY);
  // Substrate texture
  const rng = seededRng(42);
  ctx.fillStyle = shadeColor(b.substrate, -15);
  for (let i = 0; i < 60; i++) {
    const gx = rng() * W;
    const gy = subY + 2 + rng() * (H - subY - 4);
    ctx.fillRect(gx, gy, 2, 1);
  }

  // Water surface shimmer
  ctx.globalAlpha = 0.06;
  ctx.fillStyle = '#ffffff';
  for (let i = 0; i < 8; i++) {
    const sx = Math.sin(time * 0.8 + i * 1.2) * 20 + i * (W / 8);
    ctx.fillRect(sx, 0, 30 + Math.sin(time + i) * 10, 3);
  }
  ctx.globalAlpha = 1;
}

// â•â•â•â•â•â•â• RENDERING â€” DECOR â•â•â•â•â•â•â•

function renderDecor(decors, biomeKey) {
  if (!decors || !tankCat) return;
  const subY = H * (1 - (BIOMES[biomeKey]||BIOMES.fresh).subH);

  for (const d of decors) {
    const def = tankCat.content?.decor?.[d.decorId];
    if (!def) continue;
    const color = DECOR_COLORS[d.decorId] || '#888';
    const x = d.x * W;
    const baseSize = (d.size || 1) * PX_SCALE * 4;

    if (def.placement === 'top') {
      // Floating plants â€” draw at water surface
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.8;
      ctx.beginPath();
      ctx.ellipse(x, 6, baseSize * 1.2, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    } else if (def.growth) {
      // Plant â€” vertical with slight curve
      const ph = baseSize * 2.5;
      const py = subY - ph;
      ctx.fillStyle = color;
      ctx.fillRect(x - 2, py, 4, ph);
      // Leaves
      ctx.beginPath();
      for (let i = 0; i < 4; i++) {
        const ly = py + ph * (0.15 + i * 0.2);
        const dir = i % 2 === 0 ? 1 : -1;
        ctx.moveTo(x, ly);
        ctx.quadraticCurveTo(x + dir * baseSize * 0.6, ly - 4, x + dir * baseSize * 0.3, ly + 4);
      }
      ctx.fillStyle = shadeColor(color, 15);
      ctx.fill();
    } else {
      // Solid decor â€” draw as rounded shape at substrate
      const dw = baseSize * 1.5;
      const dh = baseSize * 0.8;
      const dy = subY - dh;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x - dw/2, subY);
      ctx.quadraticCurveTo(x - dw/2, dy, x, dy - 3);
      ctx.quadraticCurveTo(x + dw/2, dy, x + dw/2, subY);
      ctx.closePath();
      ctx.fill();
    }
  }
}

// â•â•â•â•â•â•â• RENDERING â€” EQUIPMENT â•â•â•â•â•â•â•

function renderEquipment(toolsOwned) {
  if (!toolsOwned || !tankCat) return;
  let eqX = W - 14;
  for (const [toolId, level] of Object.entries(toolsOwned)) {
    if (level <= 0) continue;
    const colors = { heater: '#cc3333', filter_tropical: '#778899', filter_salt: '#778899', skimmer: '#cccccc', uv_sterilizer: '#9966ff' };
    ctx.fillStyle = colors[toolId] || '#888';
    ctx.fillRect(eqX - 4, 20, 8, H * 0.4);
    ctx.fillStyle = 'rgba(255,255,255,.15)';
    ctx.fillRect(eqX - 3, 22, 2, H * 0.38);
    eqX -= 14;
  }
}

// â•â•â•â•â•â•â• RENDERING â€” FISH â•â•â•â•â•â•â•

function updateFishAnim(fish, dt) {
  // Update schooling anchors: a shared slowly-drifting point per schooling species
  const schoolingSpecies = new Set();
  for (const f of fish) {
    const sp = tankCat?.content?.fish?.[f.speciesId];
    if (sp?.preferences?.schooling) schoolingSpecies.add(f.speciesId);
  }
  for (const sid of schoolingSpecies) {
    if (!schoolAnchors[sid]) {
      const sp = tankCat?.content?.fish?.[sid];
      const zone = ZONE_RANGES[sp?.preferences?.zonePreference || 'middle'] || ZONE_RANGES.middle;
      schoolAnchors[sid] = {
        x: 0.3 + Math.random() * 0.4,
        y: zone[0] + Math.random() * (zone[1] - zone[0]),
        tx: 0.3 + Math.random() * 0.4,
        ty: zone[0] + Math.random() * (zone[1] - zone[0]),
        zone,
        timer: 0,
      };
    }
    const anchor = schoolAnchors[sid];
    anchor.timer -= dt;
    if (anchor.timer <= 0) {
      anchor.tx = 0.15 + Math.random() * 0.7;
      anchor.ty = anchor.zone[0] + Math.random() * (anchor.zone[1] - anchor.zone[0]);
      anchor.timer = 4 + Math.random() * 6;
    }
    const adx = anchor.tx - anchor.x;
    const ady = anchor.ty - anchor.y;
    anchor.x += adx * dt * 0.3;
    anchor.y += ady * dt * 0.3;
  }
  // Prune stale anchors
  for (const sid of Object.keys(schoolAnchors)) {
    if (!schoolingSpecies.has(sid)) delete schoolAnchors[sid];
  }

  for (const f of fish) {
    let anim = fishAnims[f.id];
    if (!anim) {
      const sp = tankCat?.content?.fish?.[f.speciesId];
      const zone = sp?.preferences?.zonePreference || 'middle';
      const range = ZONE_RANGES[zone] || ZONE_RANGES.middle;
      anim = {
        x: 0.1 + Math.random() * 0.8,
        y: range[0] + Math.random() * (range[1] - range[0]),
        tx: 0.2 + Math.random() * 0.6,
        ty: range[0] + Math.random() * (range[1] - range[0]),
        facing: Math.random() > 0.5 ? 1 : -1,
        phase: Math.random() * Math.PI * 2,
        speed: 0.3 + Math.random() * 0.3,
        sizeVar: 0.9 + Math.random() * 0.2,
        zone: range,
      };
      fishAnims[f.id] = anim;
    }

    // Move toward target
    const dx = anim.tx - anim.x;
    const dy = anim.ty - anim.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    // Feed mode: swim toward nearest accepted food
    let chaseTarget = null;
    if (activeMode === 'feed' && foodParticles.length > 0 && f.hunger < 70) {
      const sp = tankCat?.content?.fish?.[f.speciesId];
      const accepts = sp?.diet?.accepts || [];
      let nearest = null, nearDist = Infinity;
      for (const fp of foodParticles) {
        if (!accepts.includes(fp.foodId)) continue;
        const fdx = fp.x / W - anim.x;
        const fdy = fp.y / H - anim.y;
        const fd = Math.sqrt(fdx*fdx + fdy*fdy);
        if (fd < nearDist) { nearDist = fd; nearest = fp; }
      }
      if (nearest && nearDist < 0.4) chaseTarget = { x: nearest.x / W, y: nearest.y / H };
    }
    // Laser mode: chase laser
    if (activeMode === 'laser' && laserPos) {
      const sp = tankCat?.content?.fish?.[f.speciesId];
      if (f.speciesId !== 'moray_eel') {
        chaseTarget = { x: laserPos.x / W, y: laserPos.y / H };
      }
    }

    if (chaseTarget) {
      anim.tx = chaseTarget.x;
      anim.ty = chaseTarget.y;
    } else if (dist < 0.03) {
      // Schooling fish orbit the shared anchor
      const sp = tankCat?.content?.fish?.[f.speciesId];
      const anchor = sp?.preferences?.schooling ? schoolAnchors[f.speciesId] : null;
      if (anchor) {
        const offset = 0.08;
        anim.tx = anchor.x + (Math.random() - 0.5) * offset * 2;
        anim.ty = anchor.y + (Math.random() - 0.5) * offset;
      } else {
        anim.tx = 0.08 + Math.random() * 0.84;
        anim.ty = anim.zone[0] + Math.random() * (anim.zone[1] - anim.zone[0]);
      }
    }

    const spd = (chaseTarget ? 1.5 : 0.6) * anim.speed * dt;
    anim.x += dx * spd * 2;
    anim.y += dy * spd * 2 + Math.sin(anim.phase) * 0.0003;
    anim.phase += dt * 3;
    if (Math.abs(dx) > 0.005) anim.facing = dx > 0 ? 1 : -1;

    // Clamp
    anim.x = Math.max(0.04, Math.min(0.96, anim.x));
    anim.y = Math.max(0.05, Math.min(0.88, anim.y));
  }
}

function renderFish(fish) {
  // Sort by Y for depth ordering
  const sorted = [...fish].sort((a, b) => {
    const ay = fishAnims[a.id]?.y || 0;
    const by = fishAnims[b.id]?.y || 0;
    return ay - by;
  });

  for (const f of sorted) {
    const anim = fishAnims[f.id];
    if (!anim) continue;
    const cached = spriteCache[f.speciesId];
    if (!cached) continue;

    const img = anim.facing > 0 ? cached.right : cached.left;
    const scale = anim.sizeVar;
    const drawW = img.width * scale;
    const drawH = img.height * scale;
    const px = anim.x * W - drawW / 2;
    const py = anim.y * H - drawH / 2;

    // Weak state: make grey/transparent
    if (f.weak) {
      ctx.globalAlpha = 0.45;
      ctx.filter = 'grayscale(0.8)';
    }

    ctx.drawImage(img, px, py, drawW, drawH);

    if (f.weak) {
      ctx.globalAlpha = 1;
      ctx.filter = 'none';
    }

    // Level badge
    if (f.level > 1) {
      ctx.fillStyle = 'rgba(0,0,0,.5)';
      ctx.fillRect(px + drawW - 10, py - 2, 12, 10);
      ctx.fillStyle = '#ffd866';
      ctx.font = '8px sans-serif';
      ctx.fillText(f.level, px + drawW - 8, py + 6);
    }
  }
}

// â•â•â•â•â•â•â• FOOD PARTICLES â•â•â•â•â•â•â•

function updateFoodParticles(dt) {
  const fish = gameState?.tanks?.[activeTankId]?.fish || [];
  for (let i = foodParticles.length - 1; i >= 0; i--) {
    const fp = foodParticles[i];
    const sinkSpeed = fp.sink === 'slowSink' ? 25 : fp.sink === 'sink' ? 60 : 5;
    fp.y += sinkSpeed * dt;
    fp.x += Math.sin(fp.phase) * 8 * dt;
    fp.phase += dt * 2;
    fp.life -= dt;

    // Check fish contact
    let eaten = false;
    for (const f of fish) {
      const anim = fishAnims[f.id];
      if (!anim) continue;
      const sp = tankCat?.content?.fish?.[f.speciesId];
      if (!sp || !sp.diet.accepts.includes(fp.foodId)) continue;
      const fdx = fp.x - anim.x * W;
      const fdy = fp.y - anim.y * H;
      if (Math.sqrt(fdx*fdx + fdy*fdy) < 18) {
        API.doAction('fish_consume', { fishId: f.id, foodId: fp.foodId }).then(refreshState);
        showFloatText(fp.x, fp.y, '+fed');
        eaten = true;
        break;
      }
    }

    if (eaten || fp.life <= 0 || fp.y > H) {
      foodParticles.splice(i, 1);
    }
  }
}

function renderFoodParticles() {
  for (const fp of foodParticles) {
    ctx.fillStyle = '#e8c870';
    ctx.beginPath();
    ctx.arc(fp.x, fp.y, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffd866';
    ctx.beginPath();
    ctx.arc(fp.x, fp.y, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }
}

// â•â•â•â•â•â•â• BUBBLES â•â•â•â•â•â•â•

function updateBubbles(dt, biomeKey) {
  const b = BIOMES[biomeKey] || BIOMES.fresh;
  // Spawn
  if (Math.random() < b.bubbleRate * dt * 10) {
    bubbles.push({
      x: 10 + Math.random() * (W - 20),
      y: H * 0.85 + Math.random() * H * 0.1,
      r: 1 + Math.random() * 2.5,
      speed: 15 + Math.random() * 25,
      phase: Math.random() * Math.PI * 2,
    });
  }
  for (let i = bubbles.length - 1; i >= 0; i--) {
    const b = bubbles[i];
    b.y -= b.speed * dt;
    b.x += Math.sin(b.phase + b.y * 0.05) * 0.3;
    if (b.y < -5) bubbles.splice(i, 1);
  }
}

function renderBubbles() {
  ctx.fillStyle = 'rgba(200,230,255,.2)';
  ctx.strokeStyle = 'rgba(200,230,255,.15)';
  ctx.lineWidth = 0.5;
  for (const b of bubbles) {
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  }
}

// â•â•â•â•â•â•â• DIRT & CLEANING â•â•â•â•â•â•â•

function initCleanMask(seed, gridW, gridH, dirtPercent) {
  cleanSeed = seed;
  cleanGridW = gridW; cleanGridH = gridH;
  cleanDirtyStart = dirtPercent;
  const rng = seededRng(seed);
  cleanMask = [];
  const maxX = gridW - 1, maxY = gridH - 1;
  for (let cy = 0; cy < gridH; cy++) {
    for (let cx = 0; cx < gridW; cx++) {
      const isEdge = cx === 0 || cy === 0 || cx === maxX || cy === maxY;
      const isCorner = (cx <= 1 || cx >= maxX - 1) && (cy <= 1 || cy >= maxY - 1);
      let threshold = isCorner ? 0.25 : isEdge ? 0.40 : 0.55;
      threshold *= (1 - dirtPercent * 0.6);
      const dirty = rng() >= threshold;
      const opacity = (0.08 + rng() * 0.12) * (1 + dirtPercent * 0.5);
      cleanMask.push({ dirty, opacity, cleaned: false });
    }
  }
}

function wipeCells(canvasX, canvasY, radius) {
  if (!cleanMask) return;
  const cellW = W / cleanGridW;
  const cellH = H / cleanGridH;
  const cx = Math.floor(canvasX / cellW);
  const cy = Math.floor(canvasY / cellH);
  const r = Math.ceil(radius);
  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      if (dx*dx + dy*dy > r*r) continue;
      const tx = cx + dx, ty = cy + dy;
      if (tx < 0 || tx >= cleanGridW || ty < 0 || ty >= cleanGridH) continue;
      const idx = ty * cleanGridW + tx;
      if (cleanMask[idx].dirty && !cleanMask[idx].cleaned) {
        cleanMask[idx].cleaned = true;
      }
    }
  }
  updateCleanDockLabel();
}

function getCleanProgress() {
  if (!cleanMask) return 0;
  let totalDirty = 0, cleaned = 0;
  for (const c of cleanMask) {
    if (c.dirty) { totalDirty++; if (c.cleaned) cleaned++; }
  }
  return totalDirty === 0 ? 1 : cleaned / totalDirty;
}

function renderDirtOverlay() {
  dirtCtx.clearRect(0, 0, W, H);
  if (activeMode !== 'clean' || !cleanMask) {
    // Simple dirt tint based on cleanliness
    const tank = gameState?.tanks?.[activeTankId];
    if (tank && tank.cleanliness < 90) {
      const dirt = 1 - tank.cleanliness / 100;
      dirtCtx.fillStyle = `rgba(80, 60, 30, ${dirt * 0.3})`;
      dirtCtx.fillRect(0, 0, W, H);
    }
    return;
  }
  // Clean mode: render wipe mask
  const cellW = W / cleanGridW;
  const cellH = H / cleanGridH;
  for (let cy = 0; cy < cleanGridH; cy++) {
    for (let cx = 0; cx < cleanGridW; cx++) {
      const cell = cleanMask[cy * cleanGridW + cx];
      if (!cell.dirty || cell.cleaned) continue;
      dirtCtx.fillStyle = `rgba(80, 60, 30, ${cell.opacity})`;
      dirtCtx.fillRect(cx * cellW, cy * cellH, cellW + 0.5, cellH + 0.5);
    }
  }
}

// â•â•â•â•â•â•â• LASER â•â•â•â•â•â•â•

function renderLaser() {
  if (activeMode !== 'laser' || !laserPos) return;
  const t = Date.now() / 200;
  const pulse = 4 + Math.sin(t) * 1.5;
  ctx.fillStyle = 'rgba(255,50,50,.7)';
  ctx.beginPath();
  ctx.arc(laserPos.x, laserPos.y, pulse, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = 'rgba(255,150,150,.4)';
  ctx.beginPath();
  ctx.arc(laserPos.x, laserPos.y, pulse + 3, 0, Math.PI * 2);
  ctx.fill();
}

// â•â•â•â•â•â•â• FLOAT TEXT â•â•â•â•â•â•â•

function showFloatText(x, y, text, color) {
  const el = document.createElement('div');
  el.className = 'float-text';
  el.textContent = text;
  if (color) el.style.color = color;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  $('tankWrap').appendChild(el);
  setTimeout(() => el.remove(), 1600);
}

// â•â•â•â•â•â•â• HUD â•â•â•â•â•â•â•

function updateHUD() {
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank) return;

  $('coinCount').textContent = Math.floor(tank.coins);

  const clean = Math.round(tank.cleanliness);
  $('cleanFill').style.width = clean + '%';
  $('cleanFill').style.background = clean > 60 ? '#4caf88' : clean > 30 ? '#e8a040' : '#e05050';
  $('cleanVal').textContent = clean + '%';

  // Average hunger of all fish
  const fish = tank.fish || [];
  const avgHunger = fish.length > 0
    ? Math.round(fish.reduce((s, f) => s + f.hunger, 0) / fish.length)
    : 100;
  $('hungerFill').style.width = avgHunger + '%';
  $('hungerFill').style.background = avgHunger > 60 ? '#e8a040' : avgHunger > 30 ? '#e07838' : '#e05050';
  $('hungerVal').textContent = avgHunger + '%';

  // Tank nav
  const unlocked = tanksList ? tanksList.filter(t => t.unlocked) : [];
  const navEl = $('tankNav');
  if (unlocked.length > 1) {
    navEl.classList.remove('hidden');
    $('tnLabel').textContent = (BIOMES[activeTankId] || BIOMES.fresh).label;
  } else {
    navEl.classList.add('hidden');
  }

  // Container attrs
  const wc = $('widgetContainer');
  wc.dataset.tank = activeTankId;
  wc.dataset.tier = TANK_TIER_MAP[activeTankId] || '1';
}

// â•â•â•â•â•â•â• TOAST â•â•â•â•â•â•â•

let toastTimer = null;
function showToast(msg, duration) {
  const t = $('toast');
  t.textContent = msg;
  t.classList.add('visible');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => t.classList.remove('visible'), duration || 3000);
}

// â•â•â•â•â•â•â• HUD TOOLTIP â•â•â•â•â•â•â•

function showHudTooltip(title, body) {
  $('hudTooltipTitle').textContent = title;
  $('hudTooltipBody').textContent = body;
  $('hudTooltip').classList.add('visible');
  clearTimeout(tooltipTimer);
  tooltipTimer = setTimeout(() => $('hudTooltip').classList.remove('visible'), 4000);
}

// â•â•â•â•â•â•â• FISH BUBBLE â•â•â•â•â•â•â•

function showFishBubble(f, px, py) {
  $('decorCard').classList.remove('visible'); // dismiss decor card
  const fb = $('fishBubble');
  const c = f._computed || {};
  $('fbName').textContent = c.speciesName || f.speciesId;
  $('fbSpecies').textContent = `Lv.${f.level} ${c.lifeStage || ''}`;
  $('fbDetail').innerHTML = `â¤ï¸ ${Math.round(f.health)} &nbsp; ğŸ˜Š ${c.happiness ?? '?'} &nbsp; ğŸ½ ${Math.round(f.hunger)}<br>ğŸ’° ${c.coinRate ?? 0}/hr`;
  $('fbStage').textContent = f.weak ? 'âš ï¸ Weak' : '';
  fb.style.left = Math.min(px, W - 140) + 'px';
  fb.style.top = Math.max(py - 60, 4) + 'px';
  fb.classList.add('visible');
  clearTimeout(fb._timer);
  fb._timer = setTimeout(() => fb.classList.remove('visible'), 4000);
}

// â•â•â•â•â•â•â• DECOR CARD â•â•â•â•â•â•â•

function showDecorCard(d, px, py) {
  $('fishBubble').classList.remove('visible'); // dismiss fish bubble
  const dc = $('decorCard');
  const dd = tankCat?.content?.decor?.[d.decorId];
  if (!dd) return;

  $('dcName').textContent = dd.name || d.decorId;
  const growInfo = dd.growth ? `Size: ${d.size.toFixed(1)} / ${dd.growth.maxSize}` : 'Static';
  $('dcInfo').textContent = `${dd.placement} Â· ${growInfo}`;

  let actionsHtml = '';
  if (dd.growth) {
    const atMin = d.size <= (dd.growth.minSize + 0.01);
    actionsHtml += `<button class="dc-trim" ${atMin ? 'disabled' : ''} data-trim-decor="${d.id}">âœ‚ï¸ Trim</button>`;
  }
  actionsHtml += `<button class="dc-sell" data-sell-decor-card="${d.id}">Sell</button>`;
  $('dcActions').innerHTML = actionsHtml;

  // Bind trim handler
  const trimBtn = $('dcActions').querySelector('[data-trim-decor]');
  if (trimBtn) {
    trimBtn.onclick = async () => {
      const res = await API.doAction('trim_plant', { decorInstanceId: d.id });
      if (res?.result?.trimmed) {
        showToast(`Trimmed! Size: ${res.result.newSize.toFixed(1)}`);
        await refreshState();
        dc.classList.remove('visible');
      } else if (res?.result?.error) {
        showToast(res.result.error);
      }
    };
  }

  // Bind sell handler
  const sellBtn = $('dcActions').querySelector('[data-sell-decor-card]');
  if (sellBtn) {
    sellBtn.onclick = async () => {
      const res = await API.doAction('sell_decor', { decorInstanceId: d.id });
      if (res?.result?.sold) {
        showToast(`Sold for ${res.result.value} coins`);
        await refreshState();
        dc.classList.remove('visible');
      } else if (res?.result?.error) {
        showToast(res.result.error);
      }
    };
  }

  dc.style.left = Math.min(px, W - 160) + 'px';
  dc.style.top = Math.max(py - 50, 4) + 'px';
  dc.classList.add('visible');
  clearTimeout(dc._timer);
  dc._timer = setTimeout(() => dc.classList.remove('visible'), 8000);
}

// â•â•â•â•â•â•â• FAB & MENU â•â•â•â•â•â•â•

function toggleMenu() {
  menuOpen = !menuOpen;
  $('menuOverlay').classList.toggle('visible', menuOpen);
  $('fab').classList.toggle('active', menuOpen);
  // Close any active panel when menu toggles
}

function closeMenu() {
  menuOpen = false;
  $('menuOverlay').classList.remove('visible');
  $('fab').classList.remove('active');
}

function handleMenuAction(action) {
  closeMenu();
  switch (action) {
    case 'feed': enterFeedMode(); break;
    case 'clean': enterCleanMode(); break;
    case 'laser': enterLaserMode(); break;
    case 'store': openPanel('storePanel'); break;
    case 'upgrades': openPanel('upgradesPanel'); break;
    case 'inventory': openPanel('inventoryPanel'); break;
    case 'tanks': openPanel('tanksPanel'); break;
    case 'help': openPanel('helpPanel'); break;
  }
}

// â•â•â•â•â•â•â• TOOL MODES â•â•â•â•â•â•â•

function exitToolMode() {
  activeMode = null;
  $('toolDock').classList.remove('visible');
  $('fab').style.display = '';
  laserPos = null;
  cleanMask = null;
  selectedFoodId = null;
  renderDirtOverlay();
}

function enterFeedMode() {
  exitToolMode();
  activeMode = 'feed';
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank || !tankCat) return;

  const foods = Object.entries(tank.foodStock || {}).filter(([, qty]) => qty > 0);
  const allFoods = Object.entries(tankCat.content?.food || {});
  const dock = $('toolDockContent');
  dock.innerHTML = '';

  for (const [fid, fdef] of allFoods) {
    const qty = tank.foodStock?.[fid] || 0;
    const el = document.createElement('div');
    el.className = 'dock-item' + (selectedFoodId === fid ? ' active' : '');
    el.innerHTML = `<span>${fdef.name}</span><span class="dock-qty">Ã—${qty}</span>`;
    el.onclick = () => {
      selectedFoodId = fid;
      dock.querySelectorAll('.dock-item').forEach(d => d.classList.remove('active'));
      el.classList.add('active');
    };
    dock.appendChild(el);
  }
  // Auto-select first available food
  if (!selectedFoodId || !(tank.foodStock?.[selectedFoodId] > 0)) {
    const first = allFoods.find(([fid]) => (tank.foodStock?.[fid] || 0) > 0);
    if (first) {
      selectedFoodId = first[0];
      dock.querySelector('.dock-item')?.classList.add('active');
    }
  }

  $('toolDock').classList.add('visible');
  $('fab').style.display = 'none';
}

async function enterCleanMode() {
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank) return;
  if (tank.cleanliness >= 98) {
    showToast('Your tank is sparkling clean! âœ¨');
    return;
  }
  exitToolMode();
  activeMode = 'clean';

  const res = await API.doAction('start_clean');
  const r = res?.result;
  if (r && r.started) {
    initCleanMask(r.seed, r.gridW || 64, r.gridH || 48, r.dirtPercent);
    renderDirtOverlay();
  }

  const dock = $('toolDockContent');
  dock.innerHTML = '<span id="cleanDockLabel">Wipe to clean!</span>';
  $('toolDock').classList.add('visible');
  $('fab').style.display = 'none';
}

function updateCleanDockLabel() {
  const lbl = $('cleanDockLabel');
  if (!lbl) return;
  const prog = getCleanProgress();
  if (prog >= 0.99) {
    lbl.textContent = 'Tank cleaned! âœ¨';
  } else if (prog > 0) {
    lbl.textContent = `${Math.round(prog * 100)}% cleaned`;
  } else {
    lbl.textContent = 'Wipe to clean!';
  }
}

async function finishClean() {
  const progress = getCleanProgress();
  const res = await API.doAction('finish_clean', { improvementPercent: Math.round(progress * 100) });
  const r = res?.result;
  cleanMask = null;
  renderDirtOverlay();

  if (r && r.coinsEarned > 0) {
    if (progress >= 0.95) {
      showToast(`Tank cleaned! +${r.coinsEarned} coins ğŸª™`);
    } else {
      showToast(`Partially cleaned! +${r.coinsEarned} coins ğŸª™`);
    }
  } else if (progress < 0.05) {
    showToast('Barely cleaned...');
  } else {
    showToast('Partially cleaned!');
  }
  await refreshState();
}

function enterLaserMode() {
  exitToolMode();
  activeMode = 'laser';
  laserActive = true;
  laserStartTime = Date.now();

  const dock = $('toolDockContent');
  dock.innerHTML = '<span>ğŸ”´ Move your finger to play! Fish love to chase the dot.</span>';
  $('toolDock').classList.add('visible');
  $('fab').style.display = 'none';
}

async function triggerLaserReward() {
  const elapsed = Date.now() - laserStartTime;
  if (elapsed < 5000) return; // Need 5 seconds of play
  const res = await API.doAction('laser_pointer');
  const r = res?.result;
  if (r?.reward) {
    showToast(`+${r.reward.coins} coins! Fish had fun! ğŸ‰`);
    showFloatText(W / 2, H / 2, `+${r.reward.coins}`, '#ffd866');
    await refreshState();
  } else if (r?.cooldownRemaining) {
    const mins = Math.ceil(r.cooldownRemaining / 60000);
    showToast(`Play cooldown: ${mins > 60 ? Math.floor(mins/60)+'h '+mins%60+'m' : mins+'m'}`);
  }
}

// â•â•â•â•â•â•â• PANELS â•â•â•â•â•â•â•

function openPanel(panelId) {
  closeAllPanels();
  const el = $(panelId);
  if (!el) return;
  activePanel = panelId;
  el.classList.add('visible');
  populatePanel(panelId);
}

function closeAllPanels() {
  document.querySelectorAll('.panel').forEach(p => p.classList.remove('visible'));
  activePanel = null;
}

function populatePanel(panelId) {
  switch (panelId) {
    case 'storePanel': populateStore(); break;
    case 'upgradesPanel': populateUpgrades(); break;
    case 'inventoryPanel': populateInventory(); break;
    case 'tanksPanel': populateTanks(); break;
    case 'helpPanel': populateHelp(); break;
  }
}

function populateStore() {
  if (!storeData || !tankCat) return;
  const list = $('storeList');
  const tank = gameState?.tanks?.[activeTankId];
  const cap = tankCat.capacity?.spaceCapacity || 8;
  const used = tankCat._computed?.usedSpace || 0;
  $('storeCap').textContent = `${used}/${cap}`;

  // Tabs
  const sections = Object.keys(storeData);
  let html = '<div class="store-tabs">';
  for (const sec of ['fish','food','decor','tools']) {
    if (!storeData[sec]) continue;
    const label = sec === 'fish' ? 'Fish' : sec === 'food' ? 'Food' : sec === 'decor' ? 'Decorations' : 'Tools';
    html += `<button class="store-tab ${storeTab === sec ? 'active' : ''}" data-tab="${sec}">${label}</button>`;
  }
  html += '</div>';

  // Items for active tab
  const items = storeData[storeTab] || [];
  if (items.length === 0) {
    html += '<div style="opacity:.5;text-align:center;padding:20px">Nothing available</div>';
  }

  if (storeTab === 'fish') {
    html += `<div class="panel-section-title">Fish â€” Space: ${used}/${cap}</div>`;
    for (const item of items) {
      const locked = !item.canBuy;
      const reqText = item.reqInfo?.length ? `<div class="s-desc" style="color:#e8a040;opacity:.8">âš ï¸ ${item.reqInfo.join(', ')}</div>` : '';
      html += `<div class="s-item ${locked && item.blockReason !== 'Not enough coins' ? 'locked' : ''}">
        <div class="s-icon">ğŸŸ</div>
        <div class="s-info">
          <div class="s-name">${item.name}</div>
          <div class="s-desc">â—†${item.spaceCost} space Â· ${item.baseCoinPerHour}/hr${item.ownedCount > 0 ? ' Â· Ã—' + item.ownedCount + ' owned' : ''}</div>
          ${reqText}
        </div>
        <button class="buy-btn primary" ${!item.canBuy ? 'disabled' : ''} data-buy-fish="${item.id}">
          ${item.blockReason?.includes('full') || item.blockReason?.includes('Max') ? 'Full' : item.price + ' ğŸª™'}
        </button>
      </div>`;
    }
  } else if (storeTab === 'food') {
    html += '<div class="panel-section-title">Food</div>';
    for (const item of items) {
      html += `<div class="s-item">
        <div class="s-icon">ğŸ½</div>
        <div class="s-info">
          <div class="s-name">${item.name}</div>
          <div class="s-desc">+${item.hungerRestore} hunger Â· Stock: Ã—${item.currentStock}</div>
        </div>
        <button class="buy-btn primary" ${!item.canBuy ? 'disabled' : ''} data-buy-food="${item.id}">
          ${item.price * 5} ğŸª™ Ã—5
        </button>
      </div>`;
    }
  } else if (storeTab === 'decor') {
    html += '<div class="panel-section-title">Decorations</div>';
    for (const item of items) {
      html += `<div class="s-item ${!item.canBuy ? 'locked' : ''}">
        <div class="s-icon" style="color:${DECOR_COLORS[item.id] || '#888'}">â—</div>
        <div class="s-info">
          <div class="s-name">${item.name}</div>
          <div class="s-desc">${item.placement} Â· ${item.growth ? 'grows' : 'static'}${item.blockReason ? ' Â· ' + item.blockReason : ''}</div>
        </div>
        <button class="buy-btn primary" ${!item.canBuy ? 'disabled' : ''} data-buy-decor="${item.id}">
          ${item.price} ğŸª™
        </button>
      </div>`;
    }
  } else if (storeTab === 'tools') {
    html += '<div class="panel-section-title">Equipment</div>';
    for (const item of items) {
      html += `<div class="s-item">
        <div class="s-icon">ğŸ”§</div>
        <div class="s-info">
          <div class="s-name">${item.name}</div>
          <div class="s-desc">Level ${item.currentLevel}/${item.maxLevel}${item.maxed ? ' (Max)' : ''}</div>
        </div>
        <button class="buy-btn primary" ${!item.canBuy ? 'disabled' : ''} data-buy-tool="${item.id}">
          ${item.maxed ? 'Max' : item.nextPrice + ' ğŸª™'}
        </button>
      </div>`;
    }
  }

  list.innerHTML = html;

  // Tab click handlers
  list.querySelectorAll('.store-tab').forEach(tab => {
    tab.onclick = () => { storeTab = tab.dataset.tab; populateStore(); };
  });

  // Buy handlers
  list.querySelectorAll('[data-buy-fish]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('buy_fish', { speciesId: btn.dataset.buyFish });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.bought) showToast(`Bought ${btn.dataset.buyFish}! ğŸŸ`);
      await refreshState();
      populateStore();
    };
  });
  list.querySelectorAll('[data-buy-food]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('buy_food', { foodId: btn.dataset.buyFood, quantity: 5 });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.bought) showToast(`Bought ${res.result.quantity}Ã— food`);
      await refreshState();
      populateStore();
    };
  });
  list.querySelectorAll('[data-buy-decor]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('buy_decor', { decorId: btn.dataset.buyDecor });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.bought) showToast('Decoration placed! ğŸ¨');
      await refreshState();
      populateStore();
    };
  });
  list.querySelectorAll('[data-buy-tool]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('buy_tool', { toolId: btn.dataset.buyTool });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.bought) showToast(`Upgraded ${btn.dataset.buyTool}! ğŸ”§`);
      await refreshState();
      populateStore();
    };
  });
}

function populateUpgrades() {
  const list = $('upgradesList');
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank || !tankCat) { list.innerHTML = '<div style="opacity:.5">No tools available for this tank.</div>'; return; }

  let html = '<div class="panel-section-title">Equipment</div>';
  const tools = tankCat.content?.tools || {};
  const toolEntries = Object.entries(tools);

  if (toolEntries.length === 0) {
    html += '<div style="opacity:.5;padding:10px">No equipment available for this tank.</div>';
  }

  for (const [toolId, toolDef] of toolEntries) {
    const level = tank.toolsOwned?.[toolId] || 0;
    const maxed = level >= toolDef.maxLevel;
    const nextPrice = maxed ? null : toolDef.prices[level];
    const canBuy = !maxed && tank.coins >= (nextPrice || Infinity);

    html += `<div class="s-item">
      <div class="s-icon">ğŸ”§</div>
      <div class="s-info">
        <div class="s-name">${toolDef.name}</div>
        <div class="s-desc">Level ${level}/${toolDef.maxLevel}${maxed ? ' â€” Fully upgraded' : ''}</div>
      </div>
      <button class="buy-btn primary" ${!canBuy ? 'disabled' : ''} data-upgrade-tool="${toolId}">
        ${maxed ? 'Max' : nextPrice + ' ğŸª™'}
      </button>
    </div>`;
  }

  // Show utility fish
  const utilFish = (tank.fish || []).filter(f => {
    const sp = tankCat.content?.fish?.[f.speciesId];
    return sp?.utility;
  });
  if (utilFish.length > 0) {
    html += '<div class="panel-section-title">Utility Creatures</div>';
    for (const f of utilFish) {
      const sp = tankCat.content?.fish?.[f.speciesId];
      html += `<div class="s-item">
        <div class="s-icon">ğŸŒ</div>
        <div class="s-info">
          <div class="s-name">${sp.name}</div>
          <div class="s-desc">Reduces dirt by ${Math.round((sp.utility.dirtReduction||0)*100)}%</div>
        </div>
      </div>`;
    }
  }

  list.innerHTML = html;

  list.querySelectorAll('[data-upgrade-tool]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('buy_tool', { toolId: btn.dataset.upgradeTool });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.bought) showToast('Tool upgraded! ğŸ”§');
      await refreshState();
      populateUpgrades();
    };
  });
}

function populateInventory() {
  const list = $('inventoryList');
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank || !tankCat) { list.innerHTML = ''; return; }

  let html = '';

  // Food stock
  const foods = Object.entries(tank.foodStock || {}).filter(([, q]) => q > 0);
  if (foods.length > 0 || Object.keys(tankCat.content?.food || {}).length > 0) {
    html += '<div class="panel-section-title">Food Stock</div>';
    for (const [fid, fdef] of Object.entries(tankCat.content?.food || {})) {
      const qty = tank.foodStock?.[fid] || 0;
      html += `<div class="s-item">
        <div class="s-icon">ğŸ½</div>
        <div class="s-info">
          <div class="s-name">${fdef.name}</div>
          <div class="s-desc">Stock: Ã—${qty}</div>
        </div>
      </div>`;
    }
  }

  // Fish
  const fish = tank.fish || [];
  if (fish.length > 0) {
    html += '<div class="panel-section-title">Fish</div>';
    for (const f of fish) {
      const c = f._computed || {};
      const sp = tankCat.content?.fish?.[f.speciesId];
      html += `<div class="s-item">
        <div class="s-icon">ğŸŸ</div>
        <div class="s-info">
          <div class="s-name">${c.speciesName || f.speciesId} ${f.weak ? 'âš ï¸' : ''}</div>
          <div class="s-desc">Lv.${f.level} ${c.lifeStage||''} Â· ğŸ˜Š${c.happiness??'?'} Â· ğŸ½${Math.round(f.hunger)} Â· ğŸ’°${c.coinRate||0}/hr</div>
        </div>
        ${fish.length > 1 ? `<button class="sell-btn" data-sell-fish="${f.id}">Sell</button>` : ''}
      </div>`;
    }
  }

  // Decorations
  const decors = tank.decor || [];
  if (decors.length > 0) {
    html += '<div class="panel-section-title">Decorations</div>';
    for (const d of decors) {
      const dd = tankCat.content?.decor?.[d.decorId];
      html += `<div class="s-item">
        <div class="s-icon" style="color:${DECOR_COLORS[d.decorId]||'#888'}">â—</div>
        <div class="s-info">
          <div class="s-name">${dd?.name || d.decorId}</div>
          <div class="s-desc">${dd?.growth ? 'Size: ' + d.size.toFixed(1) : 'Static'}</div>
        </div>
        <button class="sell-btn" data-sell-decor="${d.id}">Sell</button>
      </div>`;
    }
  }

  list.innerHTML = html;

  list.querySelectorAll('[data-sell-fish]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('sell_fish', { fishId: btn.dataset.sellFish });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.sold) showToast(`Sold for ${res.result.value} coins`);
      await refreshState();
      populateInventory();
    };
  });
  list.querySelectorAll('[data-sell-decor]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('sell_decor', { decorInstanceId: btn.dataset.sellDecor });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.sold) showToast(`Sold for ${res.result.value} coins`);
      await refreshState();
      populateInventory();
    };
  });
}

function populateTanks() {
  const list = $('tanksList');
  if (!tanksList) { list.innerHTML = ''; return; }

  let html = '';
  for (const t of tanksList) {
    const isCurrent = t.tankId === activeTankId;
    const b = BIOMES[t.tankId] || {};
    html += `<div class="s-item ${isCurrent ? 'active-tank' : ''}">
      <div class="s-icon">${t.unlocked ? 'ğŸ ' : 'ğŸ”’'}</div>
      <div class="s-info">
        <div class="s-name">${t.name}${isCurrent ? ' â€” Current' : ''}</div>
        <div class="s-desc">${t.unlocked ? `${t.fishCount} fish Â· ${t.usedSpace}/${t.spaceCapacity} space Â· ${t.coins} coins` : t.unlockLabel}</div>
      </div>
      ${!isCurrent && t.unlocked ?
        `<button class="buy-btn primary" data-switch-tank="${t.tankId}">Switch</button>` :
        (!t.unlocked ?
          `<button class="buy-btn primary" ${!t.meetsRequirements ? 'disabled' : ''} data-unlock-tank="${t.tankId}">${t.meetsRequirements ? 'Unlock' : 'Locked'}</button>` :
          '')}
    </div>`;
  }

  list.innerHTML = html;

  list.querySelectorAll('[data-switch-tank]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('switch_tank', { tankId: btn.dataset.switchTank });
      if (res?.result?.switched) {
        await refreshState();
        closeAllPanels();
      }
    };
  });
  list.querySelectorAll('[data-unlock-tank]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('unlock_tank', { tankId: btn.dataset.unlockTank });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.unlocked) {
        showToast(`Unlocked ${res.result.tankName}! ğŸ‰`);
        await refreshState();
        populateTanks();
      }
    };
  });
}

function populateHelp() {
  $('helpBody').innerHTML = `
    <div class="panel-section-title">Getting Started</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      You start with a Fresh tank and one guppy. Feed your fish, keep the tank clean, and earn coins.
      Buy more fish and supplies from the Store!
    </p>
    <div class="panel-section-title">Tanks &amp; Switching</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Multiple tank biomes are available, each with unique fish, coins, food, and decor.
      Unlock new tanks by earning lifetime coins. Fresh â†’ Tropical â†’ Saltwater.
    </p>
    <div class="panel-section-title">Feeding</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Open Feed mode from the menu. Tap on the tank to drop food. Switch food types in the dock.
      Different fish eat different foods â€” check what your fish accepts!
    </p>
    <div class="panel-section-title">Cleaning</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Dirt builds up over time. Open Clean mode and swipe to wipe away grime.
      Earn coins proportional to dirt removed! Filters and snails slow dirt accumulation.
    </p>
    <div class="panel-section-title">Play</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Open Play mode for a laser pointer. Fish will chase the dot!
      Earn coins and XP every 6 hours of cooldown.
    </p>
    <div class="panel-section-title">Decor &amp; Plants</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Buy decor from the Store. Plants grow over time â€” trim overgrown plants by tapping them.
      Floating plants can multiply into new clusters. Some fish require specific decor to be happy.
    </p>
    <div class="panel-section-title">Happiness &amp; Requirements</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Each fish has a happiness score (0â€“100). Hunger, cleanliness, tools, and decor affect happiness.
      Missing required decor or tools causes large penalties. Happy fish generate more coins!
      Tap a fish to see its happiness breakdown.
    </p>
    <div class="panel-section-title">Weak State &amp; Recovery</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Fish never die permanently. Neglected fish become Weak â€” they stop generating coins and appear grey.
      To recover: feed them and clean the tank. Health regenerates over time once conditions improve.
    </p>
    <div class="panel-section-title">Store Rules</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Some items require tools or lifetime coins to unlock. Tank space limits how many fish you can have.
      Fish prices increase for each one you already own. Selling returns a fraction of the purchase price.
      Tools can't be sold â€” they're permanent upgrades.
    </p>
    <button class="reset-btn" id="resetBtn">ğŸ—‘ Reset Aquarium</button>
  `;

  $('resetBtn').onclick = async () => {
    if (confirm('Are you sure you want to reset your aquarium? All progress will be lost!')) {
      await API.doAction('reset_state');
      await refreshState();
      closeAllPanels();
      showToast('Aquarium reset!');
    }
  };
}

// â•â•â•â•â•â•â• INPUT HANDLING â•â•â•â•â•â•â•

function setupInput() {
  // FAB
  $('fab').onclick = toggleMenu;

  // Menu buttons
  document.querySelectorAll('.menu-btn').forEach(btn => {
    btn.onclick = () => handleMenuAction(btn.dataset.action);
  });

  // Panel close buttons
  document.querySelectorAll('[data-close]').forEach(btn => {
    btn.onclick = () => {
      const panelId = btn.dataset.close;
      $(panelId)?.classList.remove('visible');
      if (activePanel === panelId) activePanel = null;
    };
  });

  // Dock close
  document.querySelector('.dock-close').onclick = async () => {
    if (activeMode === 'clean' && cleanMask) {
      await finishClean();
    }
    if (activeMode === 'laser') {
      await triggerLaserReward();
    }
    exitToolMode();
  };

  // HUD tooltips
  $('coinDisplay').onclick = () => {
    const tank = gameState?.tanks?.[activeTankId];
    const lifetime = gameState?.lifetime?.coinsEarned || 0;
    showHudTooltip('Coins', `Current: ${Math.floor(tank?.coins||0)}\nLifetime: ${Math.floor(lifetime)}`);
  };
  $('cleanBar').onclick = () => {
    const tank = gameState?.tanks?.[activeTankId];
    showHudTooltip('Cleanliness', `${Math.round(tank?.cleanliness||0)}%\nKeep above 60% for happy fish!`);
  };
  $('hungerBar').onclick = () => {
    const fish = gameState?.tanks?.[activeTankId]?.fish || [];
    const avg = fish.length > 0 ? Math.round(fish.reduce((s,f) => s + f.hunger, 0)/fish.length) : 100;
    showHudTooltip('Hunger', `Average: ${avg}%\nFeed fish when below 70%!`);
  };

  // Tank nav
  $('tnPrev').onclick = () => switchTankNav(-1);
  $('tnNext').onclick = () => switchTankNav(1);

  // Canvas interactions
  const canvasEl = canvas;
  let isDragging = false;
  let lastDragPos = null;

  function getCanvasPos(e) {
    const rect = canvasEl.getBoundingClientRect();
    const touch = e.touches ? e.touches[0] : e;
    return {
      x: (touch.clientX - rect.left) * (W / rect.width),
      y: (touch.clientY - rect.top) * (H / rect.height),
    };
  }

  canvasEl.addEventListener('mousedown', onPointerDown);
  canvasEl.addEventListener('touchstart', onPointerDown, { passive: false });
  canvasEl.addEventListener('mousemove', onPointerMove);
  canvasEl.addEventListener('touchmove', onPointerMove, { passive: false });
  canvasEl.addEventListener('mouseup', onPointerUp);
  canvasEl.addEventListener('touchend', onPointerUp);

  function onPointerDown(e) {
    if (e.touches) e.preventDefault();
    const pos = getCanvasPos(e);
    isDragging = true;
    lastDragPos = pos;

    if (activeMode === 'clean') {
      wipeCells(pos.x, pos.y, 3);
      renderDirtOverlay();
    } else if (activeMode === 'laser') {
      laserPos = pos;
    } else if (activeMode === 'feed') {
      dropFood(pos.x, pos.y);
    } else {
      // Normal mode: check fish tap
      checkFishTap(pos.x, pos.y);
    }
  }

  function onPointerMove(e) {
    if (!isDragging) return;
    if (e.touches) e.preventDefault();
    const pos = getCanvasPos(e);

    if (activeMode === 'clean') {
      wipeCells(pos.x, pos.y, 3);
      renderDirtOverlay();
    } else if (activeMode === 'laser') {
      laserPos = pos;
    }
    lastDragPos = pos;
  }

  function onPointerUp(e) {
    isDragging = false;
    if (activeMode === 'clean') {
      // Auto-complete check
      const prog = getCleanProgress();
      if (prog >= 0.99) {
        finishClean();
        exitToolMode();
      }
    }
  }
}

async function dropFood(x, y) {
  if (!selectedFoodId) { showToast('Select a food first!'); return; }
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank || (tank.foodStock?.[selectedFoodId] || 0) <= 0) {
    showToast('Out of food! Buy more from the Store.');
    return;
  }

  const res = await API.doAction('feed', { foodId: selectedFoodId });
  if (res?.result?.error) { showToast(res.result.error); return; }
  if (res?.result?.fed) {
    const fdef = tankCat?.content?.food?.[selectedFoodId];
    foodParticles.push({
      x, y, foodId: selectedFoodId,
      sink: fdef?.sinkBehavior || 'slowSink',
      phase: Math.random() * Math.PI * 2,
      life: 12,
    });
    // Update local stock
    if (tank.foodStock[selectedFoodId]) tank.foodStock[selectedFoodId]--;
    // Refresh dock display
    enterFeedMode();
  }
}

function checkFishTap(px, py) {
  const tank = gameState?.tanks?.[activeTankId];
  const fish = tank?.fish || [];
  // Check fish first
  for (const f of fish) {
    const anim = fishAnims[f.id];
    if (!anim) continue;
    const fx = anim.x * W, fy = anim.y * H;
    if (Math.abs(px - fx) < 20 && Math.abs(py - fy) < 15) {
      showFishBubble(f, fx, fy);
      return;
    }
  }
  // Check decor
  const decors = tank?.decor || [];
  const biome = BIOMES[activeTankId] || BIOMES.fresh;
  const subY = H * (1 - biome.subH);
  for (const d of decors) {
    const dd = tankCat?.content?.decor?.[d.decorId];
    if (!dd) continue;
    const dx = d.x * W;
    const baseSize = (d.size || 1) * PX_SCALE * 4;
    let hitW, hitH, hitX, hitY;
    if (dd.placement === 'top') {
      hitW = baseSize * 2.4; hitH = 14; hitX = dx; hitY = 6;
    } else if (dd.growth) {
      hitW = baseSize * 1.2; hitH = baseSize * 5; hitX = dx; hitY = subY - hitH;
    } else {
      hitW = baseSize * 3; hitH = baseSize * 1.6; hitX = dx; hitY = subY - baseSize * 0.8;
    }
    if (Math.abs(px - hitX) < hitW / 2 && py > hitY - 4 && py < hitY + hitH + 4) {
      showDecorCard(d, px, py);
      return;
    }
  }
  // No fish/decor tapped â€” dismiss popups
  $('fishBubble').classList.remove('visible');
  $('decorCard').classList.remove('visible');
}

async function switchTankNav(dir) {
  if (!tanksList) return;
  const unlocked = tanksList.filter(t => t.unlocked);
  const currentIdx = unlocked.findIndex(t => t.tankId === activeTankId);
  const nextIdx = (currentIdx + dir + unlocked.length) % unlocked.length;
  const nextTank = unlocked[nextIdx];
  if (nextTank && nextTank.tankId !== activeTankId) {
    exitToolMode();
    const res = await API.doAction('switch_tank', { tankId: nextTank.tankId });
    if (res?.result?.switched) await refreshState();
  }
}

// â•â•â•â•â•â•â• STATE SYNC â•â•â•â•â•â•â•

async function refreshState() {
  try {
    const res = await API.getState();
    if (!res) return;
    applyState(res);
  } catch (err) {
    console.error('Failed to refresh state:', err);
  }
}

function applyState(res) {
  gameState = res.save;
  activeTankId = res.activeTankId || gameState?.activeTankId || 'fresh';
  tankCat = res.tankCatalog;
  storeData = res.store;
  tanksList = res.tanksList;
  globalCat = res.global;

  // Prune anims for fish no longer present
  const fishIds = new Set((gameState?.tanks?.[activeTankId]?.fish || []).map(f => f.id));
  for (const id of Object.keys(fishAnims)) {
    if (!fishIds.has(id)) delete fishAnims[id];
  }

  updateHUD();

  // Refresh active panel if open
  if (activePanel) populatePanel(activePanel);
}

// â•â•â•â•â•â•â• GAME LOOP â•â•â•â•â•â•â•

function gameLoop(timestamp) {
  const dt = Math.min((timestamp - lastFrameTime) / 1000, 0.1) || 0.016;
  lastFrameTime = timestamp;

  resizeCanvas();

  const tank = gameState?.tanks?.[activeTankId];
  const fish = tank?.fish || [];

  // Update
  updateFishAnim(fish, dt);
  updateFoodParticles(dt);
  updateBubbles(dt, activeTankId);

  // Render
  ctx.clearRect(0, 0, W, H);
  renderEnvironment(activeTankId);
  renderDecor(tank?.decor, activeTankId);
  renderEquipment(tank?.toolsOwned);
  renderFish(fish);
  renderFoodParticles();
  renderBubbles();
  renderLaser();
  renderDirtOverlay();

  requestAnimationFrame(gameLoop);
}

// â•â•â•â•â•â•â• RESIZE â•â•â•â•â•â•â•

function resizeCanvas() {
  const rect = canvas.parentElement.getBoundingClientRect();
  const newW = Math.round(rect.width);
  const newH = Math.round(rect.height);
  if (newW === W && newH === H) return;

  DPR = window.devicePixelRatio || 1;
  W = newW;
  H = newH;
  canvas.width = W * DPR;
  canvas.height = H * DPR;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  ctx.imageSmoothingEnabled = false;

  dirtCanvas.width = W * DPR;
  dirtCanvas.height = H * DPR;
  dirtCanvas.style.width = W + 'px';
  dirtCanvas.style.height = H + 'px';
  dirtCtx.setTransform(DPR, 0, 0, DPR, 0, 0);

  PX_SCALE = Math.max(2, Math.floor(Math.min(W, H) / 100));
  buildSpriteCache();
}

// â•â•â•â•â•â•â• HELPERS â•â•â•â•â•â•â•

function seededRng(seed) {
  let s = seed | 0;
  return function() { s = (s * 1664525 + 1013904223) | 0; return (s >>> 0) / 4294967296; };
}

function shadeColor(hex, amt) {
  let r = parseInt(hex.slice(1,3),16) + amt;
  let g = parseInt(hex.slice(3,5),16) + amt;
  let b = parseInt(hex.slice(5,7),16) + amt;
  r = Math.max(0,Math.min(255,r));
  g = Math.max(0,Math.min(255,g));
  b = Math.max(0,Math.min(255,b));
  return `rgb(${r},${g},${b})`;
}

// â•â•â•â•â•â•â• INIT â•â•â•â•â•â•â•

async function init(homey) {
  if (homey) window.Homey = homey;
  try {
    await Homey.ready();
  } catch (e) {
    // Standalone / sandbox mode
  }

  await API.init();
  setupInput();
  resizeCanvas();

  // Check reset setting
  try {
    const settings = await Homey.getSettings();
    if (settings?.reset_state) {
      await API.doAction('reset_state');
      try { await Homey.set('reset_state', false); } catch(e) {}
    }
  } catch (e) { /* ignore in sandbox */ }

  // Initial state load
  const res = await API.getState();
  if (res) {
    applyState(res);

    // Show "while you were away" if significant idle earnings
    if (res.simResult?.coinsEarned > 5) {
      showToast(`While away: +${res.simResult.coinsEarned} coins earned! ğŸª™`, 4000);
    }
  }

  // Hide loading
  $('loading').classList.add('hidden');

  // Start game loop
  lastFrameTime = performance.now();
  requestAnimationFrame(gameLoop);

  // Periodic refresh every 5 minutes
  refreshTimer = setInterval(refreshState, 5 * 60 * 1000);
}

window.onHomeyReady = init;
</script>
</body>
</html>
