<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<style>
/* ═══════ BASE ═══════ */
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#0a1628;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;color:#e0e8f0;-webkit-tap-highlight-color:transparent;user-select:none;touch-action:none}
#widgetContainer{position:relative;width:100%;height:100%;overflow:hidden}
#loading{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:#0a1628;z-index:100;font-size:14px;color:#6090c0;transition:opacity .3s}
#loading.hidden{opacity:0;pointer-events:none}

/* ═══════ TANK ═══════ */
#tankWrap{position:absolute;inset:0;overflow:hidden}
#tank{display:block;width:100%;height:100%}
#dirtCanvas{position:absolute;inset:0;width:100%;height:100%;pointer-events:none;z-index:12}

/* ═══════ HUD ═══════ */
.coin-display{position:absolute;top:8px;left:10px;display:flex;align-items:center;gap:4px;background:rgba(0,0,0,.45);border-radius:12px;padding:3px 10px 3px 6px;font-size:13px;font-weight:600;z-index:30;cursor:pointer;transition:opacity .2s}
#coinIcon{font-size:14px}
#coinCount{color:#ffd866}
#hudRight{position:absolute;top:8px;right:10px;display:flex;flex-direction:column;gap:4px;z-index:30;transition:opacity .2s}
.hud-muted .coin-display,.hud-muted #hudRight{pointer-events:none;opacity:.3}
.hud-bar{display:flex;align-items:center;gap:4px;background:rgba(0,0,0,.45);border-radius:8px;padding:3px 8px;font-size:10px;cursor:pointer;min-width:80px}
.hud-bar-label{width:10px;text-align:center}
.hud-bar-track{flex:1;height:5px;background:rgba(255,255,255,.12);border-radius:3px;overflow:hidden}
.hud-bar-fill{height:100%;border-radius:3px;transition:width .5s}
.hud-bar-val{font-size:9px;opacity:.7;min-width:22px;text-align:right}

/* ═══════ HUD TOOLTIP ═══════ */
#hudTooltip{position:absolute;background:rgba(10,22,40,.92);border:1px solid rgba(100,160,220,.3);border-radius:10px;padding:8px 12px;z-index:31;opacity:0;pointer-events:none;transform:translateY(-4px);transition:opacity .2s,transform .2s;max-width:200px;font-size:11px}
#hudTooltip.visible{opacity:1;pointer-events:auto;transform:translateY(0)}
#hudTooltipTitle{font-weight:600;margin-bottom:3px;font-size:12px}
#hudTooltipBody{opacity:.75;line-height:1.4}

/* ═══════ FISH BUBBLE ═══════ */
#fishBubble{position:absolute;background:rgba(10,22,40,.94);border:1px solid rgba(100,160,220,.35);border-radius:12px;padding:10px 14px;z-index:21;opacity:0;pointer-events:none;transition:opacity .2s;font-size:11px;min-width:150px;max-width:200px}
#fishBubble.visible{opacity:1;pointer-events:auto}
#fbName{font-weight:700;font-size:13px;margin-bottom:1px}
#fbSpecies{opacity:.6;font-size:10px;margin-bottom:6px}
#fbDetail{line-height:1.5}
.fb-stats{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:3px}
.fb-stat{font-size:10px;background:rgba(255,255,255,.08);padding:1px 6px;border-radius:4px}
.fb-earn{font-size:10px;opacity:.7;margin-bottom:2px}
.fb-warn{color:#ff8866;font-size:10px;font-weight:600;margin-top:2px}
.fb-trait{font-size:9px;opacity:.5;margin-top:1px}
.fb-actions{display:flex;gap:6px;margin-top:6px;padding-top:5px;border-top:1px solid rgba(100,160,220,.15)}
.fb-btn{padding:3px 10px;border-radius:5px;border:none;font-size:10px;font-weight:600;cursor:pointer}
.fb-sell{background:rgba(180,60,60,.5);color:#ffa0a0}
.fb-sell:hover{background:rgba(200,70,70,.6)}

/* ═══════ DECOR CARD ═══════ */
#decorCard{position:absolute;background:rgba(10,22,40,.94);border:1px solid rgba(100,160,220,.3);border-radius:10px;padding:10px 14px;z-index:22;opacity:0;pointer-events:none;transition:opacity .2s;font-size:11px;min-width:140px}
#decorCard.visible{opacity:1;pointer-events:auto}
#dcName{font-weight:600;font-size:12px;margin-bottom:2px}
#dcInfo{opacity:.6;font-size:10px;margin-bottom:6px;line-height:1.4}
#dcActions{display:flex;gap:6px}
#dcActions button{padding:4px 10px;border-radius:5px;border:none;font-size:10px;font-weight:600;cursor:pointer}
.dc-trim{background:rgba(80,160,80,.5);color:#b0ffb0}
.dc-trim:hover{background:rgba(80,160,80,.7)}
.dc-trim:disabled{opacity:.4;cursor:default}
.dc-sell{background:rgba(180,60,60,.5);color:#ffa0a0}
.dc-sell:hover{background:rgba(200,70,70,.6)}
.dc-move{background:rgba(80,120,200,.5);color:#a0c8ff}
.dc-move:hover{background:rgba(90,140,220,.6)}

/* ═══════ TANK NAV ═══════ */
#tankNav{position:absolute;bottom:8px;left:50%;transform:translateX(-50%);display:flex;align-items:center;gap:8px;background:rgba(0,0,0,.5);border-radius:16px;padding:3px 10px;z-index:40;font-size:11px}
#tankNav.hidden{display:none}
#tankNav button{background:none;border:none;color:#e0e8f0;font-size:14px;cursor:pointer;padding:2px 6px;opacity:.7}
#tankNav button:hover{opacity:1}
#tnLabel{font-weight:500;min-width:80px;text-align:center}


/* ═══════ FAB ═══════ */
#fab{position:absolute;bottom:12px;right:12px;width:44px;height:44px;border-radius:50%;background:rgba(40,80,140,.85);border:2px solid rgba(100,160,220,.5);color:#e0e8f0;font-size:20px;display:flex;align-items:center;justify-content:center;cursor:pointer;z-index:65;transition:transform .2s,background .2s;box-shadow:0 2px 8px rgba(0,0,0,.4)}
#fab:hover{background:rgba(50,100,170,.9);transform:scale(1.05)}
#fab.active{background:rgba(60,120,200,.9)}
#fab .fab-line{display:block;width:18px;height:2px;background:#e0e8f0;border-radius:1px;position:absolute;transition:transform .25s,opacity .25s}
#fab .fab-line:nth-child(1){transform:translateY(-5px)}
#fab .fab-line:nth-child(2){transform:translateY(0)}
#fab .fab-line:nth-child(3){transform:translateY(5px)}
#fab.active .fab-line:nth-child(1){transform:rotate(45deg)}
#fab.active .fab-line:nth-child(2){opacity:0;transform:scaleX(0)}
#fab.active .fab-line:nth-child(3){transform:rotate(-45deg)}

/* ═══════ MENU OVERLAY ═══════ */
#menuOverlay{position:absolute;inset:0;background:rgba(5,12,25,.82);z-index:60;display:flex;align-items:center;justify-content:center;opacity:0;pointer-events:none;transition:opacity .2s}
#menuOverlay.visible{opacity:1;pointer-events:auto}
#menuContent{display:flex;flex-direction:column;align-items:center;gap:8px;max-width:280px;width:100%;padding:0 16px}
.menu-page{width:100%}
.menu-title{font-size:13px;font-weight:600;text-align:center;margin-bottom:8px;opacity:.7}
.menu-grid-3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
.menu-btn{display:flex;flex-direction:column;align-items:center;gap:4px;background:rgba(30,60,100,.6);border:1px solid rgba(100,160,220,.25);border-radius:12px;padding:12px 8px;color:#e0e8f0;font-size:11px;font-weight:500;cursor:pointer;transition:background .15s,transform .15s;min-width:0}
.menu-btn:hover{background:rgba(40,80,140,.7);transform:scale(1.03)}
.menu-btn .menu-icon{font-size:20px}
.menu-btn[data-action="help"]{grid-column:span 3;padding:8px 10px;flex-direction:row;justify-content:center;gap:6px;opacity:.7}

/* ═══════ TOOL DOCK ═══════ */
#toolDock{position:absolute;bottom:0;left:0;right:0;background:rgba(10,22,40,.92);border-top:1px solid rgba(100,160,220,.25);z-index:42;padding:8px 12px;display:flex;align-items:center;gap:8px;transform:translateY(100%);transition:transform .25s;border-radius:12px 12px 0 0}
#toolDock.visible{transform:translateY(0)}
#toolDockContent{flex:1;display:flex;align-items:center;gap:8px;overflow-x:auto}
.dock-item{display:flex;flex-direction:column;align-items:center;gap:2px;padding:6px 10px;background:rgba(40,80,140,.4);border:1px solid rgba(100,160,220,.25);border-radius:8px;font-size:10px;cursor:pointer;min-width:56px;white-space:nowrap;transition:background .15s}
.dock-item:hover,.dock-item.active{background:rgba(60,120,200,.5);border-color:rgba(100,160,220,.5)}
.dock-item .dock-qty{font-size:9px;opacity:.6}
#cleanDockLabel{font-size:12px;font-weight:500;}
.dock-close{background:none;border:none;color:#e0e8f0;font-size:18px;cursor:pointer;padding:4px 8px;opacity:.7}
.dock-close:hover{opacity:1}

/* ═══════ PANELS ═══════ */
.panel{position:absolute;inset:0;background:rgba(8,18,35,.95);z-index:70;display:flex;flex-direction:column;opacity:0;pointer-events:none;transform:translateY(8px);transition:opacity .2s,transform .2s}
.panel.visible{opacity:1;pointer-events:auto;transform:translateY(0)}
.panel-header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid rgba(100,160,220,.15);font-weight:600;font-size:14px}
.panel-header button{background:none;border:none;color:#e0e8f0;font-size:18px;cursor:pointer;padding:4px 8px;opacity:.7}
.panel-header button:hover{opacity:1}
.panel-body{flex:1;overflow-y:auto;padding:10px 14px;-webkit-overflow-scrolling:touch}
.panel-section-title{font-size:11px;font-weight:600;text-transform:uppercase;opacity:.5;margin:12px 0 6px;letter-spacing:.5px}
.panel-section-title:first-child{margin-top:0}

/* ═══ Store items ═══ */
.s-item{display:flex;align-items:center;gap:10px;padding:8px;background:rgba(30,60,100,.25);border:1px solid rgba(100,160,220,.12);border-radius:8px;margin-bottom:6px;transition:opacity .2s}
.s-item.locked{opacity:.4}
.s-item.active-tank{border-color:rgba(100,200,140,.5);background:rgba(30,100,60,.2)}
.s-icon{font-size:20px;width:28px;text-align:center;flex-shrink:0}
.s-info{flex:1;min-width:0}
.s-name{font-size:12px;font-weight:500}
.s-desc{font-size:10px;opacity:.6;margin-top:1px}
.buy-btn{padding:4px 10px;border-radius:6px;border:none;font-size:11px;font-weight:600;cursor:pointer;white-space:nowrap;transition:background .15s}
.buy-btn.primary{background:#3070b0;color:#fff}
.buy-btn.primary:hover{background:#4088cc}
.buy-btn:disabled{background:rgba(60,80,100,.3);color:rgba(200,210,220,.4);cursor:default}
.sell-btn{background:rgba(180,60,60,.5);color:#ffa0a0;padding:3px 8px;border-radius:5px;border:none;font-size:10px;cursor:pointer}
.sell-btn:hover{background:rgba(200,70,70,.6)}

/* ═══ Store tabs ═══ */
.store-tabs{display:flex;gap:4px;margin-bottom:10px;flex-wrap:wrap}
.store-tab{padding:4px 10px;border-radius:6px;border:1px solid rgba(100,160,220,.2);background:transparent;color:#e0e8f0;font-size:11px;cursor:pointer;opacity:.6;transition:all .15s}
.store-tab.active{opacity:1;background:rgba(40,80,140,.4);border-color:rgba(100,160,220,.4)}

/* ═══════ TOAST ═══════ */
#toast{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%) scale(.9);background:rgba(10,22,40,.92);border:1px solid rgba(100,160,220,.3);border-radius:12px;padding:10px 18px;z-index:50;font-size:13px;font-weight:500;text-align:center;opacity:0;pointer-events:none;transition:opacity .3s,transform .3s;max-width:80%}
#toast.visible{opacity:1;transform:translate(-50%,-50%) scale(1)}

/* ═══════ FLOAT TEXT ═══════ */
.float-text{position:absolute;font-size:12px;font-weight:700;color:#ffd866;text-shadow:0 1px 3px rgba(0,0,0,.6);pointer-events:none;z-index:20;animation:floatUp 1.5s ease-out forwards}
@keyframes floatUp{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-30px)}}

/* ═══════ SCROLLBAR ═══════ */
.panel-body::-webkit-scrollbar{width:4px}
.panel-body::-webkit-scrollbar-track{background:transparent}
.panel-body::-webkit-scrollbar-thumb{background:rgba(100,160,220,.25);border-radius:2px}

/* ═══════ RESET BUTTON ═══════ */
.reset-btn{display:block;margin:16px auto 0;padding:8px 20px;background:rgba(180,50,50,.5);border:1px solid rgba(200,80,80,.4);border-radius:8px;color:#ffa0a0;font-size:12px;cursor:pointer}
.reset-btn:hover{background:rgba(200,60,60,.6)}

/* ═══════ PIXEL ICONS ═══════ */
.hud-px-icon,.tn-btn{display:inline-flex;align-items:center;justify-content:center}
.menu-icon{display:inline-flex;align-items:center;justify-content:center;font-size:0}
.hud-px-icon img,.menu-icon img,.tn-btn img,#fab img{image-rendering:pixelated;display:block}
</style>
</head>
<body>
<div id="widgetContainer" data-tank="fresh" data-tier="1">
  <div id="loading">Loading aquarium…</div>
  <div id="tankWrap">
    <canvas id="tank"></canvas>
    <canvas id="dirtCanvas"></canvas>

    <!-- HUD -->
    <div class="coin-display" id="coinDisplay">
      <span id="coinIcon" class="hud-px-icon" data-icon="coin"></span>
      <span id="coinCount">0</span>
    </div>
    <div id="hudRight">
      <div id="cleanBar" class="hud-bar">
        <span class="hud-bar-label hud-px-icon" data-icon="broom"></span>
        <div class="hud-bar-track"><div class="hud-bar-fill" id="cleanFill" style="width:100%;background:#4caf88"></div></div>
        <span class="hud-bar-val" id="cleanVal">100%</span>
      </div>
      <div id="hungerBar" class="hud-bar">
        <span class="hud-bar-label hud-px-icon" data-icon="food"></span>
        <div class="hud-bar-track"><div class="hud-bar-fill" id="hungerFill" style="width:100%;background:#e8a040"></div></div>
        <span class="hud-bar-val" id="hungerVal">100%</span>
      </div>
    </div>

    <!-- HUD Tooltip -->
    <div id="hudTooltip">
      <div id="hudTooltipTitle"></div>
      <div id="hudTooltipBody"></div>
    </div>

    <!-- Fish bubble -->
    <div id="fishBubble">
      <div id="fbName"></div>
      <div id="fbSpecies"></div>
      <div id="fbDetail"></div>
      <div id="fbStage"></div>
    </div>

    <!-- Decor card -->
    <div id="decorCard">
      <div id="dcName"></div>
      <div id="dcInfo"></div>
      <div id="dcActions"></div>
    </div>

    <!-- Tank nav -->
    <div id="tankNav" class="hidden">
      <button id="tnPrev" class="tn-btn" data-icon="arrow_l"></button>
      <span id="tnLabel"></span>
      <button id="tnNext" class="tn-btn" data-icon="arrow_r"></button>
    </div>

  </div>

  <!-- FAB -->
  <button id="fab"><span class="fab-line"></span><span class="fab-line"></span><span class="fab-line"></span></button>

  <!-- Menu overlay -->
  <div id="menuOverlay">
    <div id="menuContent">
      <!-- Single flat menu -->
      <div id="menuMain" class="menu-page">
        <div class="menu-title">Menu</div>
        <div id="menuGrid" class="menu-grid-3">
          <button class="menu-btn" data-action="feed"><span class="menu-icon" data-icon="fish"></span>Feed</button>
          <button class="menu-btn" data-action="clean"><span class="menu-icon" data-icon="broom"></span>Clean</button>
          <button class="menu-btn" data-action="laser"><span class="menu-icon" data-icon="laser"></span>Play</button>
          <button class="menu-btn" data-action="store"><span class="menu-icon" data-icon="store"></span>Store</button>
          <button class="menu-btn" data-action="inventory"><span class="menu-icon" data-icon="clipboard"></span>Inventory</button>
          <button class="menu-btn" data-action="tanks"><span class="menu-icon" data-icon="house"></span>Tanks</button>
          <button class="menu-btn" data-action="help"><span class="menu-icon" data-icon="help"></span>Help</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Tool dock -->
  <div id="toolDock">
    <div id="toolDockContent"></div>
    <button class="dock-close">✕</button>
  </div>

  <!-- Panels -->
  <div id="storePanel" class="panel">
    <div class="panel-header"><span>Store</span><span id="storeCap"></span><button data-close="storePanel">✕</button></div>
    <div id="storeList" class="panel-body"></div>
  </div>
  <div id="inventoryPanel" class="panel">
    <div class="panel-header"><span>Fish &amp; Supplies</span><button data-close="inventoryPanel">✕</button></div>
    <div id="inventoryList" class="panel-body"></div>
  </div>
  <div id="tanksPanel" class="panel">
    <div class="panel-header"><span>Tanks</span><button data-close="tanksPanel">✕</button></div>
    <div id="tanksList" class="panel-body"></div>
  </div>
  <div id="helpPanel" class="panel">
    <div class="panel-header"><span>Help</span><button data-close="helpPanel">✕</button></div>
    <div id="helpBody" class="panel-body"></div>
  </div>

  <!-- Toast -->
  <div id="toast"></div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════════════
// Aquarium Widget — Client Renderer (Homey SDK 3)
//
// Hybrid Canvas + DOM:  Canvas for game world, DOM for HUD/menus/panels.
// All game logic lives server-side. Client is a "dumb renderer".
// ═══════════════════════════════════════════════════════════════════════════════

// ═══════ CONSTANTS ═══════

const TANK_TIER_MAP = { fresh: '1', tropical: '2', salt: '3' };
const BIOMES = {
  fresh: {
    bg: ['#48b8d0','#1a6878'], wall: '#145858', substrate: '#c8a868',
    subH: 0.16, bubbleRate: 0.08, label: 'Fresh Starter',
  },
  tropical: {
    bg: ['#30a8c0','#145058'], wall: '#0c4040', substrate: '#a89870',
    subH: 0.14, bubbleRate: 0.12, label: 'Tropical Planted',
  },
  salt: {
    bg: ['#1858a0','#081840'], wall: '#051028', substrate: '#d8c8a8',
    subH: 0.13, bubbleRate: 0.16, label: 'Saltwater Reef',
  },
};

const FISH_SPRITES = {
  // ── FRESH TANK ──
  // Guppy: tiny body with large colorful fan-shaped tail (12×7)
  guppy: { w:12, h:7, data:['000020000000','002134200000','021345530000','213355533000','021345530000','002134200000','000020000000'] },
  // Goldfish: compact round body with flowing tail, prominent eye (12×8)
  goldfish: { w:12, h:8, data:['000022000000','000213100000','002134510000','021345510000','221335510000','021345100000','002133100000','000221000000'] },
  // Snail: rounded spiral shell, soft body underneath, delicate antennae (10×8)
  snail: { w:10, h:8, data:['0000433000','0004344300','0043443400','0434434000','0333330000','0411040100','4100001040','0100000100'] },

  // ── TROPICAL TANK ──
  // Neon Tetra: tiny torpedo, iridescent blue stripe + red tail (10×5)
  neon_tetra: { w:10, h:5, data:['0016650000','1666655100','1663355200','1163310200','0012200000'] },
  // Blue-Eye: small, big reflective eye accent (10×6)
  blue_eye: { w:10, h:6, data:['0011100000','0115351000','1153551000','1153351000','0113310000','0011200000'] },
  // Moon Fish: tall disc body, crescent shape (14×12)
  moon_fish: { w:14, h:12, data:['00000110000000','00001131000000','00011331000000','00113351000000','01113351100000','11133551100000','11133551100000','01113351100000','00113351000000','00011331000000','00001131000000','00000110000000'] },
  // Discus: large round disc, vertical band pattern, red eye (18×14)
  discus: { w:18, h:14, data:['000000011000000000','000000113100000000','000001136100000000','000011363100000000','000113636100000000','001136361100000000','011136636110000000','011136636110000000','001136361100000000','000113636100000000','000011363100000000','000001136100000000','000000113100000000','000000011000000000'] },
  // Pleco: long flat body, wide head, sucker mouth, spot pattern (20×7)
  pleco: { w:20, h:7, data:['00000000000000000000','00011141111141110000','00113434514131411000','01111145111111411110','00113434514131411000','00011141111141110000','00011000110000000000'] },
  // Gourami: oval with elegant long trailing ventral feeler fins (14×11)
  gourami: { w:14, h:11, data:['00002200000000','00021131000000','00211335100000','02211335100000','22113351100000','22113311000000','00211310000000','00021100000000','00001010000000','00000100000000','00000010000000'] },

  // ── SALTWATER TANK ──
  // Clownfish: vivid orange with 3 white bands, rounded body (14×9)
  clownfish: { w:14, h:9, data:['00001100000000','00016161000000','01161636100000','16163161600000','16163116160000','16163161600000','01161636100000','00016161000000','00001100000000'] },
  // Blue Tang: larger oval, yellow tail accent, palette blue body (18×12)
  blue_tang: { w:18, h:12, data:['000000022000000000','000000211300000000','000002113310000000','000021133510000000','000211336310000000','002113366311000000','002113366311000000','000211336310000000','000021133510000000','000002113310000000','000000211300000000','000000022000000000'] },
  // Green Chromis: small oval, solid green-blue, schooling (8×6)
  green_chromis: { w:8, h:6, data:['01113000','11335100','11335510','11335510','01131000','00120000'] },
  // Firefish: elongated, tall first dorsal fin, fiery gradient (16×9)
  firefish: { w:16, h:9, data:['0000004000000000','0000013300000000','0001133351000000','0011333351000000','0113333510000000','0013333510000000','0001133100000000','0000133000000000','0000022000000000'] },
  // Royal Gramma: half purple half yellow, vivid split color (14×9)
  royal_gramma: { w:14, h:9, data:['00002200000000','00064131000000','00641335100000','06641336100000','66613661100000','06641336100000','00641135000000','00064130000000','00002200000000'] },
  // Banggai Cardinalfish: vertical black-white stripes, elongated fins (12×9)
  banggai_cardinal: { w:12, h:9, data:['000320000000','002161100000','021645610000','216456100000','216456100000','021645610000','002161100000','000220000000','000020000000'] },
  // Moray Eel: LONG thin serpentine body, spotted pattern, visible jaw (28×4)
  moray_eel: { w:28, h:4, data:['0000000000000000000000000000','0000111111111111111111100000','0005133413341334133413310000','0000111111111111111111100000'] },
  // Cleaner Shrimp: long antennae, segmented translucent body, red-white (14×8)
  cleaner_shrimp: { w:14, h:8, data:['50000550000050','00001133000000','00013345100000','00113351000000','00013350000000','00011330000000','00100101000000','01000010100000'] },
};

const FISH_PALETTES = {
  guppy:      { 1:'#FF8844', 2:'#FF5522', 3:'#FFCC88', 4:'#AA4400', 5:'#FFDD44' },
  goldfish:   { 1:'#FFB833', 2:'#FF9500', 3:'#FFE088', 4:'#CC7700', 5:'#111' },
  snail:      { 1:'#D4B896', 2:'#B89878', 3:'#8B6B4A', 4:'#A08060', 5:'#111' },
  neon_tetra: { 1:'#C0C8D0', 2:'#FF3333', 3:'#FF5050', 4:'#333', 5:'#111', 6:'#3388FF' },
  blue_eye:   { 1:'#88CCEE', 2:'#5599CC', 3:'#AADDFF', 4:'#336688', 5:'#2266FF' },
  moon_fish:  { 1:'#CCE0CC', 2:'#88BB88', 3:'#E8FFE8', 4:'#668866', 5:'#111' },
  discus:     { 1:'#FF6644', 2:'#DD4422', 3:'#FF8866', 4:'#CC3311', 5:'#111', 6:'#FF4422' },
  pleco:      { 1:'#665544', 2:'#554433', 3:'#887766', 4:'#443322', 5:'#111' },
  gourami:    { 1:'#5599CC', 2:'#3377AA', 3:'#88CCEE', 4:'#224466', 5:'#111' },
  clownfish:  { 1:'#FF6600', 2:'#FF4400', 3:'#FF8833', 4:'#CC4400', 5:'#111', 6:'#FFFFFF' },
  blue_tang:  { 1:'#3355BB', 2:'#FFDD33', 3:'#5577DD', 4:'#223399', 5:'#111', 6:'#FFDD33' },
  green_chromis: { 1:'#55BB77', 2:'#339955', 3:'#88EEBB', 4:'#227744', 5:'#111' },
  firefish:   { 1:'#FF4444', 2:'#FFAA33', 3:'#FFCC44', 4:'#CC2222', 5:'#111' },
  royal_gramma: { 1:'#8833CC', 2:'#7722BB', 3:'#AA55EE', 4:'#5511AA', 5:'#111', 6:'#FFDD33' },
  banggai_cardinal: { 1:'#CCCCCC', 2:'#AAAAAA', 3:'#EEEEEE', 4:'#555', 5:'#111', 6:'#222' },
  moray_eel:  { 1:'#667744', 2:'#556633', 3:'#8B9966', 4:'#445522', 5:'#FFDD33' },
  cleaner_shrimp: { 1:'#EE4444', 2:'#CC2222', 3:'#FFFFFF', 4:'#AA0000', 5:'#FFFFFF' },
};

const DECOR_COLORS = {
  hornwort:'#44AA44', vallisneria:'#3B9944', anubias:'#2D7A2D', moss_ball:'#339933',
  rock_pile:'#888888', driftwood:'#8B6B4A', treasure_chest:'#AA7733',
  java_fern:'#338833', amazon_sword:'#228822', cryptocoryne:'#557744', ludwigia:'#AA5533',
  floating_plants:'#55BB55', mossy_log:'#6B4B2A', hollow_stump:'#5A3A1A',
  anemone:'#FF6688', live_rock:'#999999', brain_coral:'#DD8844',
  staghorn_coral:'#DDAA66', cave:'#555555', sea_fan:'#CC5599',
};

const ZONE_RANGES = { top:[0.08,0.35], middle:[0.25,0.65], bottom:[0.55,0.82], any:[0.15,0.75] };

// Species base display scales — dramatic size differences for realism
const FISH_BASE_SCALES = {
  guppy: 0.85, goldfish: 1.3, snail: 1.0,
  neon_tetra: 0.65, blue_eye: 0.8, moon_fish: 1.7, discus: 2.0, pleco: 1.8, gourami: 1.5,
  clownfish: 1.3, blue_tang: 1.8, green_chromis: 0.65, firefish: 1.2,
  royal_gramma: 1.2, banggai_cardinal: 0.85, moray_eel: 2.8, cleaner_shrimp: 0.9,
};

// ═══════ PIXEL ICON SYSTEM ═══════
// Pre-rendered pixel art icons replace all emojis for consistent style.
// Each icon is a small sprite rendered to a Data URL at init.

const ICON_DATA = {
  coin: { w:7,h:7, pal:{1:'#b8860b',2:'#daa520',3:'#ffd700',4:'#ffe566'},
    d:['0011100','0233320','1344431','1344431','1344431','0233320','0011100'] },
  broom: { w:7,h:7, pal:{1:'#8B7355',2:'#A0522D',3:'#D2B48C',4:'#90EE90'},
    d:['0004000','0004000','0034000','0134000','0113000','1113000','0110000'] },
  food: { w:7,h:7, pal:{1:'#888',2:'#aaa',3:'#ccc',4:'#ddd'},
    d:['0000000','0333300','3444430','3444430','3444430','0222200','0000000'] },
  fish: { w:9,h:5, pal:{1:'#4488cc',2:'#66aaee',3:'#88ccff',4:'#224466',5:'#111'},
    d:['001110000','012234000','123345100','012234000','001110000'] },
  store: { w:7,h:7, pal:{1:'#666',2:'#888',3:'#aaa',4:'#ccc'},
    d:['1100011','0100010','0222220','0344430','0344430','0344430','0222220'] },
  wrench: { w:7,h:7, pal:{1:'#708090',2:'#a0b0c0',3:'#c0d0e0',4:'#506070'},
    d:['0002200','0012300','0012300','0011000','0011000','0011000','0001000'] },
  clipboard: { w:7,h:7, pal:{1:'#8B7355',2:'#D2B48C',3:'#FFF8DC',4:'#888'},
    d:['0111100','1233310','1233310','1244410','1233310','1233310','0111100'] },
  house: { w:7,h:7, pal:{1:'#4682B4',2:'#6495ED',3:'#87CEEB',4:'#ADD8E6'},
    d:['0001000','0012100','0123210','1234321','0123210','0123210','0111110'] },
  help: { w:7,h:7, pal:{1:'#5599dd',2:'#77bbff',3:'#99ddff',4:'#fff'},
    d:['0111100','1222210','0002210','0022100','0022100','0000000','0022100'] },
  laser: { w:7,h:7, pal:{1:'#800',2:'#c00',3:'#f44',4:'#f88'},
    d:['0001000','0012100','0123210','1234321','0123210','0012100','0001000'] },
  close: { w:5,h:5, pal:{1:'#999',2:'#ccc'},
    d:['10001','02020','00200','02020','10001'] },
  menu: { w:7,h:5, pal:{1:'#ccc',2:'#fff'},
    d:['1111111','0000000','1111111','0000000','1111111'] },
  lock: { w:7,h:7, pal:{1:'#888',2:'#aaa',3:'#daa520',4:'#ffd700'},
    d:['0022200','0211200','0200200','0344430','0344430','0344430','0333300'] },
  arrow_l: { w:5,h:7, pal:{1:'#aaa',2:'#ddd'},
    d:['00010','00110','01210','12210','01210','00110','00010'] },
  arrow_r: { w:5,h:7, pal:{1:'#aaa',2:'#ddd'},
    d:['01000','01100','01210','01221','01210','01100','01000'] },
  plant: { w:5,h:7, pal:{1:'#2d6b2d',2:'#3a8a3a',3:'#5cb85c',4:'#8fd88f'},
    d:['00300','03430','34340','03430','00200','00100','00100'] },
  decor: { w:7,h:5, pal:{1:'#666',2:'#888',3:'#aaa',4:'#ccc'},
    d:['0023200','0234320','2344432','1233321','1111111'] },
  heater: { w:5,h:9, pal:{1:'#aa3333',2:'#cc4444',3:'#ff6666',4:'#ffaa88'},
    d:['01110','12221','12321','12321','12321','12321','12321','12221','01110'] },
  filter: { w:7,h:9, pal:{1:'#556677',2:'#778899',3:'#99aabb',4:'#88bbff'},
    d:['0111110','1222221','1234321','1222221','1234321','1222221','1234321','1222221','0111110'] },
  skimmer: { w:5,h:9, pal:{1:'#999',2:'#bbb',3:'#ddd',4:'#fff'},
    d:['01110','12221','13331','12221','12221','12221','13331','12221','01110'] },
  uv: { w:5,h:9, pal:{1:'#6633cc',2:'#8855ee',3:'#aa77ff',4:'#ddbbff'},
    d:['01110','12221','12321','13431','14341','13431','12321','12221','01110'] },
};

const iconCache = {};

function renderPixelIcon(key, scale) {
  const cacheKey = key + '_' + scale;
  if (iconCache[cacheKey]) return iconCache[cacheKey];
  const ic = ICON_DATA[key];
  if (!ic) return '';
  const c = document.createElement('canvas');
  c.width = ic.w * scale; c.height = ic.h * scale;
  const cx = c.getContext('2d');
  cx.imageSmoothingEnabled = false;
  for (let y = 0; y < ic.h; y++) {
    for (let x = 0; x < ic.w; x++) {
      const ch = ic.d[y][x];
      if (ch === '0') continue;
      cx.fillStyle = ic.pal[ch] || '#888';
      cx.fillRect(x * scale, y * scale, scale, scale);
    }
  }
  const url = c.toDataURL();
  iconCache[cacheKey] = url;
  return url;
}

function iconImg(key, size) {
  const s = size || 16;
  const scale = Math.max(2, Math.round(s / 7));
  return `<img src="${renderPixelIcon(key, scale)}" width="${s}" height="${s}" style="image-rendering:pixelated;vertical-align:middle" alt="">`;
}

// ═══════ STATE ═══════

let W = 400, H = 300, DPR = 1, PX_SCALE = 3;
let gameState = null;
let tankCat = null;
let storeData = null;
let tanksList = null;
let activeTankId = 'fresh';

// Animation state per fish
let fishAnims = {};
// Schooling anchors per species
let schoolAnchors = {};

// Claimed decor zones for territorial fish (rebuilt every updateFishAnim call)
let claimedDecorZones = [];
// Particles
let bubbles = [];
let foodParticles = [];
// Sprite cache
let spriteCache = {};
// UI state
let activeMode = null; // 'feed' | 'clean' | 'laser' | null
let selectedFoodId = null;
let activePanel = null;
let menuOpen = false;
let storeTab = 'fish';
// Cleaning state
let cleanMask = null;
let cleanGridW = 64, cleanGridH = 48;
// Laser state
let laserPos = null;
let laserStartTime = 0;
// Tooltip
let tooltipTimer = null;
let selectedFishId = null; // only this fish shows level badge
let selectedFishTimer = null;
// Decor dragging state
let draggingDecor = null; // { id, decorId, startX, startY }
let isDragging = false; // pointer drag state for decor movement
// Game time
let lastFrameTime = 0;
let refreshTimer = null;

// ═══════ DOM REFS ═══════

const $ = id => document.getElementById(id);
const canvas = $('tank');
const ctx = canvas.getContext('2d');
const dirtCanvas = $('dirtCanvas');
const dirtCtx = dirtCanvas.getContext('2d');

// ═══════ API LAYER ═══════

const API = {
  widgetId: 'default',
  async init() {
    try { this.widgetId = await Homey.getWidgetInstanceId(); } catch(e) { /* sandbox fallback */ }
  },
  async getState() {
    return Homey.api('GET', `/?widgetId=${encodeURIComponent(this.widgetId)}`);
  },
  async doAction(type, payload) {
    return Homey.api('POST', `/?widgetId=${encodeURIComponent(this.widgetId)}`, { type, payload: payload || {} });
  },
};

// ═══════ SPRITE PRE-RENDERING ═══════

function buildSpriteCache() {
  spriteCache = {};
  for (const [key, sp] of Object.entries(FISH_SPRITES)) {
    const pal = FISH_PALETTES[key];
    if (!pal) continue;
    spriteCache[key] = {
      right: renderSprite(sp, pal, PX_SCALE, false),
      left: renderSprite(sp, pal, PX_SCALE, true),
    };
  }
}

function renderSprite(sp, palette, scale, flip) {
  const c = document.createElement('canvas');
  c.width = sp.w * scale;
  c.height = sp.h * scale;
  const cx = c.getContext('2d');
  cx.imageSmoothingEnabled = false;
  for (let y = 0; y < sp.h; y++) {
    const row = sp.data[y];
    for (let x = 0; x < sp.w; x++) {
      const ch = row[x];
      if (ch === '0') continue;
      const color = palette[ch];
      if (!color) continue;
      cx.fillStyle = color;
      const dx = flip ? (sp.w - 1 - x) * scale : x * scale;
      cx.fillRect(dx, y * scale, scale, scale);
    }
  }
  return c;
}

// ═══════ RENDERING — ENVIRONMENT ═══════

function renderEnvironment(biomeKey) {
  const b = BIOMES[biomeKey] || BIOMES.fresh;

  // Water gradient — deeper color transition
  const grad = ctx.createLinearGradient(0, 0, 0, H);
  grad.addColorStop(0, b.bg[0]);
  grad.addColorStop(0.5, b.bg[1]);
  grad.addColorStop(1, shadeColor(b.bg[1], -15));
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, W, H);

  // Underwater light rays from surface — reaching the bottom
  const time = Date.now() / 3000;
  ctx.globalAlpha = 0.03;
  ctx.fillStyle = '#ffffff';
  for (let i = 0; i < 7; i++) {
    const rayX = ((time * 12 + i * 65) % (W + 60)) - 30;
    const rayW = 8 + Math.sin(time + i) * 4;
    ctx.beginPath();
    ctx.moveTo(rayX - rayW, 0);
    ctx.lineTo(rayX + rayW, 0);
    ctx.lineTo(rayX + rayW * 3, H * 0.95);
    ctx.lineTo(rayX - rayW * 2, H * 0.95);
    ctx.closePath();
    ctx.fill();
  }

  // Caustic light patterns — animated dappled light
  ctx.globalAlpha = 0.025;
  for (let i = 0; i < 12; i++) {
    const cx = Math.sin(time * 0.4 + i * 2.1) * W * 0.4 + W * 0.5;
    const cy = Math.cos(time * 0.3 + i * 1.7) * H * 0.2 + H * 0.25;
    const r = 15 + Math.sin(time * 0.8 + i) * 8;
    ctx.beginPath();
    ctx.ellipse(cx, cy, r, r * 0.6, time * 0.1 + i, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  // Substrate — multi-layer for depth
  const subY = H * (1 - b.subH);
  // Dark substrate base
  ctx.fillStyle = shadeColor(b.substrate, -20);
  ctx.fillRect(0, subY, W, H - subY);
  // Lighter top layer
  const subGrad = ctx.createLinearGradient(0, subY, 0, H);
  subGrad.addColorStop(0, b.substrate);
  subGrad.addColorStop(0.3, shadeColor(b.substrate, -10));
  subGrad.addColorStop(1, shadeColor(b.substrate, -25));
  ctx.fillStyle = subGrad;
  ctx.fillRect(0, subY, W, H - subY);

  // Substrate pebble texture — varied sizes and colors
  const rng = seededRng(42);
  for (let i = 0; i < 120; i++) {
    const gx = rng() * W;
    const gy = subY + 2 + rng() * (H - subY - 4);
    const shade = ((rng() - 0.5) * 40) | 0;
    ctx.fillStyle = shadeColor(b.substrate, shade);
    const pw = 1 + rng() * 3.5;
    const ph = 0.8 + rng() * 1.5;
    ctx.fillRect(gx, gy, pw, ph);
  }
  // Substrate highlight line — softer
  ctx.fillStyle = 'rgba(255,255,255,.08)';
  ctx.fillRect(0, subY, W, 1.5);
  ctx.fillStyle = 'rgba(255,255,255,.03)';
  ctx.fillRect(0, subY + 1.5, W, 1);

  // Water surface — animated wave line with ripples and refraction
  // Wave line
  ctx.save();
  ctx.beginPath();
  ctx.moveTo(0, 0);
  for (let x = 0; x <= W; x += 2) {
    const y = 5 + Math.sin(x * 0.04 + time * 2.5) * 2.2 + Math.sin(x * 0.08 + time * 1.3) * 1.0;
    ctx.lineTo(x, y);
  }
  ctx.lineTo(W, 0);
  ctx.closePath();
  // Light refraction above water line
  ctx.fillStyle = 'rgba(180,220,255,0.12)';
  ctx.fill();

  // Surface highlight shimmer
  ctx.globalAlpha = 0.10;
  ctx.fillStyle = '#ffffff';
  for (let i = 0; i < 12; i++) {
    const sx = Math.sin(time * 0.8 + i * 1.2) * 25 + i * (W / 12);
    const sw = 18 + Math.sin(time * 1.2 + i) * 10;
    const sy = 1.5 + Math.sin(sx * 0.04 + time * 2.5) * 1.8;
    ctx.fillRect(sx, sy, sw, 2);
    ctx.globalAlpha = 0.05;
    ctx.fillRect(sx + 3, sy + 2, sw * 0.7, 1.5);
    ctx.globalAlpha = 0.10;
  }
  // Subtle blue underside of surface
  ctx.globalAlpha = 0.04;
  ctx.fillStyle = '#88ccff';
  for (let x = 0; x < W; x += 3) {
    const y = 3 + Math.sin(x * 0.04 + time * 2.5) * 1.8;
    ctx.fillRect(x, y, 3, 3 + Math.sin(x * 0.1 + time) * 2);
  }
  ctx.restore();
  ctx.globalAlpha = 1;

  // Depth fog near bottom — subtle dark gradient at bottom
  const fogGrad = ctx.createLinearGradient(0, subY - 20, 0, subY);
  fogGrad.addColorStop(0, 'rgba(0,0,0,0)');
  fogGrad.addColorStop(1, 'rgba(0,0,0,.06)');
  ctx.fillStyle = fogGrad;
  ctx.fillRect(0, subY - 20, W, 20);

  // Glass frame — subtle edge borders with inner reflection
  ctx.strokeStyle = 'rgba(150,200,255,.06)';
  ctx.lineWidth = 2;
  ctx.strokeRect(1, 1, W - 2, H - 2);
  // Inner glass reflection strips — animated subtle shimmer
  const reflAlpha = 0.02 + Math.sin(time * 0.5) * 0.01;
  ctx.fillStyle = `rgba(150,200,255,${reflAlpha})`;
  ctx.fillRect(0, 0, 4, H);
  ctx.fillRect(W - 4, 0, 4, H);
  // Top reflection
  ctx.fillStyle = 'rgba(200,230,255,.04)';
  ctx.fillRect(0, 0, W, 3);
}

// ═══════ RENDERING — DECOR (Layered: back decor → fish → front decor) ═══════

// Draw BACK layer decor (fish swim in front of these)
function renderDecorBack(decors, biomeKey) {
  if (!decors || !tankCat) return;
  const biome = BIOMES[biomeKey] || BIOMES.fresh;
  const subY = H * (1 - biome.subH);
  // Back layer: large plants, corals — rendered at 60% opacity for depth
  for (const d of decors) {
    const def = tankCat.content?.decor?.[d.decorId];
    if (!def) continue;
    if (def.placement === 'top') continue; // floating always in front
    const color = DECOR_COLORS[d.decorId] || '#888';
    const x = d.x * W;
    const baseSize = Math.max(16, (d.size || 1) * PX_SCALE * 10);
    // Only render roughly half the decor in the back (based on index)
    const idx = decors.indexOf(d);
    if (idx % 3 !== 0) continue; // every 3rd decor drawn behind fish
    ctx.globalAlpha = 0.55; // faded depth effect
    drawDecorItem(d, def, color, x, baseSize, subY, biomeKey, true);
    ctx.globalAlpha = 1;
  }
}

// Draw FRONT layer decor (in front of fish)
function renderDecorFront(decors, biomeKey) {
  if (!decors || !tankCat) return;
  const biome = BIOMES[biomeKey] || BIOMES.fresh;
  const subY = H * (1 - biome.subH);
  for (const d of decors) {
    const def = tankCat.content?.decor?.[d.decorId];
    if (!def) continue;
    const color = DECOR_COLORS[d.decorId] || '#888';
    const x = d.x * W;
    const baseSize = Math.max(16, (d.size || 1) * PX_SCALE * 10);
    const idx = decors.indexOf(d);
    if (idx % 3 === 0) continue; // skip back-layer items
    drawDecorItem(d, def, color, x, baseSize, subY, biomeKey, false);
  }
}

function drawDecorItem(d, def, color, x, baseSize, subY, biomeKey, isBack) {
  if (def.placement === 'top') {
    // ── Floating plants: lush lily-pad clusters at surface ──
    const time = Date.now() / 4000;
    const driftX = Math.sin(time + d.x * 10) * 4;
    const driftY = Math.sin(time * 0.7 + d.x * 7) * 2;
    ctx.save();
    const rng = seededRng(Math.round(d.x * 10000));
    const clusterSize = 4 + Math.floor(rng() * 3); // 4-6 pads per cluster
    for (let i = 0; i < clusterSize; i++) {
      const ox = x + driftX + (rng() - 0.5) * baseSize * 1.3;
      const r = baseSize * (0.25 + rng() * 0.35);
      // Main pad
      const padShade = ((rng() - 0.5) * 20) | 0;
      ctx.fillStyle = shadeColor(color, padShade);
      ctx.globalAlpha = isBack ? 0.5 : 0.88;
      ctx.beginPath();
      ctx.ellipse(ox, 4 + driftY + rng() * 8, r, r * 0.45, rng() * 0.3, 0, Math.PI * 2);
      ctx.fill();
      // Leaf vein
      ctx.strokeStyle = shadeColor(color, -15);
      ctx.lineWidth = 0.6;
      ctx.beginPath();
      ctx.moveTo(ox - r * 0.5, 4 + driftY + rng() * 4);
      ctx.lineTo(ox + r * 0.4, 4 + driftY + rng() * 4);
      ctx.stroke();
      // Highlight spot
      ctx.fillStyle = shadeColor(color, 35);
      ctx.globalAlpha = isBack ? 0.2 : 0.4;
      ctx.beginPath();
      ctx.ellipse(ox - r * 0.2, 2 + driftY + rng() * 4, r * 0.3, r * 0.15, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    // Roots dangling down into water — lush with branching
    ctx.globalAlpha = isBack ? 0.15 : 0.25;
    ctx.strokeStyle = shadeColor(color, -30);
    ctx.lineWidth = 1;
    const rootRng = seededRng(Math.round(d.x * 10000) + 42);
    for (let r = 0; r < 7; r++) {
      const rx = x + driftX + (rootRng() - 0.5) * baseSize * 1.0;
      const rootLen = 18 + rootRng() * 35;
      ctx.lineWidth = 0.6 + rootRng() * 0.8;
      ctx.beginPath();
      ctx.moveTo(rx, 10 + driftY);
      const cp1x = rx + (rootRng()-0.5)*10;
      const cp1y = 10 + rootLen*0.4;
      const endx = rx + (rootRng()-0.5)*6;
      const endy = 10 + rootLen;
      ctx.quadraticCurveTo(cp1x, cp1y, endx, endy);
      ctx.stroke();
      // Sub-roots branching off
      if (rootRng() > 0.35) {
        const brX = cp1x + (rootRng()-0.5)*8;
        const brY = cp1y + rootRng()*12;
        ctx.lineWidth = 0.4;
        ctx.beginPath();
        ctx.moveTo(cp1x, cp1y);
        ctx.lineTo(brX, brY);
        ctx.stroke();
      }
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  } else if (def.growth) {
    // ── Plants: lush, tall, multi-stem with dense leaves ──
    // Flow sway from filter equipment
    const flowStrength = tankCat?._computed?.flow || 0;
    const flowTime = Date.now() / 2000;
    const flowSway = flowStrength * Math.sin(flowTime + d.x * 6) * 8;

    const ph = baseSize * 2.5; // taller plants
    const baseY = subY;
    const topY = baseY - ph;
    const rng = seededRng(Math.round(d.x * 10000) + 99);

    // Plant type specific rendering
    const isVallisneria = d.decorId === 'vallisneria';
    const isAnubias = d.decorId === 'anubias';
    const isCryptocoryne = d.decorId === 'cryptocoryne';
    const isLudwigia = d.decorId === 'ludwigia';

    // Multiple stems for fullness
    const stemCount = isVallisneria ? (4 + Math.floor(rng() * 3)) : isAnubias ? 2 : (2 + Math.floor(rng() * 3));
    for (let s = 0; s < stemCount; s++) {
      const sx = x + (rng() - 0.5) * baseSize * 0.6;
      const curveCp = sx + (rng() - 0.5) * 20 + flowSway * 0.5;
      const topX = sx + (rng() - 0.5) * 10 + flowSway;
      const stemTopY = topY + rng() * ph * 0.25;
      // Stem
      ctx.strokeStyle = shadeColor(color, -25);
      ctx.lineWidth = isVallisneria ? 1.5 : 2.5;
      ctx.beginPath();
      ctx.moveTo(sx, baseY);
      ctx.quadraticCurveTo(curveCp, baseY - ph * 0.5, topX, stemTopY);
      ctx.stroke();

      // Dense leaves along stem
      const leafCount = isVallisneria ? (10 + Math.floor(rng() * 4)) :
                        isAnubias ? (3 + Math.floor(rng() * 2)) :
                        (6 + Math.floor(rng() * 5));
      for (let i = 0; i < leafCount; i++) {
        const t = (i + 0.3) / leafCount;
        const u = t;
        const ly = baseY * (1-u)*(1-u) + (baseY - ph*0.5) * 2*u*(1-u) + stemTopY * u*u;
        const lx = sx * (1-u)*(1-u) + curveCp * 2*u*(1-u) + topX * u*u;
        const dir = (i % 2 === 0 ? 1 : -1) * (0.8 + rng() * 0.4);
        const shade = ((rng() - 0.5) * 30) | 0;
        ctx.fillStyle = shadeColor(color, shade);
        ctx.globalAlpha = isBack ? 0.5 : 0.9;

        if (isVallisneria) {
          // Long ribbon-like leaves
          const leafW = baseSize * (0.12 + rng() * 0.08) * dir;
          const leafH = baseSize * (0.5 + rng() * 0.3);
          ctx.beginPath();
          ctx.moveTo(lx, ly);
          ctx.quadraticCurveTo(lx + leafW * 2 + flowSway * 0.3, ly - leafH * 0.5, lx + leafW + flowSway * 0.5, ly - leafH);
          ctx.quadraticCurveTo(lx + leafW * 0.5 + flowSway * 0.2, ly - leafH * 0.4, lx, ly);
          ctx.fill();
        } else if (isAnubias) {
          // Broad, round leaves
          const leafW = baseSize * (0.45 + rng() * 0.2) * dir;
          const leafH = baseSize * (0.25 + rng() * 0.15);
          ctx.beginPath();
          ctx.ellipse(lx + leafW * 0.4, ly - leafH * 0.3, Math.abs(leafW) * 0.5, leafH * 0.5, dir * 0.3, 0, Math.PI * 2);
          ctx.fill();
          // Darker vein
          ctx.strokeStyle = shadeColor(color, -15);
          ctx.lineWidth = 0.6;
          ctx.globalAlpha = isBack ? 0.2 : 0.4;
          ctx.beginPath();
          ctx.moveTo(lx, ly);
          ctx.lineTo(lx + leafW * 0.4, ly - leafH * 0.3);
          ctx.stroke();
        } else if (isLudwigia) {
          // Reddish-green leaves, alternating pairs
          const leafW = baseSize * (0.25 + rng() * 0.15) * dir;
          const leafH = baseSize * (0.1 + rng() * 0.08);
          const redTint = t > 0.6 ? 20 : 0; // tops more red
          ctx.fillStyle = shadeColor(color, shade + redTint);
          ctx.beginPath();
          ctx.moveTo(lx, ly);
          ctx.quadraticCurveTo(lx + leafW * 0.8, ly - leafH * 1.2, lx + leafW * 0.5, ly + leafH * 0.3);
          ctx.quadraticCurveTo(lx + leafW * 0.2, ly + leafH * 0.8, lx, ly);
          ctx.fill();
        } else {
          // Default leaf shape (java fern, amazon sword, hornwort, cryptocoryne)
          const leafW = baseSize * (isCryptocoryne ? (0.28 + rng() * 0.18) : (0.35 + rng() * 0.25)) * dir;
          const leafH = baseSize * (0.12 + rng() * 0.08);
          ctx.beginPath();
          ctx.moveTo(lx, ly);
          ctx.quadraticCurveTo(lx + leafW * 0.8, ly - leafH * 1.2, lx + leafW * 0.5, ly + leafH * 0.3);
          ctx.quadraticCurveTo(lx + leafW * 0.2, ly + leafH * 0.8, lx, ly);
          ctx.fill();
          // Leaf vein
          ctx.strokeStyle = shadeColor(color, -12);
          ctx.lineWidth = 0.4;
          ctx.globalAlpha = isBack ? 0.2 : 0.35;
          ctx.beginPath();
          ctx.moveTo(lx, ly);
          ctx.lineTo(lx + leafW * 0.45, ly + leafH * 0.1);
          ctx.stroke();
        }
      }
    }
    ctx.globalAlpha = 1;
  } else {
    // ── Solid decor — larger, more detailed ──
    const dw = baseSize * 1.8;
    const dh = baseSize * 1.2;
    const dy = subY - dh;

    if (d.decorId.includes('rock') || d.decorId === 'live_rock') {
      // Rocky pile: 5-7 overlapping irregular boulders with cracks and moss
      const rng = seededRng(Math.round(d.x * 10000) + 55);
      const rockCount = 5 + Math.floor(rng() * 3);
      for (let r = 0; r < rockCount; r++) {
        const rx = x + (rng() - 0.5) * dw * 0.7;
        const ry = subY - rng() * dh * 0.95 - 2;
        const rw = dw * (0.22 + rng() * 0.32);
        const rh = dh * (0.18 + rng() * 0.28);
        const rot = (rng() - 0.5) * 0.5;
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,.15)';
        ctx.beginPath();
        ctx.ellipse(rx + 2, ry + 3, rw/2 + 1, rh/2 + 1, rot, 0, Math.PI * 2);
        ctx.fill();
        // Rock body — irregular rounded polygon
        const rockShade = ((rng() - 0.5) * 35) | 0;
        ctx.fillStyle = shadeColor(color, rockShade);
        ctx.beginPath();
        const pts = 6 + Math.floor(rng() * 3);
        for (let p = 0; p < pts; p++) {
          const a = (p / pts) * Math.PI * 2 + rot;
          const rr = (p % 2 === 0 ? 1 : 0.85 + rng() * 0.15);
          const px = rx + Math.cos(a) * rw/2 * rr;
          const py = ry + Math.sin(a) * rh/2 * rr;
          if (p === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        // Highlight crescent on top
        ctx.fillStyle = shadeColor(color, 30 + (rng() * 15 | 0));
        ctx.globalAlpha = isBack ? 0.15 : 0.3;
        ctx.beginPath();
        ctx.ellipse(rx - rw*0.1, ry - rh*0.22, rw*0.22, rh*0.1, rot, 0, Math.PI * 2);
        ctx.fill();
        // Crack lines
        ctx.globalAlpha = isBack ? 0.1 : 0.2;
        ctx.strokeStyle = shadeColor(color, -30);
        ctx.lineWidth = 0.4;
        if (rng() > 0.4) {
          ctx.beginPath();
          ctx.moveTo(rx - rw*0.15, ry - rh*0.1);
          ctx.lineTo(rx + rw*0.1, ry + rh*0.15);
          ctx.stroke();
        }
        ctx.globalAlpha = isBack ? 0.55 : 1;
      }
      // Sparse moss/algae on top rocks
      if (d.decorId === 'live_rock') {
        ctx.fillStyle = '#4a8a4a';
        ctx.globalAlpha = isBack ? 0.2 : 0.4;
        const mRng = seededRng(Math.round(d.x * 10000) + 111);
        for (let m = 0; m < 5; m++) {
          const mx = x + (mRng() - 0.5) * dw * 0.5;
          const my = subY - dh * 0.5 - mRng() * dh * 0.4;
          ctx.beginPath();
          ctx.arc(mx, my, 1.5 + mRng() * 2, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = isBack ? 0.55 : 1;
      }
    } else if (d.decorId.includes('coral') || d.decorId === 'anemone' || d.decorId === 'sea_fan') {
      // Coral/anemone: dense branching, swaying tips
      const rng = seededRng(Math.round(d.x * 10000) + 77);
      const isAnemone = d.decorId === 'anemone';
      const flowStrength = tankCat?._computed?.flow || 0;
      // Anemone is much larger for clownfish nesting
      const scaleMult = isAnemone ? 3.5 : 1.0;
      const aDw = dw * scaleMult;
      const aDh = dh * scaleMult;
      const branches = isAnemone ? (12 + Math.floor(rng() * 5)) : (5 + Math.floor(rng() * 4));
      const sway = Math.sin(Date.now() / 2000 + d.x * 5) * (2 + flowStrength * 4);
      // Anemone base/foot
      if (isAnemone) {
        ctx.fillStyle = shadeColor(color, -20);
        ctx.beginPath();
        ctx.ellipse(x, subY - aDh * 0.08, aDw * 0.25, aDh * 0.08, 0, 0, Math.PI * 2);
        ctx.fill();
        // Thick column
        ctx.fillStyle = shadeColor(color, -15);
        ctx.fillRect(x - aDw * 0.08, subY - aDh * 0.35, aDw * 0.16, aDh * 0.28);
      }
      for (let b = 0; b < branches; b++) {
        const bx = x + (rng() - 0.5) * aDw * 0.5;
        const by1 = isAnemone ? subY - aDh * 0.3 : subY;
        const height = aDh * (0.4 + rng() * 0.6);
        const by2 = by1 - height;
        const tipX = bx + (rng() - 0.5) * aDw * 0.3 + sway;
        ctx.strokeStyle = shadeColor(color, ((rng() - 0.5) * 30) | 0);
        ctx.lineWidth = isAnemone ? (3 + rng() * 2.5) : (2.5 + rng() * 2);
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(bx, by1);
        ctx.quadraticCurveTo(bx + (rng()-0.5)*aDw*0.3, (by1+by2)/2, tipX, by2);
        ctx.stroke();
        // Bulbous tip (larger for anemone)
        ctx.fillStyle = shadeColor(color, 25);
        ctx.beginPath();
        const tipR = isAnemone ? (3.5 + rng() * 4) : (2.5 + rng() * 3);
        ctx.arc(tipX, by2, tipR, 0, Math.PI * 2);
        ctx.fill();
        // Sub-tentacles for anemone
        if (isAnemone && rng() > 0.3) {
          const subX = tipX + (rng()-0.5)*12 + sway*0.5;
          const subY2 = by2 - 5 - rng()*12;
          ctx.strokeStyle = shadeColor(color, 15);
          ctx.lineWidth = 1.8;
          ctx.beginPath();
          ctx.moveTo(tipX, by2);
          ctx.lineTo(subX, subY2);
          ctx.stroke();
          ctx.fillStyle = shadeColor(color, 35);
          ctx.beginPath();
          ctx.arc(subX, subY2, 2 + rng() * 1.5, 0, Math.PI*2);
          ctx.fill();
        }
      }
    } else if (d.decorId === 'cave') {
      // Cave: large rocky arch that can house a moray eel
      const caveW = dw * 1.8;
      const caveH = dh * 1.6;
      // Shadow beneath
      ctx.fillStyle = 'rgba(0,0,0,.15)';
      ctx.beginPath();
      ctx.ellipse(x + 3, subY, caveW/2 + 4, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      // Outer rock wall
      ctx.fillStyle = shadeColor(color, -10);
      ctx.beginPath();
      ctx.moveTo(x - caveW/2, subY);
      ctx.quadraticCurveTo(x - caveW/2 - 4, subY - caveH * 0.8, x, subY - caveH);
      ctx.quadraticCurveTo(x + caveW/2 + 4, subY - caveH * 0.8, x + caveW/2, subY);
      ctx.closePath();
      ctx.fill();
      // Rock texture
      const caveRng = seededRng(Math.round(d.x * 10000) + 123);
      for (let r = 0; r < 6; r++) {
        ctx.fillStyle = shadeColor(color, ((caveRng() - 0.5) * 30) | 0);
        const rx = x + (caveRng() - 0.5) * caveW * 0.7;
        const ry = subY - caveH * 0.3 - caveRng() * caveH * 0.5;
        ctx.beginPath();
        ctx.ellipse(rx, ry, 4 + caveRng() * 6, 3 + caveRng() * 4, caveRng(), 0, Math.PI * 2);
        ctx.fill();
      }
      // Dark interior opening (large enough for moray)
      ctx.fillStyle = 'rgba(5,5,15,.75)';
      ctx.beginPath();
      ctx.ellipse(x, subY - caveH * 0.22, caveW * 0.32, caveH * 0.35, 0, Math.PI, 0);
      ctx.closePath();
      ctx.fill();
      // Interior depth gradient
      const caveGrad = ctx.createRadialGradient(x, subY - caveH * 0.25, 2, x, subY - caveH * 0.25, caveW * 0.3);
      caveGrad.addColorStop(0, 'rgba(0,0,0,0.5)');
      caveGrad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = caveGrad;
      ctx.fillRect(x - caveW * 0.4, subY - caveH * 0.5, caveW * 0.8, caveH * 0.4);
      // Highlight on top
      ctx.fillStyle = shadeColor(color, 22);
      ctx.globalAlpha = isBack ? 0.2 : 0.4;
      ctx.beginPath();
      ctx.ellipse(x - caveW*0.08, subY - caveH*0.75, caveW*0.18, caveH*0.08, -0.2, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = isBack ? 0.55 : 1;
    } else if (d.decorId.includes('wood') || d.decorId === 'mossy_log' || d.decorId === 'hollow_stump') {
      // Driftwood/logs: natural gnarled shape with bark texture and branches
      const rng = seededRng(Math.round(d.x * 10000) + 33);
      const woodH = dh * 2.2;
      const woodTop = subY - woodH;
      // Main trunk — thick tapering shape
      const trunkW = dw * 0.14;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x - trunkW, subY - 2);
      ctx.quadraticCurveTo(x - trunkW * 1.8, subY - woodH * 0.5, x - trunkW * 0.6, woodTop + woodH * 0.12);
      ctx.quadraticCurveTo(x, woodTop - 3, x + trunkW * 0.5, woodTop + woodH * 0.1);
      ctx.quadraticCurveTo(x + trunkW * 1.5, subY - woodH * 0.4, x + trunkW, subY);
      ctx.closePath();
      ctx.fill();
      // Bark texture — horizontal grain lines
      ctx.strokeStyle = shadeColor(color, -18);
      ctx.lineWidth = 0.5;
      ctx.globalAlpha = isBack ? 0.2 : 0.45;
      for (let g = 0; g < 7; g++) {
        const gy = subY - woodH * 0.08 - g * woodH * 0.13 + rng() * 4;
        const gxOff = (rng() - 0.5) * 4;
        ctx.beginPath();
        ctx.moveTo(x - trunkW * 0.8 + gxOff, gy);
        ctx.quadraticCurveTo(x + gxOff, gy - 1.5 + rng()*3, x + trunkW * 0.8 + gxOff, gy + rng()*2);
        ctx.stroke();
      }
      // Knots in bark
      ctx.fillStyle = shadeColor(color, -22);
      ctx.globalAlpha = isBack ? 0.2 : 0.35;
      for (let k = 0; k < 2; k++) {
        const kx = x + (rng() - 0.5) * trunkW * 0.8;
        const ky = subY - woodH * 0.2 - rng() * woodH * 0.5;
        ctx.beginPath();
        ctx.ellipse(kx, ky, 2 + rng(), 1.5 + rng(), rng() * 0.5, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = isBack ? 0.55 : 1;
      // Branch extending right — natural curve
      ctx.strokeStyle = shadeColor(color, 5);
      ctx.lineWidth = 2.5 + rng();
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(x + trunkW * 0.3, subY - woodH * 0.55);
      ctx.quadraticCurveTo(x + dw * 0.35, subY - woodH * 0.7, x + dw * 0.6, subY - woodH * 0.58);
      ctx.stroke();
      // Thinner sub-branch
      ctx.lineWidth = 1.2;
      ctx.beginPath();
      ctx.moveTo(x + dw * 0.45, subY - woodH * 0.65);
      ctx.lineTo(x + dw * 0.55, subY - woodH * 0.72);
      ctx.stroke();
      // Branch extending left
      ctx.lineWidth = 2 + rng();
      ctx.beginPath();
      ctx.moveTo(x - trunkW * 0.4, subY - woodH * 0.35);
      ctx.quadraticCurveTo(x - dw * 0.35, subY - woodH * 0.48, x - dw * 0.5, subY - woodH * 0.38);
      ctx.stroke();
      // Highlight edge on left side (light source)
      ctx.fillStyle = shadeColor(color, 22);
      ctx.globalAlpha = isBack ? 0.1 : 0.2;
      ctx.fillRect(x - trunkW * 0.9, subY - woodH * 0.8, 1.2, woodH * 0.6);
      ctx.globalAlpha = isBack ? 0.55 : 1;
      // Moss coating on top
      if (d.decorId === 'mossy_log') {
        const mossRng = seededRng(Math.round(d.x * 10000) + 88);
        ctx.fillStyle = '#3a8a3a';
        ctx.globalAlpha = isBack ? 0.35 : 0.65;
        for (let m = 0; m < 8; m++) {
          const mx = x - dw*0.3 + mossRng() * dw * 0.6;
          const my = dy - 2 + mossRng() * 6;
          ctx.beginPath();
          ctx.arc(mx, my, 2 + mossRng()*3, 0, Math.PI*2);
          ctx.fill();
        }
        ctx.globalAlpha = isBack ? 0.55 : 1;
      }
    } else if (d.decorId === 'moss_ball') {
      // Moss ball: perfectly round, fuzzy green ball
      const radius = baseSize * 0.7;
      const cy = subY - radius;
      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,.1)';
      ctx.beginPath();
      ctx.ellipse(x + 2, subY - 1, radius * 0.9, radius * 0.25, 0, 0, Math.PI * 2);
      ctx.fill();
      // Main sphere shape with gradient
      const mbGrad = ctx.createRadialGradient(x - radius * 0.2, cy - radius * 0.2, 0, x, cy, radius);
      mbGrad.addColorStop(0, shadeColor(color, 25));
      mbGrad.addColorStop(0.6, color);
      mbGrad.addColorStop(1, shadeColor(color, -25));
      ctx.fillStyle = mbGrad;
      ctx.beginPath();
      ctx.arc(x, cy, radius, 0, Math.PI * 2);
      ctx.fill();
      // Fuzzy moss texture dots
      const mbRng = seededRng(Math.round(d.x * 10000) + 66);
      ctx.globalAlpha = isBack ? 0.3 : 0.55;
      for (let m = 0; m < 20; m++) {
        const angle = mbRng() * Math.PI * 2;
        const dist = mbRng() * radius * 0.8;
        const mx = x + Math.cos(angle) * dist;
        const my = cy + Math.sin(angle) * dist;
        ctx.fillStyle = shadeColor(color, ((mbRng() - 0.5) * 35) | 0);
        ctx.beginPath();
        ctx.arc(mx, my, 1 + mbRng() * 2, 0, Math.PI * 2);
        ctx.fill();
      }
      // Highlight
      ctx.fillStyle = 'rgba(255,255,255,0.15)';
      ctx.beginPath();
      ctx.ellipse(x - radius * 0.25, cy - radius * 0.3, radius * 0.3, radius * 0.2, -0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = isBack ? 0.55 : 1;
    } else {
      // Generic (treasure_chest, etc.) — rounder, more prominent
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x - dw/2, subY);
      ctx.quadraticCurveTo(x - dw/2, dy - 2, x - dw*0.1, dy - 6);
      ctx.quadraticCurveTo(x + dw*0.1, dy - 8, x + dw/2, dy);
      ctx.quadraticCurveTo(x + dw/2, subY - 2, x + dw/2, subY);
      ctx.closePath();
      ctx.fill();
      // Shading highlight
      ctx.fillStyle = shadeColor(color, 18);
      ctx.globalAlpha = isBack ? 0.2 : 0.45;
      ctx.beginPath();
      ctx.ellipse(x, dy + dh*0.2, dw*0.25, dh*0.12, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = isBack ? 0.55 : 1;
    }
  }
}

// ═══════ RENDERING — EQUIPMENT ═══════

function renderEquipment(toolsOwned) {
  if (!toolsOwned || !tankCat) return;
  let eqX = W - 10;
  const iconKeys = { heater:'heater', filter_tropical:'filter', filter_salt:'filter', skimmer:'skimmer', uv_sterilizer:'uv' };

  for (const [toolId, level] of Object.entries(toolsOwned)) {
    if (level <= 0) continue;
    const iKey = iconKeys[toolId] || 'filter';
    const ic = ICON_DATA[iKey];
    if (!ic) continue;

    const eqScale = Math.max(2, PX_SCALE - 1);
    const eqW = ic.w * eqScale;
    const eqH = ic.h * eqScale;
    const eqY = 15;

    // Draw equipment pixel art on right wall
    for (let y = 0; y < ic.h; y++) {
      for (let x = 0; x < ic.w; x++) {
        const ch = ic.d[y][x];
        if (ch === '0') continue;
        ctx.fillStyle = ic.pal[ch] || '#888';
        ctx.globalAlpha = 0.85;
        ctx.fillRect(eqX - eqW + x * eqScale, eqY + y * eqScale, eqScale, eqScale);
      }
    }
    ctx.globalAlpha = 1;

    // Level indicator dots
    if (level > 1) {
      for (let i = 0; i < Math.min(level, 5); i++) {
        ctx.fillStyle = '#ffd866';
        ctx.fillRect(eqX - eqW / 2 - (level * 2) + i * 4, eqY + eqH + 3, 2, 2);
      }
    }

    eqX -= eqW + 6;
  }
}

// ═══════ RENDERING — FISH ═══════

function updateFishAnim(fish, dt) {
  // ── Schooling: pick a leader per species, others follow it ──
  const schoolingSpecies = new Map(); // speciesId → [fish instances]
  for (const f of fish) {
    const sp = tankCat?.content?.fish?.[f.speciesId];
    if (sp?.preferences?.schooling) {
      if (!schoolingSpecies.has(f.speciesId)) schoolingSpecies.set(f.speciesId, []);
      schoolingSpecies.get(f.speciesId).push(f);
    }
  }
  // Assign leader (first fish, or keep current leader if alive)
  for (const [sid, members] of schoolingSpecies) {
    if (!schoolAnchors[sid]) {
      const sp = tankCat?.content?.fish?.[sid];
      const zone = ZONE_RANGES[sp?.preferences?.zonePreference || 'middle'] || ZONE_RANGES.middle;
      schoolAnchors[sid] = { leaderId: members[0].id, zone, timer: 0 };
    }
    const anchor = schoolAnchors[sid];
    // Validate leader
    if (!members.find(m => m.id === anchor.leaderId)) {
      anchor.leaderId = members[0].id;
    }
  }
  // Prune stale anchors
  for (const sid of Object.keys(schoolAnchors)) {
    if (!schoolingSpecies.has(sid)) delete schoolAnchors[sid];
  }

  // ── Territorial behavior: find fish near other fish's claimed decor ──
  // Build map of claimed decor positions
  claimedDecorZones = []; // { fishId, x, y, radius, speciesId }
  const tank = gameState?.tanks?.[activeTankId];
  const decors = tank?.decor || [];
  for (const f of fish) {
    const sp = tankCat?.content?.fish?.[f.speciesId];
    const nearDecor = sp?.preferences?.nearDecor;
    if (!nearDecor) continue;
    // Find the decor this fish claims
    const claimed = decors.find(d => d.decorId === nearDecor);
    if (!claimed) continue;
    // Moray and clownfish get tight territory zones
    const isMoray = f.speciesId === 'moray_eel';
    const isClownfish = f.speciesId === 'clownfish';
    const zRadius = isMoray ? 0.05 : isClownfish ? 0.07 : 0.09;
    claimedDecorZones.push({ fishId: f.id, x: claimed.x, y: claimed.y * 0.85, radius: zRadius, speciesId: f.speciesId, decorId: nearDecor, isMoray, isClownfish });
  }

  for (const f of fish) {
    let anim = fishAnims[f.id];
    if (!anim) {
      const sp = tankCat?.content?.fish?.[f.speciesId];
      const zone = sp?.preferences?.zonePreference || 'middle';
      const range = ZONE_RANGES[zone] || ZONE_RANGES.middle;
      const movType = sp?.preferences?.movementType || 'default';
      anim = {
        x: 0.1 + Math.random() * 0.8,
        y: range[0] + Math.random() * (range[1] - range[0]),
        tx: 0.2 + Math.random() * 0.6,
        ty: range[0] + Math.random() * (range[1] - range[0]),
        facing: Math.random() > 0.5 ? 1 : -1,
        phase: Math.random() * Math.PI * 2,
        speed: 0.3 + Math.random() * 0.3,
        sizeVar: 0.9 + Math.random() * 0.2,
        zone: range,
        movementType: movType,
        wiggle: false,
        wiggleTimer: 0,
        dashSpeed: 0, // territorial dash boost
      };
      // Crawl types start on bottom
      if (movType === 'crawl') {
        anim.y = range[1] || 0.82;
        anim.ty = anim.y;
      }
      fishAnims[f.id] = anim;
    }

    // Handle wiggle state — keep wiggling while this fish is selected (bubble open)
    if (anim.wiggle) {
      // Stop wiggle if no longer selected or bubble dismissed
      if (selectedFishId !== f.id || !$('fishBubble').classList.contains('visible')) {
        anim.wiggle = false;
      } else {
        anim.phase += dt * 18; // fast wiggle
        continue; // Don't move while wiggling
      }
    }

    const sp = tankCat?.content?.fish?.[f.speciesId];
    const movType = anim.movementType || 'default';

    // ── Territorial: check if this fish is inside someone else's claimed zone ──
    let beingChased = false;
    for (const zone of claimedDecorZones) {
      if (zone.fishId === f.id) continue; // own zone
      if (zone.speciesId === f.speciesId) continue; // same species OK
      const distToDecor = Math.sqrt((anim.x - zone.x)*(anim.x - zone.x) + (anim.y - zone.y)*(anim.y - zone.y));
      if (distToDecor < zone.radius) {
        // This fish is trespassing! Flee away from the decor
        const fleeAngle = Math.atan2(anim.y - zone.y, anim.x - zone.x);
        anim.tx = Math.max(0.08, Math.min(0.92, anim.x + Math.cos(fleeAngle) * 0.25));
        anim.ty = Math.max(0.08, Math.min(0.85, anim.y + Math.sin(fleeAngle) * 0.15));
        anim.dashSpeed = 3.0; // flee fast
        beingChased = true;
        break;
      }
    }

    // ── Territorial: owner dashes at intruders near its claimed decor ──
    const myNearDecor = sp?.preferences?.nearDecor;
    if (myNearDecor && !beingChased) {
      const myDecor = decors.find(d => d.decorId === myNearDecor);
      if (myDecor) {
        // Check if any other-species fish is near my decor
        let intruder = null;
        let intruderDist = Infinity;
        for (const of2 of fish) {
          if (of2.id === f.id || of2.speciesId === f.speciesId) continue;
          const oa = fishAnims[of2.id];
          if (!oa) continue;
          const d2 = Math.sqrt((oa.x - myDecor.x)*(oa.x - myDecor.x) + (oa.y - myDecor.y*0.85)*(oa.y - myDecor.y*0.85));
          if (d2 < 0.10 && d2 < intruderDist) { intruder = of2; intruderDist = d2; }
        }
        if (intruder) {
          // Dash toward the intruder to chase it away
          const ia = fishAnims[intruder.id];
          if (ia) {
            anim.tx = ia.x;
            anim.ty = ia.y;
            anim.dashSpeed = 2.5;
          }
        } else if (anim.dashSpeed > 0.1) {
          // Return to near decor
          anim.tx = myDecor.x + (Math.random() - 0.5) * 0.08;
          anim.ty = myDecor.y * 0.85 + (Math.random() - 0.5) * 0.06;
          anim.dashSpeed *= 0.92; // slow down return
        }
      }
    }
    // Decay dash speed
    if (anim.dashSpeed > 0) anim.dashSpeed *= (1 - dt * 2);
    if (anim.dashSpeed < 0.05) anim.dashSpeed = 0;

    // Move toward target
    const dx = anim.tx - anim.x;
    const dy = anim.ty - anim.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    // Feed mode: swim toward nearest accepted food
    let chaseTarget = null;
    if (activeMode === 'feed' && foodParticles.length > 0 && f.hunger < 70) {
      const accepts = sp?.diet?.accepts || [];
      let nearest = null, nearDist = Infinity;
      for (const fp of foodParticles) {
        if (!accepts.includes(fp.foodId)) continue;
        const fdx = fp.x / W - anim.x;
        const fdy = fp.y / H - anim.y;
        const fd = Math.sqrt(fdx*fdx + fdy*fdy);
        if (fd < nearDist) { nearDist = fd; nearest = fp; }
      }
      if (nearest && nearDist < 0.4) chaseTarget = { x: nearest.x / W, y: nearest.y / H };
    }
    // Laser mode: chase laser
    if (activeMode === 'laser' && laserPos) {
      if (movType !== 'snake' && movType !== 'crawl') {
        chaseTarget = { x: laserPos.x / W, y: laserPos.y / H };
      }
    }

    if (chaseTarget) {
      anim.tx = chaseTarget.x;
      anim.ty = chaseTarget.y;
    } else if (dist < 0.03) {
      // ── Check if this fish has a tight territory zone (clownfish/moray) ──
      const myZone = claimedDecorZones.find(z => z.fishId === f.id);
      if (myZone && (myZone.isMoray || myZone.isClownfish)) {
        // Stay very close to their decor — tight swimming zone
        const swimRadius = myZone.isMoray ? 0.04 : 0.06;
        const angle = Math.random() * Math.PI * 2;
        const r = Math.random() * swimRadius;
        anim.tx = Math.max(0.06, Math.min(0.94, myZone.x + Math.cos(angle) * r));
        anim.ty = Math.max(0.1, Math.min(0.85, myZone.y + Math.sin(angle) * r * 0.7));
      }
      // ── Movement type: CRAWL (snails, shrimp) ──
      else if (movType === 'crawl') {
        // Stay on substrate bottom, move very slowly left/right
        anim.tx = 0.06 + Math.random() * 0.88;
        anim.ty = anim.zone[1] || 0.82; // stay at bottom of zone
      }
      // ── Movement type: GLASS (pleco) ──
      else if (movType === 'glass') {
        if (!anim._wallSide) anim._wallSide = Math.random() > 0.5 ? 'left' : 'right';
        if (Math.random() < 0.12) anim._wallSide = anim._wallSide === 'left' ? 'right' : 'left';
        anim.tx = anim._wallSide === 'left' ? 0.04 : 0.96;
        anim.ty = 0.15 + Math.random() * 0.65;
      }
      // ── Movement type: SNAKE (moray eel) ──
      else if (movType === 'snake') {
        // Slow undulating movement near bottom/cave
        anim.tx = 0.1 + Math.random() * 0.8;
        anim.ty = Math.max(anim.zone[0], 0.5 + Math.random() * 0.32);
      }
      // ── Schooling fish: follow leader ──
      else if (sp?.preferences?.schooling && schoolAnchors[f.speciesId]) {
        const anchor = schoolAnchors[f.speciesId];
        const leaderAnim = fishAnims[anchor.leaderId];
        if (leaderAnim && f.id !== anchor.leaderId) {
          // Follow leader with offset
          const idx = (schoolingSpecies.get(f.speciesId) || []).indexOf(f);
          const angle = (idx * 1.2) + anim.phase * 0.05;
          const followDist = 0.06 + (idx % 3) * 0.03;
          anim.tx = leaderAnim.x - leaderAnim.facing * followDist + Math.sin(angle) * 0.04;
          anim.ty = leaderAnim.y + Math.cos(angle) * 0.03;
        } else {
          // Leader: normal swimming
          anim.tx = 0.1 + Math.random() * 0.8;
          anim.ty = anim.zone[0] + Math.random() * (anim.zone[1] - anim.zone[0]);
        }
      }
      // ── Default movement ──
      else {
        anim.tx = 0.08 + Math.random() * 0.84;
        anim.ty = anim.zone[0] + Math.random() * (anim.zone[1] - anim.zone[0]);
      }
    }

    // Speed varies by movement type + territorial dash boost
    let baseSpd = (chaseTarget ? 1.5 : 0.6) * anim.speed;
    if (movType === 'crawl') baseSpd *= 0.25; // snails are very slow
    if (movType === 'snake') baseSpd *= 0.5; // eels are moderate
    if (movType === 'glass') baseSpd *= 0.4; // plecos are slow
    baseSpd *= (1 + (anim.dashSpeed || 0)); // territorial dash boost
    const spd = baseSpd * dt;

    anim.x += dx * spd * 2;
    // Snake movement: add sinusoidal vertical oscillation
    const yOsc = movType === 'snake'
      ? Math.sin(anim.phase * 1.5) * 0.001
      : Math.sin(anim.phase) * 0.0003;
    anim.y += dy * spd * 2 + yOsc;
    anim.phase += dt * (movType === 'snake' ? 5 : 3);
    if (Math.abs(dx) > 0.005) anim.facing = dx > 0 ? 1 : -1;

    // Clamp — crawl types hug the bottom
    anim.x = Math.max(0.04, Math.min(0.96, anim.x));
    if (movType === 'crawl') {
      anim.y = Math.max(anim.zone[1] - 0.03, Math.min(anim.zone[1] + 0.02, anim.y));
    } else {
      anim.y = Math.max(0.05, Math.min(0.88, anim.y));
    }
  }
}

function renderFish(fish) {
  // Sort by Y for depth ordering
  const sorted = [...fish].sort((a, b) => {
    const ay = fishAnims[a.id]?.y || 0;
    const by = fishAnims[b.id]?.y || 0;
    return ay - by;
  });

  const biome = BIOMES[activeTankId] || BIOMES.fresh;
  const subY = H * (1 - biome.subH);
  const tank = gameState?.tanks?.[activeTankId];
  const decors = tank?.decor || [];

  for (const f of sorted) {
    const anim = fishAnims[f.id];
    if (!anim) continue;
    const cached = spriteCache[f.speciesId];
    if (!cached) continue;

    const img = anim.facing > 0 ? cached.right : cached.left;
    const baseScale = FISH_BASE_SCALES[f.speciesId] || 1.0;
    const scale = anim.sizeVar * baseScale;
    const drawW = img.width * scale;
    const drawH = img.height * scale;
    const px = anim.x * W - drawW / 2;
    const py = anim.y * H - drawH / 2;
    const movType = anim.movementType || 'default';

    // Weak state: make grey/transparent
    if (f.weak) {
      ctx.globalAlpha = 0.45;
      ctx.filter = 'grayscale(0.8)';
    }

    // Wiggle animation
    if (anim.wiggle) {
      ctx.save();
      const wigAmt = Math.sin(anim.phase) * 3;
      ctx.translate(anim.x * W, anim.y * H);
      ctx.rotate(wigAmt * Math.PI / 180 * 4);
      ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
      ctx.restore();
    }
    // Glass movement (pleco): draw attached to glass wall, oriented vertically
    else if (movType === 'glass' && anim._wallSide) {
      ctx.save();
      const wallX = anim._wallSide === 'left' ? 4 + drawW * 0.3 : W - 4 - drawW * 0.3;
      ctx.translate(wallX, anim.y * H);
      // Head up, body along glass
      const rot = anim._wallSide === 'left' ? -Math.PI / 2 : Math.PI / 2;
      ctx.rotate(rot);
      ctx.scale(anim.facing > 0 ? 1 : -1, 1); // flip for facing
      ctx.drawImage(cached.right, -drawW / 2, -drawH / 2, drawW, drawH);
      ctx.restore();
    }
    // Snake movement: sinusoidal body undulation + cave hiding
    else if (movType === 'snake') {
      ctx.save();
      const myDecorZone = claimedDecorZones?.find(z => z.fishId === f.id && z.isMoray);
      ctx.translate(anim.x * W, anim.y * H);
      const undulate = Math.sin(anim.phase * 1.5) * 2;
      ctx.rotate(undulate * Math.PI / 180);

      if (myDecorZone) {
        const caveDecor = decors.find(d => d.decorId === 'cave');
        if (caveDecor) {
          const cdx = anim.x - caveDecor.x;
          const caveDist = Math.abs(cdx);
          if (caveDist < 0.08) {
            // Moray is inside cave — clip to show only the head poking out from the dark opening
            // The cave opening is the dark ellipse at the bottom part of the cave
            const caveX = caveDecor.x * W - anim.x * W; // relative to moray center
            const caveBaseY = (subY - anim.y * H);
            // Only draw the front portion emerging from cave darkness
            const visiblePortion = Math.max(0.25, 0.25 + caveDist * 8);
            const headSide = anim.facing > 0 ? 1 : -1;
            const srcW = Math.floor(img.width * visiblePortion);
            const dstW = drawW * visiblePortion;
            // Show the head end emerging
            if (anim.facing > 0) {
              // facing right — head is on right, show right portion
              ctx.drawImage(img, img.width - srcW, 0, srcW, img.height,
                drawW / 2 - dstW, -drawH / 2, dstW, drawH);
            } else {
              // facing left — head is on left, show left portion
              ctx.drawImage(img, 0, 0, srcW, img.height,
                -drawW / 2, -drawH / 2, dstW, drawH);
            }
          } else {
            ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
          }
        } else {
          ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
        }
      } else {
        ctx.drawImage(img, -drawW / 2, -drawH / 2, drawW, drawH);
      }
      ctx.restore();
    }
    // Crawl movement (snails, shrimp): on substrate
    else if (movType === 'crawl') {
      // Draw on top of substrate
      const crawlY = subY - drawH * 0.6;
      ctx.drawImage(img, anim.x * W - drawW / 2, crawlY, drawW, drawH);
    }
    // Default swim
    else {
      // Clownfish near anemone: partially obscured by tentacles (lower opacity)
      if (f.speciesId === 'clownfish') {
        const myZone = claimedDecorZones?.find(z => z.fishId === f.id && z.isClownfish);
        if (myZone) {
          const distToDecor = Math.sqrt((anim.x - myZone.x) ** 2 + (anim.y - myZone.y) ** 2);
          if (distToDecor < 0.05) {
            ctx.globalAlpha = Math.max(0.55, ctx.globalAlpha * (0.6 + distToDecor * 8));
          }
        }
      }
      ctx.drawImage(img, px, py, drawW, drawH);
      ctx.globalAlpha = f.weak ? 0.45 : 1;
    }

    if (f.weak) {
      ctx.globalAlpha = 1;
      ctx.filter = 'none';
    }

    // Level badge — only show for selected (tapped) fish while bubble is visible
    if (f.level > 1 && f.id === selectedFishId && $('fishBubble').classList.contains('visible')) {
      const badgeX = (movType === 'crawl') ? anim.x * W + drawW / 2 - 12 : px + drawW - 12;
      const badgeY = (movType === 'crawl') ? subY - drawH * 0.6 - 2 : py - 2;
      ctx.fillStyle = 'rgba(0,0,0,.6)';
      ctx.fillRect(badgeX, badgeY, 16, 11);
      ctx.fillStyle = '#ffd866';
      ctx.font = 'bold 9px sans-serif';
      ctx.fillText('L' + f.level, badgeX + 1, badgeY + 8);
    }
  }
}

// ═══════ FOOD PARTICLES ═══════

function updateFoodParticles(dt) {
  const fish = gameState?.tanks?.[activeTankId]?.fish || [];
  for (let i = foodParticles.length - 1; i >= 0; i--) {
    const fp = foodParticles[i];
    const sinkSpeed = fp.sink === 'slowSink' ? 25 : fp.sink === 'sink' ? 60 : 5;
    fp.y += sinkSpeed * dt;
    fp.x += Math.sin(fp.phase) * 8 * dt;
    fp.phase += dt * 2;
    fp.life -= dt;

    // Check fish contact
    let eaten = false;
    for (const f of fish) {
      const anim = fishAnims[f.id];
      if (!anim) continue;
      const sp = tankCat?.content?.fish?.[f.speciesId];
      if (!sp) continue;
      // Only eat food the fish accepts AND only when hungry
      if (!sp.diet.accepts.includes(fp.foodId)) continue;
      if (f.hunger >= 95) continue; // already full — ignore
      const fdx = fp.x - anim.x * W;
      const fdy = fp.y - anim.y * H;
      if (Math.sqrt(fdx*fdx + fdy*fdy) < 18) {
        // Keep fish at current position so it doesn't snap back
        anim.tx = anim.x;
        anim.ty = anim.y;
        API.doAction('fish_consume', { fishId: f.id, foodId: fp.foodId }).then(refreshState);
        showFloatText(fp.x, fp.y, '+fed');
        eaten = true;
        break;
      }
    }

    if (eaten || fp.life <= 0 || fp.y > H) {
      foodParticles.splice(i, 1);
    }
  }
}

function renderFoodParticles() {
  for (const fp of foodParticles) {
    ctx.fillStyle = '#e8c870';
    ctx.beginPath();
    ctx.arc(fp.x, fp.y, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#ffd866';
    ctx.beginPath();
    ctx.arc(fp.x, fp.y, 1.5, 0, Math.PI * 2);
    ctx.fill();
  }
}

// ═══════ BUBBLES ═══════

function updateBubbles(dt, biomeKey) {
  const b = BIOMES[biomeKey] || BIOMES.fresh;
  // Spawn
  if (Math.random() < b.bubbleRate * dt * 10) {
    bubbles.push({
      x: 10 + Math.random() * (W - 20),
      y: H * 0.85 + Math.random() * H * 0.1,
      r: 1 + Math.random() * 2.5,
      speed: 15 + Math.random() * 25,
      phase: Math.random() * Math.PI * 2,
    });
  }
  for (let i = bubbles.length - 1; i >= 0; i--) {
    const b = bubbles[i];
    b.y -= b.speed * dt;
    b.x += Math.sin(b.phase + b.y * 0.05) * 0.3;
    if (b.y < -5) bubbles.splice(i, 1);
  }
}

function renderBubbles() {
  ctx.fillStyle = 'rgba(200,230,255,.2)';
  ctx.strokeStyle = 'rgba(200,230,255,.15)';
  ctx.lineWidth = 0.5;
  for (const b of bubbles) {
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.stroke();
  }
}

// ═══════ DIRT & CLEANING ═══════

function initCleanMask(seed, gridW, gridH, dirtPercent) {
  cleanSeed = seed;
  cleanGridW = gridW; cleanGridH = gridH;
  cleanDirtyStart = dirtPercent;
  // Use same seed that produces the normal dirt overlay pattern so the
  // clean-mode mask looks identical to the dirt that was already visible.
  const rng = seededRng(activeTankId.length * 1000 + 7);
  cleanMask = [];
  // Pre-sample the same RNG sequence used by the normal overlay (12×10 grid)
  // to compute which coarse cells had dirt, then map to the finer clean grid.
  const coarseCols = 12, coarseRows = 10;
  const coarseDirty = [];
  for (let cy = 0; cy < coarseRows; cy++) {
    for (let cx = 0; cx < coarseCols; cx++) {
      const show = rng() <= dirtPercent * 1.5;
      // consume rest of rng calls that renderDirtOverlay does
      rng(); rng(); rng(); rng(); rng();
      coarseDirty.push(show);
    }
  }
  // Build fine grid from coarse dirt map
  const fineRng = seededRng(seed);
  for (let cy = 0; cy < gridH; cy++) {
    for (let cx = 0; cx < gridW; cx++) {
      // Map fine cell to coarse cell
      const ccx = Math.floor(cx / gridW * coarseCols);
      const ccy = Math.floor(cy / gridH * coarseRows);
      const coarseIdx = ccy * coarseCols + ccx;
      const inCoarseDirt = coarseDirty[coarseIdx] || false;

      const isEdge = cx === 0 || cy === 0 || cx === gridW - 1 || cy === gridH - 1;
      const isCorner = (cx <= 1 || cx >= gridW - 2) && (cy <= 1 || cy >= gridH - 2);
      let threshold = isCorner ? 0.25 : isEdge ? 0.40 : 0.55;
      // Cells in coarse-dirty areas are more likely to be dirty
      if (inCoarseDirt) threshold *= 0.5;
      else threshold *= (1 + dirtPercent * 0.5);
      threshold *= (1 - dirtPercent * 0.4);
      const dirty = fineRng() >= threshold;
      const opacity = (0.08 + fineRng() * 0.12) * (1 + dirtPercent * 0.5);
      cleanMask.push({ dirty, opacity, cleaned: false });
    }
  }
}

function wipeCells(canvasX, canvasY, radius) {
  if (!cleanMask) return;
  const biome = BIOMES[activeTankId] || BIOMES.fresh;
  const subY = H * (1 - biome.subH);
  if (canvasY > subY) return; // wiping below substrate does nothing
  const cellW = W / cleanGridW;
  const cellH = subY / cleanGridH; // grid maps to above-substrate area
  const cx = Math.floor(canvasX / cellW);
  const cy = Math.floor(canvasY / cellH);
  const r = Math.ceil(radius);
  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      if (dx*dx + dy*dy > r*r) continue;
      const tx = cx + dx, ty = cy + dy;
      if (tx < 0 || tx >= cleanGridW || ty < 0 || ty >= cleanGridH) continue;
      const idx = ty * cleanGridW + tx;
      if (cleanMask[idx].dirty && !cleanMask[idx].cleaned) {
        cleanMask[idx].cleaned = true;
      }
    }
  }
  updateCleanDockLabel();
}

function getCleanProgress() {
  if (!cleanMask) return 0;
  let totalDirty = 0, cleaned = 0;
  for (const c of cleanMask) {
    if (c.dirty) { totalDirty++; if (c.cleaned) cleaned++; }
  }
  return totalDirty === 0 ? 1 : cleaned / totalDirty;
}

function renderDirtOverlay() {
  dirtCtx.clearRect(0, 0, W, H);
  const tank = gameState?.tanks?.[activeTankId];
  const dirt = tank ? 1 - tank.cleanliness / 100 : 0;
  const biome = BIOMES[activeTankId] || BIOMES.fresh;
  const subY = H * (1 - biome.subH); // dirt only above substrate

  if (activeMode !== 'clean' || !cleanMask) {
    // Always show dirt texture when tank is dirty (not just clean mode)
    if (tank && tank.cleanliness < 95) {
      const rng = seededRng(activeTankId.length * 1000 + 7);
      const cellW = W / 12;
      const cellH = subY / 10; // only above ground
      for (let cy = 0; cy < 10; cy++) {
        for (let cx = 0; cx < 12; cx++) {
          if (rng() > dirt * 1.5) continue;
          const ox = cx * cellW + rng() * cellW * 0.5;
          const oy = cy * cellH + rng() * cellH * 0.5;
          if (oy > subY - 4) continue; // skip substrate area
          const w = cellW * (0.4 + rng() * 0.6);
          const h = cellH * (0.3 + rng() * 0.5);
          dirtCtx.fillStyle = `rgba(70,55,25,${dirt * 0.25 * (0.3 + rng() * 0.7)})`;
          dirtCtx.fillRect(ox, oy, w, h);
        }
      }
      // Edge film on glass (above substrate only)
      dirtCtx.fillStyle = `rgba(60,45,20,${dirt * 0.15})`;
      dirtCtx.fillRect(0, 0, W, 4);
      dirtCtx.fillRect(0, 0, 3, subY);
      dirtCtx.fillRect(W - 3, 0, 3, subY);
    }
    return;
  }
  // Clean mode: render wipe mask (above substrate only)
  const cellW = W / cleanGridW;
  const cellH = subY / cleanGridH; // map grid to above-substrate area
  for (let cy = 0; cy < cleanGridH; cy++) {
    for (let cx = 0; cx < cleanGridW; cx++) {
      const cell = cleanMask[cy * cleanGridW + cx];
      if (!cell.dirty || cell.cleaned) continue;
      const cellY = cy * cellH;
      if (cellY + cellH > subY) continue; // don't draw on substrate
      dirtCtx.fillStyle = `rgba(80, 60, 30, ${cell.opacity})`;
      dirtCtx.fillRect(cx * cellW, cellY, cellW + 0.5, cellH + 0.5);
    }
  }
}

// ═══════ LASER ═══════

function renderLaser() {
  if (activeMode !== 'laser' || !laserPos) return;
  const t = Date.now() / 200;
  const pulse = 4 + Math.sin(t) * 1.5;
  ctx.fillStyle = 'rgba(255,50,50,.7)';
  ctx.beginPath();
  ctx.arc(laserPos.x, laserPos.y, pulse, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = 'rgba(255,150,150,.4)';
  ctx.beginPath();
  ctx.arc(laserPos.x, laserPos.y, pulse + 3, 0, Math.PI * 2);
  ctx.fill();
}

// ═══════ FLOAT TEXT ═══════

function showFloatText(x, y, text, color) {
  const el = document.createElement('div');
  el.className = 'float-text';
  el.textContent = text;
  if (color) el.style.color = color;
  el.style.left = x + 'px';
  el.style.top = y + 'px';
  $('tankWrap').appendChild(el);
  setTimeout(() => el.remove(), 1600);
}

// ═══════ HUD ═══════

function updateHUD() {
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank) return;

  $('coinCount').textContent = Math.floor(gameState?.coins ?? 0);

  const clean = Math.round(tank.cleanliness);
  $('cleanFill').style.width = clean + '%';
  $('cleanFill').style.background = clean > 60 ? '#4caf88' : clean > 30 ? '#e8a040' : '#e05050';
  $('cleanVal').textContent = clean + '%';

  // Average hunger of all fish
  const fish = tank.fish || [];
  const avgHunger = fish.length > 0
    ? Math.round(fish.reduce((s, f) => s + f.hunger, 0) / fish.length)
    : 100;
  $('hungerFill').style.width = avgHunger + '%';
  $('hungerFill').style.background = avgHunger > 60 ? '#e8a040' : avgHunger > 30 ? '#e07838' : '#e05050';
  $('hungerVal').textContent = avgHunger + '%';

  // Tank nav
  const unlocked = tanksList ? tanksList.filter(t => t.unlocked) : [];
  const navEl = $('tankNav');
  if (unlocked.length > 1) {
    navEl.classList.remove('hidden');
    $('tnLabel').textContent = (BIOMES[activeTankId] || BIOMES.fresh).label;
  } else {
    navEl.classList.add('hidden');
  }

  // Container attrs
  const wc = $('widgetContainer');
  wc.dataset.tank = activeTankId;
  wc.dataset.tier = TANK_TIER_MAP[activeTankId] || '1';
}

// ═══════ TOAST ═══════

let toastTimer = null;
function showToast(msg, duration) {
  const t = $('toast');
  t.textContent = msg;
  t.classList.add('visible');
  clearTimeout(toastTimer);
  toastTimer = setTimeout(() => t.classList.remove('visible'), duration || 3000);
}

// ═══════ HUD TOOLTIP ═══════

function showHudTooltip(title, body, anchorEl) {
  $('hudTooltipTitle').textContent = title;
  $('hudTooltipBody').textContent = body;
  const tip = $('hudTooltip');
  if (anchorEl) {
    const r = anchorEl.getBoundingClientRect();
    const wr = $('widgetContainer').getBoundingClientRect();
    tip.style.top = (r.bottom - wr.top + 4) + 'px';
    tip.style.left = (r.left - wr.left) + 'px';
    tip.style.right = '';
  } else {
    tip.style.top = '38px';
    tip.style.right = '10px';
    tip.style.left = '';
  }
  tip.classList.add('visible');
  clearTimeout(tooltipTimer);
  tooltipTimer = setTimeout(() => tip.classList.remove('visible'), 4000);
}

// ═══════ FISH BUBBLE ═══════

function showFishBubble(f, px, py) {
  $('decorCard').classList.remove('visible'); // dismiss decor card
  // Track selected fish for level badge display
  selectedFishId = f.id;
  clearTimeout(selectedFishTimer);
  selectedFishTimer = setTimeout(() => { selectedFishId = null; }, 8000);

  const fb = $('fishBubble');
  const c = f._computed || {};
  const sp = tankCat?.content?.fish?.[f.speciesId];
  $('fbName').textContent = c.speciesName || f.speciesId;
  $('fbSpecies').textContent = `Lv.${f.level} ${c.lifeStage || ''}`;

  // Build detailed info
  let detailHtml = '';
  detailHtml += `<div class="fb-stats">`;
  detailHtml += `<span class="fb-stat">${iconImg('food', 10)} ${Math.round(f.hunger)}%</span>`;
  detailHtml += `<span class="fb-stat">HP ${Math.round(f.health)}</span>`;
  detailHtml += `<span class="fb-stat">Happy ${c.happiness ?? '?'}</span>`;
  detailHtml += `</div>`;
  detailHtml += `<div class="fb-earn">${iconImg('coin', 10)} ${c.coinRate ?? 0}/hr · XP ${f.xp}/${c.xpToNext || '?'}</div>`;
  if (f.weak) detailHtml += `<div class="fb-warn">Weak — Feed & clean to recover!</div>`;
  if (sp?.preferences?.schooling) detailHtml += `<div class="fb-trait">Schooling fish (0.5 space)</div>`;
  if (sp?.preferences?.movementType === 'crawl') detailHtml += `<div class="fb-trait">Bottom crawler</div>`;
  if (sp?.preferences?.movementType === 'glass') detailHtml += `<div class="fb-trait">Glass cleaner</div>`;
  if (sp?.utility?.dirtReduction) detailHtml += `<div class="fb-trait">Reduces dirt by ${Math.round(sp.utility.dirtReduction * 100)}%</div>`;

  // Action buttons
  detailHtml += `<div class="fb-actions">`;
  detailHtml += `<button class="fb-btn fb-sell" data-fb-sell="${f.id}">Sell</button>`;
  detailHtml += `</div>`;

  $('fbDetail').innerHTML = detailHtml;
  $('fbStage').textContent = '';
  // Clamp bubble within widget bounds
  const fbW = 170, fbH = 120; // approximate bubble size
  let fbLeft = Math.max(4, Math.min(px - fbW / 2, W - fbW - 4));
  let fbTop = py - fbH - 10; // prefer above fish
  if (fbTop < 4) fbTop = py + 20; // flip below if too high
  if (fbTop + fbH > H - 4) fbTop = H - fbH - 4; // clamp bottom
  fb.style.left = fbLeft + 'px';
  fb.style.top = Math.max(4, fbTop) + 'px';
  fb.classList.add('visible');
  clearTimeout(fb._timer);
  fb._timer = setTimeout(() => {
    fb.classList.remove('visible');
    if (selectedFishId) {
      const a = fishAnims[selectedFishId];
      if (a) a.wiggle = false;
      selectedFishId = null;
    }
  }, 8000);

  // Bind sell action
  const sellBtn = fb.querySelector('[data-fb-sell]');
  if (sellBtn) {
    sellBtn.onclick = async (e) => {
      e.stopPropagation();
      const res = await API.doAction('sell_fish', { fishId: f.id });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.sold) { showToast(`Sold for ${res.result.value} coins`); }
      fb.classList.remove('visible');
      if (selectedFishId) {
        const a = fishAnims[selectedFishId];
        if (a) a.wiggle = false;
        selectedFishId = null;
      }
      await refreshState();
    };
  }
}

// ═══════ DECOR CARD ═══════

function showDecorCard(d, px, py) {
  $('fishBubble').classList.remove('visible'); // dismiss fish bubble
  const dc = $('decorCard');
  const dd = tankCat?.content?.decor?.[d.decorId];
  if (!dd) return;

  $('dcName').textContent = dd.name || d.decorId;
  const growInfo = dd.growth ? `Size: ${d.size.toFixed(1)} / ${dd.growth.maxSize}` : 'Static';
  $('dcInfo').textContent = `${dd.placement} · ${growInfo}`;

  let actionsHtml = '';
  if (dd.growth) {
    const atMin = d.size <= (dd.growth.minSize + 0.01);
    actionsHtml += `<button class="dc-trim" ${atMin ? 'disabled' : ''} data-trim-decor="${d.id}">✂️ Trim</button>`;
  }
  actionsHtml += `<button class="dc-sell" data-sell-decor-card="${d.id}">Sell</button>`;
  if (dd.placement !== 'top') {
    actionsHtml += `<button class="dc-move" data-move-decor="${d.id}">↔ Move</button>`;
  }
  $('dcActions').innerHTML = actionsHtml;

  // Bind trim handler
  const trimBtn = $('dcActions').querySelector('[data-trim-decor]');
  if (trimBtn) {
    trimBtn.onclick = async () => {
      const res = await API.doAction('trim_plant', { decorInstanceId: d.id });
      if (res?.result?.trimmed) {
        showToast(`Trimmed! Size: ${res.result.newSize.toFixed(1)}`);
        await refreshState();
        dc.classList.remove('visible');
      } else if (res?.result?.error) {
        showToast(res.result.error);
      }
    };
  }

  // Bind sell handler
  const sellBtn = $('dcActions').querySelector('[data-sell-decor-card]');
  if (sellBtn) {
    sellBtn.onclick = async () => {
      const res = await API.doAction('sell_decor', { decorInstanceId: d.id });
      if (res?.result?.sold) {
        showToast(`Sold for ${res.result.value} coins`);
        await refreshState();
        dc.classList.remove('visible');
      } else if (res?.result?.error) {
        showToast(res.result.error);
      }
    };
  }

  // Bind move handler — enables drag mode for this decor
  const moveBtn = $('dcActions').querySelector('[data-move-decor]');
  if (moveBtn) {
    moveBtn.onclick = () => {
      dc.classList.remove('visible');
      draggingDecor = { id: d.id, decorId: d.decorId, offsetX: 0, offsetY: 0 };
      isDragging = true;
      showToast('Drag to reposition, then release');
    };
  }

  // Clamp decor card within widget bounds
  const dcW = 160, dcH = 80;
  let dcLeft = Math.max(4, Math.min(px - dcW / 2, W - dcW - 4));
  let dcTop = py - dcH - 10;
  if (dcTop < 4) dcTop = py + 20;
  if (dcTop + dcH > H - 4) dcTop = H - dcH - 4;
  dc.style.left = dcLeft + 'px';
  dc.style.top = Math.max(4, dcTop) + 'px';
  dc.classList.add('visible');
  clearTimeout(dc._timer);
  dc._timer = setTimeout(() => dc.classList.remove('visible'), 8000);
}

// ═══════ FAB & MENU ═══════

function toggleMenu() {
  menuOpen = !menuOpen;
  $('menuOverlay').classList.toggle('visible', menuOpen);
  $('fab').classList.toggle('active', menuOpen);
}

function closeMenu() {
  menuOpen = false;
  $('menuOverlay').classList.remove('visible');
  $('fab').classList.remove('active');
}

function handleMenuAction(action) {
  closeMenu();
  switch (action) {
    case 'feed': enterFeedMode(); break;
    case 'clean': enterCleanMode(); break;
    case 'laser': enterLaserMode(); break;
    case 'store': openPanel('storePanel'); break;
    case 'inventory': openPanel('inventoryPanel'); break;
    case 'tanks': openPanel('tanksPanel'); break;
    case 'help': openPanel('helpPanel'); break;
  }
}

// ═══════ TOOL MODES ═══════

function exitToolMode() {
  activeMode = null;
  $('toolDock').classList.remove('visible');
  $('fab').style.display = '';
  laserPos = null;
  cleanMask = null;
  selectedFoodId = null;
  $('widgetContainer').classList.remove('hud-muted');
  renderDirtOverlay();
}

function enterFeedMode() {
  exitToolMode();
  activeMode = 'feed';
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank || !tankCat) return;

  const foods = Object.entries(tank.foodStock || {}).filter(([, qty]) => qty > 0);
  const allFoods = Object.entries(tankCat.content?.food || {});
  const dock = $('toolDockContent');
  dock.innerHTML = '';

  for (const [fid, fdef] of allFoods) {
    const qty = tank.foodStock?.[fid] || 0;
    const el = document.createElement('div');
    el.className = 'dock-item' + (selectedFoodId === fid ? ' active' : '');
    el.innerHTML = `<span>${fdef.name}</span><span class="dock-qty">×${qty}</span>`;
    el.onclick = () => {
      selectedFoodId = fid;
      dock.querySelectorAll('.dock-item').forEach(d => d.classList.remove('active'));
      el.classList.add('active');
    };
    dock.appendChild(el);
  }
  // Auto-select first available food
  if (!selectedFoodId || !(tank.foodStock?.[selectedFoodId] > 0)) {
    const first = allFoods.find(([fid]) => (tank.foodStock?.[fid] || 0) > 0);
    if (first) {
      selectedFoodId = first[0];
      dock.querySelector('.dock-item')?.classList.add('active');
    }
  }

  $('toolDock').classList.add('visible');
  $('fab').style.display = 'none';
}

async function enterCleanMode() {
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank) return;
  if (tank.cleanliness >= 98) {
    showToast('Your tank is sparkling clean! ✨');
    return;
  }
  exitToolMode();
  activeMode = 'clean';
  $('widgetContainer').classList.add('hud-muted');

  const res = await API.doAction('start_clean');
  const r = res?.result;
  if (r && r.started) {
    initCleanMask(r.seed, r.gridW || 64, r.gridH || 48, r.dirtPercent);
    renderDirtOverlay();
  }

  const dock = $('toolDockContent');
  dock.innerHTML = '<span id="cleanDockLabel">Wipe to clean!</span>';
  $('toolDock').classList.add('visible');
  $('fab').style.display = 'none';
}

function updateCleanDockLabel() {
  const lbl = $('cleanDockLabel');
  if (!lbl) return;
  const prog = getCleanProgress();
  if (prog >= 0.99) {
    lbl.textContent = 'Tank cleaned! ✨';
  } else if (prog > 0) {
    lbl.textContent = `${Math.round(prog * 100)}% cleaned`;
  } else {
    lbl.textContent = 'Wipe to clean!';
  }
}

async function finishClean() {
  const progress = getCleanProgress();
  const res = await API.doAction('finish_clean', { improvementPercent: Math.round(progress * 100) });
  const r = res?.result;
  cleanMask = null;
  renderDirtOverlay();

  if (r && r.coinsEarned > 0) {
    if (progress >= 0.95) {
      showToast(`Tank cleaned! +${r.coinsEarned} coins`);
    } else {
      showToast(`Partially cleaned! +${r.coinsEarned} coins`);
    }
  } else if (progress < 0.05) {
    showToast('Barely cleaned...');
  } else {
    showToast('Partially cleaned!');
  }
  await refreshState();
}

function enterLaserMode() {
  exitToolMode();
  activeMode = 'laser';
  laserActive = true;
  laserStartTime = Date.now();

  const dock = $('toolDockContent');
  dock.innerHTML = '<span>Move your finger to play! Fish love to chase the dot.</span>';
  $('toolDock').classList.add('visible');
  $('fab').style.display = 'none';
}

async function triggerLaserReward() {
  const elapsed = Date.now() - laserStartTime;
  if (elapsed < 5000) return; // Need 5 seconds of play
  const res = await API.doAction('laser_pointer');
  const r = res?.result;
  if (r?.reward) {
    showToast(`+${r.reward.coins} coins! Fish had fun!`);
    showFloatText(W / 2, H / 2, `+${r.reward.coins}`, '#ffd866');
    await refreshState();
  } else if (r?.cooldownRemaining) {
    const mins = Math.ceil(r.cooldownRemaining / 60000);
    showToast(`Play cooldown: ${mins > 60 ? Math.floor(mins/60)+'h '+mins%60+'m' : mins+'m'}`);
  }
}

// ═══════ PANELS ═══════

function openPanel(panelId) {
  closeAllPanels();
  const el = $(panelId);
  if (!el) return;
  activePanel = panelId;
  el.classList.add('visible');
  populatePanel(panelId);
}

function closeAllPanels() {
  document.querySelectorAll('.panel').forEach(p => p.classList.remove('visible'));
  activePanel = null;
}

function populatePanel(panelId) {
  switch (panelId) {
    case 'storePanel': populateStore(); break;
    case 'inventoryPanel': populateInventory(); break;
    case 'tanksPanel': populateTanks(); break;
    case 'helpPanel': populateHelp(); break;
  }
}

function populateStore() {
  if (!storeData || !tankCat) return;
  const list = $('storeList');
  const tank = gameState?.tanks?.[activeTankId];
  const cap = tankCat.capacity?.spaceCapacity || 8;
  const used = tankCat._computed?.usedSpace || 0;
  $('storeCap').textContent = `${used}/${cap}`;

  // Tabs
  const sections = Object.keys(storeData);
  let html = '<div class="store-tabs">';
  for (const sec of ['fish','food','decor','tools']) {
    if (!storeData[sec]) continue;
    const label = sec === 'fish' ? 'Fish' : sec === 'food' ? 'Food' : sec === 'decor' ? 'Decorations' : 'Tools';
    html += `<button class="store-tab ${storeTab === sec ? 'active' : ''}" data-tab="${sec}">${label}</button>`;
  }
  html += '</div>';

  // Items for active tab
  const items = storeData[storeTab] || [];
  if (items.length === 0) {
    html += '<div style="opacity:.5;text-align:center;padding:20px">Nothing available</div>';
  }

  if (storeTab === 'fish') {
    html += `<div class="panel-section-title">Fish — Space: ${used}/${cap}</div>`;
    for (const item of items) {
      const locked = !item.canBuy;
      const reqText = item.reqInfo?.length ? `<div class="s-desc" style="color:#e8a040;opacity:.8">⚠️ ${item.reqInfo.join(', ')}</div>` : '';
      html += `<div class="s-item ${locked && item.blockReason !== 'Not enough coins' ? 'locked' : ''}">
        <div class="s-icon">${iconImg('fish', 20)}</div>
        <div class="s-info">
          <div class="s-name">${item.name}</div>
          <div class="s-desc">◆${item.spaceCost} space · ${item.baseCoinPerHour}/hr${item.ownedCount > 0 ? ' · ×' + item.ownedCount + ' owned' : ''}</div>
          ${reqText}
        </div>
        <button class="buy-btn primary" ${!item.canBuy ? 'disabled' : ''} data-buy-fish="${item.id}">
          ${item.blockReason?.includes('full') || item.blockReason?.includes('Max') ? 'Full' : item.price + ' ' + iconImg('coin', 12)}
        </button>
      </div>`;
    }
  } else if (storeTab === 'food') {
    html += '<div class="panel-section-title">Food</div>';
    for (const item of items) {
      html += `<div class="s-item">
        <div class="s-icon">${iconImg('food', 20)}</div>
        <div class="s-info">
          <div class="s-name">${item.name}</div>
          <div class="s-desc">+${item.hungerRestore} hunger · Stock: ×${item.currentStock}</div>
        </div>
        <button class="buy-btn primary" ${!item.canBuy ? 'disabled' : ''} data-buy-food="${item.id}">
          ${item.price * 5} ${iconImg('coin', 12)} ×5
        </button>
      </div>`;
    }
  } else if (storeTab === 'decor') {
    html += '<div class="panel-section-title">Decorations</div>';
    for (const item of items) {
      html += `<div class="s-item ${!item.canBuy ? 'locked' : ''}">
        <div class="s-icon" style="color:${DECOR_COLORS[item.id] || '#888'}">●</div>
        <div class="s-info">
          <div class="s-name">${item.name}</div>
          <div class="s-desc">${item.placement} · ${item.growth ? 'grows' : 'static'}${item.blockReason ? ' · ' + item.blockReason : ''}</div>
        </div>
        <button class="buy-btn primary" ${!item.canBuy ? 'disabled' : ''} data-buy-decor="${item.id}">
          ${item.price} ${iconImg('coin', 12)}
        </button>
      </div>`;
    }
  } else if (storeTab === 'tools') {
    html += '<div class="panel-section-title">Equipment</div>';
    for (const item of items) {
      html += `<div class="s-item">
        <div class="s-icon">${iconImg('wrench', 20)}</div>
        <div class="s-info">
          <div class="s-name">${item.name}</div>
          <div class="s-desc">Level ${item.currentLevel}/${item.maxLevel}${item.maxed ? ' (Max)' : ''}</div>
        </div>
        <button class="buy-btn primary" ${!item.canBuy ? 'disabled' : ''} data-buy-tool="${item.id}">
          ${item.maxed ? 'Max' : item.nextPrice + ' ' + iconImg('coin', 12)}
        </button>
      </div>`;
    }
  }

  list.innerHTML = html;

  // Tab click handlers
  list.querySelectorAll('.store-tab').forEach(tab => {
    tab.onclick = () => { storeTab = tab.dataset.tab; populateStore(); };
  });

  // Buy handlers
  list.querySelectorAll('[data-buy-fish]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('buy_fish', { speciesId: btn.dataset.buyFish });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.bought) showToast(`Bought ${btn.dataset.buyFish}!`);
      await refreshState();
      populateStore();
    };
  });
  list.querySelectorAll('[data-buy-food]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('buy_food', { foodId: btn.dataset.buyFood, quantity: 5 });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.bought) showToast(`Bought ${res.result.quantity}× food`);
      await refreshState();
      populateStore();
    };
  });
  list.querySelectorAll('[data-buy-decor]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('buy_decor', { decorId: btn.dataset.buyDecor });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.bought) showToast('Decoration placed!');
      await refreshState();
      populateStore();
    };
  });
  list.querySelectorAll('[data-buy-tool]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('buy_tool', { toolId: btn.dataset.buyTool });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.bought) showToast(`Upgraded ${btn.dataset.buyTool}!`);
      await refreshState();
      populateStore();
    };
  });
}

function populateInventory() {
  const list = $('inventoryList');
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank || !tankCat) { list.innerHTML = ''; return; }

  let html = '';

  // Food stock
  const foods = Object.entries(tank.foodStock || {}).filter(([, q]) => q > 0);
  if (foods.length > 0 || Object.keys(tankCat.content?.food || {}).length > 0) {
    html += '<div class="panel-section-title">Food Stock</div>';
    for (const [fid, fdef] of Object.entries(tankCat.content?.food || {})) {
      const qty = tank.foodStock?.[fid] || 0;
      html += `<div class="s-item">
        <div class="s-icon">${iconImg('food', 18)}</div>
        <div class="s-info">
          <div class="s-name">${fdef.name}</div>
          <div class="s-desc">Stock: ×${qty}</div>
        </div>
      </div>`;
    }
  }

  // Fish
  const fish = tank.fish || [];
  if (fish.length > 0) {
    html += '<div class="panel-section-title">Fish</div>';
    for (const f of fish) {
      const c = f._computed || {};
      const sp = tankCat.content?.fish?.[f.speciesId];
      html += `<div class="s-item">
        <div class="s-icon">${iconImg('fish', 18)}</div>
        <div class="s-info">
          <div class="s-name">${c.speciesName || f.speciesId} ${f.weak ? '⚠️' : ''}</div>
          <div class="s-desc">Lv.${f.level} ${c.lifeStage||''} · H:${c.happiness??'?'} · F:${Math.round(f.hunger)} · ${c.coinRate||0}/hr</div>
        </div>
        <button class="sell-btn" data-sell-fish="${f.id}">Sell</button>
      </div>`;
    }
  }

  // Decorations
  const decors = tank.decor || [];
  if (decors.length > 0) {
    html += '<div class="panel-section-title">Decorations</div>';
    for (const d of decors) {
      const dd = tankCat.content?.decor?.[d.decorId];
      html += `<div class="s-item">
        <div class="s-icon" style="color:${DECOR_COLORS[d.decorId]||'#888'}">●</div>
        <div class="s-info">
          <div class="s-name">${dd?.name || d.decorId}</div>
          <div class="s-desc">${dd?.growth ? 'Size: ' + d.size.toFixed(1) : 'Static'}</div>
        </div>
        <button class="sell-btn" data-sell-decor="${d.id}">Sell</button>
      </div>`;
    }
  }

  list.innerHTML = html;

  list.querySelectorAll('[data-sell-fish]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('sell_fish', { fishId: btn.dataset.sellFish });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.sold) showToast(`Sold for ${res.result.value} coins`);
      await refreshState();
      populateInventory();
    };
  });
  list.querySelectorAll('[data-sell-decor]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('sell_decor', { decorInstanceId: btn.dataset.sellDecor });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.sold) showToast(`Sold for ${res.result.value} coins`);
      await refreshState();
      populateInventory();
    };
  });
}

function populateTanks() {
  const list = $('tanksList');
  if (!tanksList) { list.innerHTML = ''; return; }

  let html = '';
  for (const t of tanksList) {
    const isCurrent = t.tankId === activeTankId;
    const b = BIOMES[t.tankId] || {};
    html += `<div class="s-item ${isCurrent ? 'active-tank' : ''}">
      <div class="s-icon">${t.unlocked ? iconImg('fish', 18) : iconImg('lock', 18)}</div>
      <div class="s-info">
        <div class="s-name">${t.name}${isCurrent ? ' — Current' : ''}</div>
        <div class="s-desc">${t.unlocked ? `${t.fishCount} fish · ${t.usedSpace}/${t.spaceCapacity} space` : t.unlockLabel}</div>
      </div>
      ${!isCurrent && t.unlocked ?
        `<button class="buy-btn primary" data-switch-tank="${t.tankId}">Switch</button>` :
        (!t.unlocked ?
          `<button class="buy-btn primary" ${!t.meetsRequirements ? 'disabled' : ''} data-unlock-tank="${t.tankId}">${t.meetsRequirements ? 'Unlock' : 'Locked'}</button>` :
          '')}
    </div>`;
  }

  list.innerHTML = html;

  list.querySelectorAll('[data-switch-tank]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('switch_tank', { tankId: btn.dataset.switchTank });
      if (res?.result?.switched) {
        await refreshState();
        closeAllPanels();
      }
    };
  });
  list.querySelectorAll('[data-unlock-tank]').forEach(btn => {
    btn.onclick = async () => {
      const res = await API.doAction('unlock_tank', { tankId: btn.dataset.unlockTank });
      if (res?.result?.error) { showToast(res.result.error); return; }
      if (res?.result?.unlocked) {
        showToast(`Unlocked ${res.result.tankName}!`);
        await refreshState();
        populateTanks();
      }
    };
  });
}

function populateHelp() {
  $('helpBody').innerHTML = `
    <div class="panel-section-title">Getting Started</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      You start with a Fresh tank and one guppy. Feed your fish, keep the tank clean, and earn coins.
      Buy more fish and supplies from the Store!
    </p>
    <div class="panel-section-title">Tanks &amp; Switching</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Multiple tank biomes are available, each with unique fish, coins, food, and decor.
      Unlock new tanks by earning lifetime coins. Fresh → Tropical → Saltwater.
    </p>
    <div class="panel-section-title">Feeding</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Open Feed mode from the menu. Tap on the tank to drop food. Switch food types in the dock.
      Different fish eat different foods — check what your fish accepts!
    </p>
    <div class="panel-section-title">Cleaning</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Dirt builds up over time. Open Clean mode and swipe to wipe away grime.
      Earn coins proportional to dirt removed! Filters and snails slow dirt accumulation.
    </p>
    <div class="panel-section-title">Play</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Open Play mode for a laser pointer. Fish will chase the dot!
      Earn coins and XP every 6 hours of cooldown.
    </p>
    <div class="panel-section-title">Decor &amp; Plants</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Buy decor from the Store. Plants grow over time — trim overgrown plants by tapping them.
      Floating plants can multiply into new clusters. Some fish require specific decor to be happy.
    </p>
    <div class="panel-section-title">Happiness &amp; Requirements</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Each fish has a happiness score (0–100). Hunger, cleanliness, tools, and decor affect happiness.
      Missing required decor or tools causes large penalties. Happy fish generate more coins!
      Tap a fish to see its happiness breakdown.
    </p>
    <div class="panel-section-title">Weak State &amp; Recovery</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Fish never die permanently. Neglected fish become Weak — they stop generating coins and appear grey.
      To recover: feed them and clean the tank. Health regenerates over time once conditions improve.
    </p>
    <div class="panel-section-title">Store Rules</div>
    <p style="font-size:12px;line-height:1.6;opacity:.8;margin-bottom:12px">
      Some items require tools or lifetime coins to unlock. Tank space limits how many fish you can have.
      Fish prices increase for each one you already own. Selling returns a fraction of the purchase price.
      Tools can't be sold — they're permanent upgrades.
    </p>
    <button class="reset-btn" id="resetBtn">Reset Aquarium</button>
  `;

  $('resetBtn').onclick = async () => {
    if (confirm('Are you sure you want to reset your aquarium? All progress will be lost!')) {
      await API.doAction('reset_state');
      await refreshState();
      closeAllPanels();
      showToast('Aquarium reset!');
    }
  };
}

// ═══════ INPUT HANDLING ═══════

function setupInput() {
  // FAB
  $('fab').onclick = toggleMenu;

  // Menu action buttons
  document.querySelectorAll('.menu-btn[data-action]').forEach(btn => {
    btn.onclick = () => handleMenuAction(btn.dataset.action);
  });



  // Panel close buttons
  document.querySelectorAll('[data-close]').forEach(btn => {
    btn.onclick = () => {
      const panelId = btn.dataset.close;
      $(panelId)?.classList.remove('visible');
      if (activePanel === panelId) activePanel = null;
    };
  });

  // Dock close
  document.querySelector('.dock-close').onclick = async () => {
    if (activeMode === 'clean' && cleanMask) {
      await finishClean();
    }
    if (activeMode === 'laser') {
      await triggerLaserReward();
    }
    exitToolMode();
  };

  // HUD tooltips
  $('coinDisplay').onclick = (e) => {
    const tank = gameState?.tanks?.[activeTankId];
    const lifetime = gameState?.lifetime?.coinsEarned || 0;
    showHudTooltip('Coins', `Current: ${Math.floor(gameState?.coins||0)}\nLifetime: ${Math.floor(lifetime)}`, $('coinDisplay'));
  };
  $('cleanBar').onclick = (e) => {
    const tank = gameState?.tanks?.[activeTankId];
    showHudTooltip('Cleanliness', `${Math.round(tank?.cleanliness||0)}%\nKeep above 60% for happy fish!`, $('cleanBar'));
  };
  $('hungerBar').onclick = (e) => {
    const fish = gameState?.tanks?.[activeTankId]?.fish || [];
    const avg = fish.length > 0 ? Math.round(fish.reduce((s,f) => s + f.hunger, 0)/fish.length) : 100;
    showHudTooltip('Hunger', `Average: ${avg}%\nFeed fish when below 70%!`, $('hungerBar'));
  };

  // Tank nav
  $('tnPrev').onclick = () => switchTankNav(-1);
  $('tnNext').onclick = () => switchTankNav(1);

  // Canvas interactions
  const canvasEl = canvas;

  function getCanvasPos(e) {
    const rect = canvasEl.getBoundingClientRect();
    const touch = e.touches ? e.touches[0] : e;
    return {
      x: (touch.clientX - rect.left) * (W / rect.width),
      y: (touch.clientY - rect.top) * (H / rect.height),
    };
  }

  canvasEl.addEventListener('mousedown', onPointerDown);
  canvasEl.addEventListener('touchstart', onPointerDown, { passive: false });
  canvasEl.addEventListener('mousemove', onPointerMove);
  canvasEl.addEventListener('touchmove', onPointerMove, { passive: false });
  canvasEl.addEventListener('mouseup', onPointerUp);
  canvasEl.addEventListener('touchend', onPointerUp);

  function onPointerDown(e) {
    if (e.touches) e.preventDefault();
    const pos = getCanvasPos(e);
    isDragging = true;

    if (activeMode === 'clean') {
      wipeCells(pos.x, pos.y, 3);
      renderDirtOverlay();
    } else if (activeMode === 'laser') {
      laserPos = pos;
    } else if (activeMode === 'feed') {
      dropFood(pos.x, pos.y);
    } else {
      // Normal mode: tap fish or decor to show info
      draggingDecor = null;
      checkFishTap(pos.x, pos.y);
    }
  }

  function onPointerMove(e) {
    if (!isDragging) return;
    if (e.touches) e.preventDefault();
    const pos = getCanvasPos(e);

    if (activeMode === 'clean') {
      wipeCells(pos.x, pos.y, 3);
      renderDirtOverlay();
    } else if (activeMode === 'laser') {
      laserPos = pos;
    } else if (draggingDecor) {
      // Move decor visually during drag
      const tank = gameState?.tanks?.[activeTankId];
      if (tank) {
        const d = tank.decor.find(d => d.id === draggingDecor.id);
        if (d) {
          d.x = Math.max(0.05, Math.min(0.95, pos.x / W));
          d.y = Math.max(0.05, Math.min(0.95, pos.y / H));
        }
      }
    }
  }

  function onPointerUp(e) {
    if (draggingDecor) {
      // Commit decor position to server
      const tank = gameState?.tanks?.[activeTankId];
      const d = tank?.decor?.find(d => d.id === draggingDecor.id);
      if (d) {
        API.doAction('move_decor', { decorInstanceId: d.id, x: d.x, y: d.y });
      }
      draggingDecor = null;
    }
    isDragging = false;
    if (activeMode === 'clean') {
      // Auto-complete check
      const prog = getCleanProgress();
      if (prog >= 0.99) {
        finishClean();
        exitToolMode();
      }
    }
  }
}

async function dropFood(x, y) {
  if (!selectedFoodId) { showToast('Select a food first!'); return; }
  const tank = gameState?.tanks?.[activeTankId];
  if (!tank || (tank.foodStock?.[selectedFoodId] || 0) <= 0) {
    showToast('Out of food! Buy more from the Store.');
    return;
  }

  const res = await API.doAction('feed', { foodId: selectedFoodId });
  if (res?.result?.error) { showToast(res.result.error); return; }
  if (res?.result?.fed) {
    const fdef = tankCat?.content?.food?.[selectedFoodId];
    foodParticles.push({
      x, y, foodId: selectedFoodId,
      sink: fdef?.sinkBehavior || 'slowSink',
      phase: Math.random() * Math.PI * 2,
      life: 12,
    });
    // Update local stock
    if (tank.foodStock[selectedFoodId]) tank.foodStock[selectedFoodId]--;
    // Refresh dock display
    enterFeedMode();
  }
}

function checkFishTap(px, py) {
  const tank = gameState?.tanks?.[activeTankId];
  const fish = tank?.fish || [];
  // Check fish first
  for (const f of fish) {
    const anim = fishAnims[f.id];
    if (!anim) continue;
    const fx = anim.x * W, fy = anim.y * H;
    // For crawl types, adjust hit position to substrate
    const biome = BIOMES[activeTankId] || BIOMES.fresh;
    const subYp = H * (1 - biome.subH);
    const effectiveY = (anim.movementType === 'crawl') ? subYp - 5 : fy;
    if (Math.abs(px - fx) < 20 && Math.abs(py - effectiveY) < 15) {
      // Trigger wiggle animation
      if (anim) {
        anim.wiggle = true;
      }
      showFishBubble(f, fx, effectiveY);
      return;
    }
  }
  // Check decor
  const decors = tank?.decor || [];
  const biome = BIOMES[activeTankId] || BIOMES.fresh;
  const subY = H * (1 - biome.subH);
  for (const d of decors) {
    const dd = tankCat?.content?.decor?.[d.decorId];
    if (!dd) continue;
    const dx = d.x * W;
    const baseSize = Math.max(12, (d.size || 1) * PX_SCALE * 8);
    let hitW, hitH, hitX, hitY;
    if (dd.placement === 'top') {
      hitW = baseSize * 2; hitH = 16; hitX = dx; hitY = 6;
    } else if (dd.growth) {
      hitW = baseSize * 1.5; hitH = baseSize * 4; hitX = dx; hitY = subY - hitH;
    } else {
      hitW = baseSize * 2.8; hitH = baseSize * 1.8; hitX = dx; hitY = subY - baseSize * 0.9;
    }
    if (Math.abs(px - hitX) < hitW / 2 && py > hitY - 4 && py < hitY + hitH + 4) {
      showDecorCard(d, px, py);
      return;
    }
  }
  // No fish/decor tapped — dismiss popups and stop wiggle
  $('fishBubble').classList.remove('visible');
  $('decorCard').classList.remove('visible');
  if (selectedFishId) {
    const oldAnim = fishAnims[selectedFishId];
    if (oldAnim) oldAnim.wiggle = false;
    selectedFishId = null;
  }
}

async function switchTankNav(dir) {
  if (!tanksList) return;
  const unlocked = tanksList.filter(t => t.unlocked);
  const currentIdx = unlocked.findIndex(t => t.tankId === activeTankId);
  const nextIdx = (currentIdx + dir + unlocked.length) % unlocked.length;
  const nextTank = unlocked[nextIdx];
  if (nextTank && nextTank.tankId !== activeTankId) {
    exitToolMode();
    const res = await API.doAction('switch_tank', { tankId: nextTank.tankId });
    if (res?.result?.switched) await refreshState();
  }
}

// ═══════ STATE SYNC ═══════

async function refreshState() {
  try {
    const res = await API.getState();
    if (!res) return;
    applyState(res);
  } catch (err) {
    console.error('Failed to refresh state:', err);
  }
}

function applyState(res) {
  gameState = res.save;
  activeTankId = res.activeTankId || gameState?.activeTankId || 'fresh';
  tankCat = res.tankCatalog;
  storeData = res.store;
  tanksList = res.tanksList;

  // Prune anims for fish no longer present
  const fishIds = new Set((gameState?.tanks?.[activeTankId]?.fish || []).map(f => f.id));
  for (const id of Object.keys(fishAnims)) {
    if (!fishIds.has(id)) delete fishAnims[id];
  }

  updateHUD();

  // Refresh active panel if open
  if (activePanel) populatePanel(activePanel);
}

// ═══════ GAME LOOP ═══════

function gameLoop(timestamp) {
  const dt = Math.min((timestamp - lastFrameTime) / 1000, 0.1) || 0.016;
  lastFrameTime = timestamp;

  resizeCanvas();

  const tank = gameState?.tanks?.[activeTankId];
  const fish = tank?.fish || [];

  // Update
  updateFishAnim(fish, dt);
  updateFoodParticles(dt);
  updateBubbles(dt, activeTankId);

  // Render (layered: back decor → equipment → fish → front decor → particles)
  ctx.clearRect(0, 0, W, H);
  renderEnvironment(activeTankId);
  renderDecorBack(tank?.decor, activeTankId);
  renderEquipment(tank?.toolsOwned);
  renderFish(fish);
  renderDecorFront(tank?.decor, activeTankId);
  renderFoodParticles();
  renderBubbles();
  renderLaser();
  renderDirtOverlay();

  requestAnimationFrame(gameLoop);
}

// ═══════ RESIZE ═══════

function resizeCanvas() {
  const rect = canvas.parentElement.getBoundingClientRect();
  const newW = Math.round(rect.width);
  const newH = Math.round(rect.height);
  if (newW === W && newH === H) return;

  DPR = window.devicePixelRatio || 1;
  W = newW;
  H = newH;
  canvas.width = W * DPR;
  canvas.height = H * DPR;
  canvas.style.width = W + 'px';
  canvas.style.height = H + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  ctx.imageSmoothingEnabled = false;

  dirtCanvas.width = W * DPR;
  dirtCanvas.height = H * DPR;
  dirtCanvas.style.width = W + 'px';
  dirtCanvas.style.height = H + 'px';
  dirtCtx.setTransform(DPR, 0, 0, DPR, 0, 0);

  PX_SCALE = Math.max(2, Math.floor(Math.min(W, H) / 100));
  buildSpriteCache();
}

// ═══════ HELPERS ═══════

function seededRng(seed) {
  let s = seed | 0;
  return function() { s = (s * 1664525 + 1013904223) | 0; return (s >>> 0) / 4294967296; };
}

function shadeColor(hex, amt) {
  let r = parseInt(hex.slice(1,3),16) + amt;
  let g = parseInt(hex.slice(3,5),16) + amt;
  let b = parseInt(hex.slice(5,7),16) + amt;
  r = Math.max(0,Math.min(255,r));
  g = Math.max(0,Math.min(255,g));
  b = Math.max(0,Math.min(255,b));
  return `rgb(${r},${g},${b})`;
}

// ═══════ PIXEL ICON INIT ═══════

function initPixelIcons() {
  document.querySelectorAll('[data-icon]').forEach(el => {
    const key = el.dataset.icon;
    if (!ICON_DATA[key]) return;
    let size = 14;
    if (el.classList.contains('menu-icon')) size = 24;
    else if (el.id === 'fab') size = 20;
    else if (el.classList.contains('tn-btn')) size = 12;
    el.innerHTML = iconImg(key, size);
  });
}

// ═══════ INIT ═══════

async function init(homey) {
  if (homey) window.Homey = homey;
  try {
    await Homey.ready();
  } catch (e) {
    // Standalone / sandbox mode
  }

  await API.init();
  setupInput();
  initPixelIcons();
  resizeCanvas();

  // Check reset setting
  try {
    const settings = await Homey.getSettings();
    if (settings?.reset_state) {
      await API.doAction('reset_state');
      try { await Homey.set('reset_state', false); } catch(e) {}
    }
  } catch (e) { /* ignore in sandbox */ }

  // Initial state load
  const res = await API.getState();
  if (res) {
    applyState(res);

    // Show "while you were away" if significant idle earnings
    if (res.simResult?.coinsEarned > 5) {
      showToast(`While away: +${res.simResult.coinsEarned} coins earned!`, 4000);
    }
  }

  // Hide loading
  $('loading').classList.add('hidden');

  // Start game loop
  lastFrameTime = performance.now();
  requestAnimationFrame(gameLoop);

  // Periodic refresh every 5 minutes
  refreshTimer = setInterval(refreshState, 5 * 60 * 1000);
}

window.onHomeyReady = init;
</script>
</body>
</html>
